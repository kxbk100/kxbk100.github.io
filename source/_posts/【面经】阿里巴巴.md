---
title: 【面经】阿里巴巴
date: 2019年04月08日 00:27:43
categories: Career
typora-root-url: ..
typora-copy-images-to: ../images
---

# 一面（电话+在线编程）
> 对象是一个嵌套结构的，需要把对象抹平，然后从最深处开始输出。这个题当时给定了一个方法的调用形式，包含了函数参数。然后完成这个flatten函数

思想是递归实现

>  1. 自我介绍
- 讲话可以稍微低沉一些，语速可以降低，这样显的自信
- 不做害羞的动作，例如不自觉的玩手指，不敢与面试官眼神交流，眼睛四眼无神等
- 抬头挺胸，目光直视hr
- 轮到自己发言时，眼光顺序：最左-中间-最右-中间，时间大概2-3秒，然后再大声的开始自我介绍。这样子的话全场目光都会聚焦在你身上
---
- 大家好，我叫冯天祥，来自浙江科技学院软件工程专业，今天面试的岗位为前端工程师
- 我曾应邀赴斯里兰卡参加境外国际学术会议并作英文报告，为IEEE Fellow的教授们做导游，玩遍斯里兰卡
- 计划了为期一月的旅游，游遍了大西北
- 学院我开发的ISchool学生事务管理系统完成了全体学生的三轮专业分流工作，一改纸质操作，避免数据录入错误，教务处工作量减少50%，工作周期从16天减少至7天
- 熟练使用JavaScript（含ES6）
- HTML、CSS开发页面进行前后端完全分离开发
- 使用过Bootstrap、Framework7、layui、SUI Mobile等UI框架
- 了解前端模块化开发及性能优化
- 掌握Axure原型工具的使用
- 喜欢外出，不做宅男，身体健康，乐意加班

>  2. 你有做过微信小程序，主要做了些什么事情


>  3. 你为什么选择前端开发

- 2009年，小学四年级的我，报了一个Frontpage的网页制作班，在座的所有人中我最小
- 2010年，小学毕业的我对平面设计产生了浓厚的兴趣。我参加了一个成人Photoshop学习班，坚实的知识加上我四年的水墨画功底，在那里毫不逊色
- 现在，学校的许多海报，logo是由我设计制作的
- 刚进入高中的我接触到了Dreamweaver
- 同年我接触到了淘宝客，我和朋友挑选了几个高中生的感兴趣的版块进行推广，在发现了单一营销的低效率之后，凭着自己那三脚猫功夫做出一个丑陋的单页面网站。在那之后我便开始了两个礼拜的WordPress学习，并通过国外一个免费的域名和空间提供商，架起了我的第一个淘宝客网站，实现了梦想，也赚得了500元的人生第一桶金
- 刚进入大一，跟着导师做项目，当时也就前端可以搭把手，但第一次接触就爱上了前端，后来自己申报国创新苗项目，也写过一段时间的php。对于大多数人来说，在一开始做哪个方向是不一定的，只是做着做着成就感出来了，看着自己的作品给大家看见和使用，这才觉得要往这个方向深入做，由于自己的美术功底，对于页面元素及布局也有严格的要求和自己独特的想法，对色彩也有一定的敏感度，发现前端是越学习越喜欢的东西，后面越做就越进去了

>  4. 前端开发的学习路径

html css Bootstrap js jQuery Vue.js

>  5. js引擎，事件循环机制

https://segmentfault.com/a/1190000012806637
- JS是单线程语言
- JS是异步执行的
- JS的事件循环(event loop)是JS的执行机制，通过Event Loop可以实现单线程并异步执行
---
- 首先判断JS是同步还是异步,同步就进入主线程,异步就进入event table
- 异步任务在event table中注册函数,当满足触发条件后,被推入event queue
- 同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中
---
宏任务
- script代码
- setTimeout/setInterval
- I/O
- UI交互
- setImmediate(nodejs环境中)

微任务：一个EL中只有一个微任务队列
- promise（promise的then和catch才是microtask，本身其内部的代码并不是）
- MutationObserver
- process.nextTick(nodejs环境中)
---
- 执行script下的宏任务，遇到其它宏任务放置宏任务队列，遇到微任务放置微任务队列
- 当前宏任务执行完成后，会查看微任务的队列，并将里面**全部的**微任务依次执行完
- 执行队列中的宏任务，过程中如果遇到微任务，就将其放到微任务队列里

>  6. es6了解吗，说下箭头函数，和普通函数的区别

https://www.jianshu.com/p/73cbeb6782a0
- 箭头函数作为匿名函数，是不能作为构造函数的，不能使用new
- 箭头函数不绑定arguments，取而代之用rest参数…解决
- 箭头函数会捕获其所在上下文的this值，作为自己的this值
- 箭头函数当方法使用的时候没有定义this绑定
b是一个箭头函数，然后它的 this是指向window，这是为什么呢，因为箭头函数捕获的是obj{}这个对象的环境，然后这个环境的this指向的是window，就相当于上一条的例子：在c方法里面return的那个箭头函数捕获的是c:function(){}这个环境的this，而这个环境的this是obj，这样是不是就清晰明了了
- 使用call()和apply()调用
- 箭头函数没有原型属性
- 箭头函数不能当做Generator函数，不能使用yield关键字
- 箭头函数不能换行
- 箭头函数的this永远指向其上下文的this，任何方法都改变不了其指向，如call(), bind(), apply()
- 普通函数的this指向调用它的那个对象（指向其上下文）

>  7. vue的数据双向绑定什么意思？

https://blog.csdn.net/zhang5207892/article/details/78389121
- 单向数据绑定：DOM操作直接改变
- 数据模型（Module）和视图（View）之间的双向绑定
- 用户在视图上的修改会自动同步到数据模型中去，同样的，如果数据模型中的值发生了变化，也会立刻同步到视图中去
- 双向数据绑定的优点是无需进行和单向数据绑定的那CRUD（Create，Retrieve，Update，Delete）操作
- 双向数据绑定最经常的应用场景就是表单了，这样当用户在前端页面完成输入后，不用任何操作，我们就已经拿到了用户的数据存放到数据模型中了

>  8. vue数据双向绑定的原理？

https://juejin.im/entry/5923973da22b9d005893805a
- vue数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，那么vue是如何进行数据劫持的，我们可以先来看一下通过控制台输出一个定义在vue初始化数据上的对象是个什么东西
- 我们可以看到属性a有两个相对应的get和set方法，为什么会多出这两个方法呢？因为vue是通过Object.defineProperty()来实现数据劫持的。
- Object.defineProperty( )可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先来研究下它对应的两个描述属性get和set
```js
var Book = {
  name,
};
Object.defineProperty(Book, "name", {
  set: function (value) {
    name = value;
    console.log("你取了一个书名叫做" + value);
  },
  get: function () {
    return "《" + name + "》";
  }
})
Book.name = "冯天祥"
console.log(Book.name);  // 《冯天祥》
```
- 我们通过Object.defineProperty( )设置了对象Book的name属性，对其get和set进行重写操作
- get就是在读取name属性这个值触发的函数，当读取这个属性时，就会输出 "《vue权威指南》"，因为我们在get函数里面对该值做了加工了
- set就是在设置name属性这个值触发的函数，所以当执行 Book.name = 'vue权威指南' 这个语句时，控制台会打印出 "你取了一个书名叫做vue权威指南"
- 因为view更新data其实可以通过事件监听即可，比如input标签监听 'input' 事件就可以实现了，关键点在于data如何更新view
- 数据更新视图的重点是如何知道数据变了，只要知道数据变了，那么接下去的事都好处理。如何知道数据变了，其实上文我们已经给出答案了，就是通过Object.defineProperty( )对属性设置一个set函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现data更新view了
- 实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图
- 实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者
- 实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图
- 实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。
![](https://img-blog.csdnimg.cn/20190303143205773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t4YmsxMDA=,size_16,color_FFFFFF,t_70)
>  9. 跨域的几种形式

https://www.jianshu.com/p/447fe4d86dd5
- jsonp：script标签不受同源策略的限制，在页面中*动态插入*了**script**，script标签的src属性就是后端api接口的地址，并且以get的方式（不能是post）将前端回调处理函数名称告诉后端，后端在响应请求时会将回调返还，并且将数据以参数的形式传递回去
- CORS(Cross-Origin Resource Sharing)(跨域资源共享)：允许当前域（origin）的资源（比如html/js/web service）被其他域（origin）的脚本请求访问的机制。当使用XMLHttpRequest发送请求时，浏览器如果发现违反了同源策略就会自动加上一个请求头：origin，后端在接受到请求后确定响应后会在Response Headers中加入一个属性：Access-Control-Allow-Origin，值就是发起请求的源地址(http://127.0.0.1:8888)，浏览器得到响应会进行判断Access-Control-Allow-Origin的值是否和当前的地址相同，只有匹配成功后才进行响应处理，会忽略cookie
- 服务器跨域：在前后端分离的项目中可以借助服务器实现跨域，具体做法是：前端向**本地服务器**发送请求，本地服务器代替前端再向api服务器接口发送请求进行服务器间通信，**本地服务器其实就是个中转站的角色**，再将响应的数据返回给前端，现代浏览器中和移动端都支持CORS（除了opera mini），IE下需要8+
- postmessage：在HTML5中新增了postMessage方法，postMessage可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3和Safari 4都支持postMessage。该方法可以通过绑定window的message事件来监听发送跨文档消息传输内容。使用postMessage实现跨域的话原理就类似于jsonp，**动态插入iframe标签**，再从iframe里面拿回数据，私认为用作跨页面通信更加适合

>  10. 闭包的概念？作用？问题？作用域的相关问题
>  11. 事件冒泡是什么？如何阻止事件冒泡？
>  12. 还做过别的相关的吗？用过react吗？
>  13. css的position有哪几种？默认情况？区别？
>  14. 原型链，继承
>  15. vue组件间的通信

