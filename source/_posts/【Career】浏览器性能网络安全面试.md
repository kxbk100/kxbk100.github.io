---
title: 【Career】浏览器性能网络安全面试
date: 2019年04月08日 00:27:43
categories: Career
typora-root-url: ..
typora-copy-images-to: ../images
---

@[TOC]
# 浏览器

> 事件的触发过程是怎么样的？

- **事件捕获**：当我们在某个元素上触发了某个事件后，`window` 会顺着DOM节点往事件触发处传播，在这过程中，遇到**注册的捕获事件**会触发
- **事件处理**：传播到事件触发处时触发绑定函数
- **事件冒泡**：从事件触发处往 `window` 传播，在这过程中，遇到**注册的冒泡事件**会触发
- 但是也有特例，如果给一个 body 中的子节点同时注册冒泡和捕获事件，**事件触发**会按照**注册的顺序**执行
- 我们使用 `addEventListener` 注册事件，该函数的第三个参数可以是布尔值，也可以是对象，默认为`false` 注册为冒泡，`true`为捕获
- 我们一般希望**事件只触发在目标上**，这时候可以使用 `stopPropagation` 来阻止事件的进一步传播。 `stopPropagation` 可以阻止**事件冒泡**和**事件捕获**
- `stopImmediatePropagation` 同样也能实现阻止事件，但是还能阻止该事件**目标执行**的别的注册事件

> 知道什么是事件委托（代理）吗？

- 事件代理利用的就是浏览器的**事件冒泡**
- 比如说如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话**应该注册在父节点上**，通过父节点来触发函数
- 特殊处理的元素通过`stopPropagation`阻止冒泡
- 代理的方式相较于直接给目标注册事件来说更加**节省内存**，而且不需要**给子节点注销事件**

> ⚠️输入 URL 到页面渲染的整个流程

**首先通过DNS查询获取IP**

- 如果这一步做了**智能 DNS 解析**的话，会提供**访问速度最快**的 IP 地址回来
- 如果没有的话，操作系统会首先在**本地缓存**中查询 IP
- 没有的话会去系统配置的 **DNS 服务器**中查询
- 如果这时候还没得话，会直接去 **DNS 根服务器**查询，这一步查询会找出**负责一级域名的服务器**，然后去该服务器查询二级域名
- 接下来三级域名的查询其实是我们配置的，你可以给 www 这个域名配置一个 IP，然后还可以给别的三级域名配置一个 IP

------

以上介绍的是 DNS 迭代查询，还有种是递归查询，区别就是DNS迭代查询是由**客户端**去做**请求**，而递归查询是由**系统配置的 DNS 服务器**做**请求**，得到结果后将数据返回给客户端。
PS：DNS 是基于 UDP 做的查询

<hr>

**TCP连接**

- 接下来是 TCP 握手，**应用层**会下发数据给**传输层**，这里 **TCP 协议**会指明两端的端口号，然后下发给**网络层**
- 网络层中的 **IP 协议**会确定 IP 地址，并且指示数据传输中如何**跳转路由器**
- 然后包会再被封装到**数据链路层**的**数据帧结构**中
- 最后就是**物理层面**的传输了
- 当 **TCP 握手**结束后就会进行 **TLS 握手**，然后就开始正式的传输数据

------

在这一部分中，可以详细说下 TLS 的握手情况以及两种加密方式的内容

<hr>

**HTTP请求及响应**

**服务器响应**

数据在进入服务端之前，可能还会先经过**负载均衡**的服务器，它的作用就是将请求合理的分发到多台服务器上，然后服务端会响应一个 HTML 文件

- 首先**浏览器**会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个**重定向计数器**，避免过多次的重定向，超过次数也会报错
- 接下来浏览器开始**解析文件**，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式去解码文件

**客户端渲染**

**首先浏览器接收到 HTML 文件并转换为 DOM 树，在这一过程中**

- 浏览器接收到0、1这些字节数据后，会将这些**字节数据转换为字符串**，也就是我们写的代码
- 当数据转换为字符串以后，浏览器会通过**词法分析**转换为**标记**，标记还是字符串，是构成代码的**最小单位**
- **标记**会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树
- 在解析 HTML 文件的时候，浏览器也会去下载并解析 CSS 和 JS 文件

**CSS 文件也会被转换为 CSSOM，过程和生成DOM树类似**

- 浏览器会确定每一个节点的**样式**到底是什么
- 样式可以自行设置给某个节点，也可以通过**继承**获得
- 在这一过程中，浏览器得**递归** CSSOM 树，十分**消耗资源**
- 所以我们应该尽可能的避免写**过于具体**的 CSS 选择器，避免无意义的HTML标签，保证**层级扁平**

**当遇到script标签时，会暂停构建DOM**

- 当 `script` 标签加上 `defer` 属性以后，表示该 JS 文件会并行下载，defer是**异步加载**，延后执⾏，会在HTML解析完毕之后，DOMContentLoaded之前执⾏，defer执⾏顺序按照script标签先后顺序执⾏，但是实际中不⼀定是按顺序的，可以把 `script` 标签放在任意位置
- 当`script` 标签加上 `async` 属性以后，表示该 JS 文件会并行下载并执行，不会阻塞渲染，async是**异步加载**，加载完⽴即执⾏，并且会和HTML解析并⾏执⾏，也就是说，执⾏脚本的时候会阻塞HTML解析，async执⾏顺序也不⼀定
- 如果 `script` 标签没有这些属性，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这也是都建议将 `script` 标签放在 `body` 标签底部的原因
- 如果使用 HTTP/2 协议的话会极大的提高多图的下载效率

**接下来是生成渲染树，确定页面元素的布局、样式等**

- 这不是简单的将DOM和CSSOM简单合，渲染树只会包括**需要显示的节点**和这些节点的样式信息，如果某个节点是 `display: none` 的，那么就不会在渲染树中显示
- 当浏览器生成渲染树以后，就会根据渲染树来进行**布局**，然后调用 GPU 绘制，合成图层，显示在屏幕上

> 为什么操作DOM慢？

- **DOM** 是属于**渲染引擎**中的东西
- **JS** 是属于 **JS 引擎**中的东西
- 当我们通过 JS 操作 DOM 的时候，其实涉及到了**两个线程之间的通信**
- 操作 DOM 次数一多，也就等同于**一直在进行线程之间的通信**，并且操作 DOM 可能还会带来**重绘重排**的情况，所以会导致性能上的一些问题
- DOM操作的多叉树，复杂度为`O(n^3)`

> 插入几万个 DOM，如何实现页面不卡顿？

- 解决这个问题我们可以采用**分批次部分渲染 DOM**的方法
- 通过 `requestAnimationFrame` 的方式去**循环的插入 DOM**
- 也可以通过**虚拟滚动**来实现，它的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就**实时去替换渲染的内容**
- 即使页面/列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM

> 什么情况阻塞渲染

- 渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果想要渲染的越快，就应该降低一开始需要渲染的文件**大小**，并且**扁平层级，优化选择器**
- 如果 `script` 标签没有 `defer` 、`async` 这些属性，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这也是都建议将 `script` 标签放在 `body` 标签底部的原因

> 什么是重绘和重排？

重绘和重排会在我们**设置节点样式**时频繁出现，同时也会很大程度上影响性能

- 重绘是当节点需要**更改外观**而**不会影响布局**的，比如改变 `color` 
- 重排是**布局**或者**几何属性**需要改变
- 重排**必定**会发生重绘，重绘**不一定**会引发重排
- 重排所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列重排

重绘和重排其实也和 Eventloop 有关

1. 当 Eventloop 执行完 Microtasks 后，会判断 `document` 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次
2. 然后判断是否有 `resize` 或者 `scroll` 事件，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能。
3. 判断是否触发了 media query
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执行 `requestAnimationFrame` 回调
7. 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
8. 更新界面
9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调

> ⚠️跨域

只要协议、域名、端⼝有任何一个不同，都被当作是不同的域，Ajax请求就会失败，同源策略只要是为了防止CSRF攻击，CSRF 攻击是利用用户的登录态发起恶意请求。跨域并不能完全阻止 CSRF，因为请求还是发出去了，只是浏览器拦截了**响应**

**解决方案**

**首选肯定是CORS**

- CORS需要服务端设置`Access-Control-Allow-Origin`，该属性表示哪些**域名**可以访问资源
- 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。
- 如果需要携带cookie，需要`Access-Control-Allow-Credentials`，同时前端需要加上`withCredentials`

**然后是JSONP**

- JSONP的原理就是利⽤ `<script>` 标签可以跨域请求资源，它的原理就是动态插⼊ `<script>` ，src为请求的地址，将请求数据放⼊callback返回
- **只⽀持GET请求，不⽀持POST等其它类型的HTTP请求**
- 利⽤`<script>`的onload和readyState事件可以进⾏超时处理
- 利⽤浏览器的onerror事件处理服务器的错误，它的本质还是`<script>`的异常监控

**postMessage**

- 通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息
- 利用`window.postMessage(data, domain)`这个方法发送信息
- 通过message事件获取`receiveMessage`来接收信息，`receiveMessage`包括data，origin，source，需要通过origin和source保证安全

**document.domain**

- 该方式只能用于**二级域名相同**的情况下，比如 `a.test.com` 和 `b.test.com` 
- 只需要给页面添加 `document.domain = 'test.com'` 表示二级域名都相同就可以实现跨域

# 性能

> ⚠️前端性能优化

一个是网络方面（6），一个是渲染方面（8 + HTML、CSS书写7）

**减少HTTP资源请求次数**

- 使用CSS雪碧图，HTTP2不需要，多路复⽤，单连接多资源，减⼩了压力，提⾼了吞吐量
- bundle js和css

**减⼩ HTTP 请求⼤⼩**

- ⽹⻚gzip
- 压缩js和css
- 压缩静态图⽚资源

**避免使⽤空的src和href（浏览器会加载直到超时）**

**设置强缓存和协商缓存**

**使⽤CDN管理静态资源**

**cookie隔离，不需要携带cookie的请求不携带**

**⻚⾯渲染**

加快页面渲染速度的关键在于提前 `DOMContentLoaded` 事件，当发生 `DOMContentLoaded` 事件后，就会生成渲染树，生成渲染树就可以进行渲染了，这一过程更大程度上和硬件有关系了

**减少⻚⾯重排和重绘**
- 尽量减少使⽤JS动画（容易引起重排和重绘）
- 减少使⽤iframe（会阻塞）

**从文件大小考虑**

渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果想要渲染的越快，就应该降低一开始需要渲染的文件**大小**，并且**扁平层级，优化选择器**

**从 `script` 标签使用上来考虑**

- 当 `script` 标签加上 `defer` 属性以后，表示该 JS 文件会并行下载，defer是**异步加载**，延后执⾏，会在HTML解析完毕之后，DOMContentLoaded之前执⾏，defer执⾏顺序按照script标签先后顺序执⾏，但是实际中不⼀定是按顺序的，可以把 `script` 标签放在任意位置
- 当`script` 标签加上 `async` 属性以后，表示该 JS 文件会并行下载并执行，不会阻塞渲染，async是**异步加载**，加载完⽴即执⾏，并且会和HTML解析并⾏执⾏，也就是说，执⾏脚本的时候会阻塞HTML解析，async执⾏顺序也不⼀定
- 如果 `script` 标签没有这些属性，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这也是都建议将 `script` 标签放在 `body` 标签底部的原因
- 如果使用 HTTP/2 协议的话会极大的提高多图的下载效率

**从 CSS、HTML 的代码书写上来考虑**

- 使用 `transform` 替代 `top`
- 使用 `visibility` 替换 `display: none` ， `visibility` 只会引起重绘，而 `display: none` 会引发重排，改变了布局
- 不要把节点的**属性值**放在一个循环里当成循环里的变量
- 不要使用 `table` 布局，可能很小的一个小改动会造成整个 `table` 的重排
- 动画实现的速度的选择，动画速度越快，重排次数越多，也可以选择使用 `requestAnimationFrame`
- CSS 选择符**从右往左**匹配查找，避免节点层级过多，避免写**过于具体**的 CSS 选择器，避免无意义的HTML标签，保证**层级扁平**
- 将频繁重绘或者重排的节点设置为图层，图层能够阻止**该节点的渲染行为影响别的节点**。比如浏览器会自动将 `video` 标签和 `iframe` 标签变为图层，普通标签通过`will-change`实现

**从需要下载的内容是否需要在首屏使用上来考虑**

**meta dns prefetch 设置 DNS 预解析**

**资源预加载**

**图⽚懒加载**

**单⻚应⽤路由懒加载**

# 网络

> HTTP状态码

- 200：请求成功
- 301：永久重定向
- 302：临时重定向
- 304：资源未修改，返回body为空
- 400：客户端语法错误，服务器⽆法理解
- 404：请求资源不存在
- 500：服务器内部错误

> 301和302的区别是什么

- 301：永久重定向，原地址被删除
- 302：临时重定向，原地址还存在，SEO抓取不知道抓原站还是302的，而且有可能被劫持

> cookie和session的区别

- cookie存储于浏览器端，而session存储于服务端
- cookie大小4k左右，session服务端无限制

> localStorage、sessionStorage、cookie和IndexDB的区别

- cookie大小4k，sessionStorage和localStorage大小5M，IndexDB没有限制
- localStorage和IndexDB一直有效，除非手动删除；sessionStorage在浏览器关闭就失效；cookie一般由服务器生成，可以设置过期时间
- localStorage、sessionStorage、IndexDB均不参与服务器通信，而cookie每次都会携带在 header 中，对于请求性能有影响，所以现在一般不用于存储了
- sessionStorage不能在**不同**页面间共享，而localStorage和cookie在所有同源页面间可以共享
- 对于 `cookie` 来说，我们还需要注意安全性，value不能使用明文存储，http-only设置不能通过JS访问Cookie，减少XSS攻击，secure设置协议为HTTPS协议才能访问，same-site设置浏览器不能在跨域请求中携带Cookie，防止CSRF攻击

> GET 和 POST 的区别是什么

- get⽤于获取数据，post⽤于提交数据
- get参数拼接在**url**中，⼤⼩在2K左右，具体大小还是由浏览器决定的；post参数放在**body**中，无大小限制
- 按照规范get是幂等的，多次请求结果一致；而post是不幂等的

------

幂等意思就是说，一个方法无论执行多少次，结果都会是一样

> ⚠️HTTP缓存

**强缓存**：浏览器发送请求前，根据**请求头**的`expires`和`cache-control`判断是否命中**强缓存策略**，如果命中，直接从缓存获取**资源**

- 需要在**服务端设置** `expires`和`cache-control`
- expires：绝对时间，但是如果浏览器和服务端时间误差比较大的话，会有一定偏差
- cache-control：相对时间长度
- 所以在**优先级**方面：`cache-control` > `expires`
- 强缓存HTTP状态码为200
- 强缓存不会发送多余请求

**协商缓存**：浏览器发送请求前，根据**请求头**的`last-modified` 和 `etag` 判断是否命中**协商缓存策略**，如果命中，直接从缓存获取资源

- 会根据`if-modified-since: last-modified` 或 `if-none-match: etag`来进行判断缓存是否**过期**
- `if-modified-since: last-modified`：浏览器在**第⼆次请求**会带上 `if-modified-since: last-modified`，根据浏览器和服务器的修改时间⽐对，如果一致表示命中。保存单位是秒，所以1秒以内的改动会检测不到，这个比对是个只读操作
- `if-none-match: etag`：浏览器在**第⼆次请求**会带上 `if-none-match: etag`** 并和服务端生成的 `etag` ⽐较，所以会有读和写操作，如果⼀致表示命中。`if-none-match: etag` 这样的方式解决了秒级的问题，但是每次都有读写消耗
- 协商缓存HTTP状态码为304
- 协商缓存会向服务端发送请求，返回body为空，内容小的多
- 强制刷新办法：`?v=xxx`

> ⚠️TCP三次握⼿和四次挥⼿

**三次握手**

- client发送syn，进⼊syn_send
- server应答ack，进⼊syn_received
- client发送ack，进⼊established，server接收后，也进入established

**四次挥手**

- client发送fin，进入fin_wait_1
- server发送**确认包**，进⼊close_wait，client接收后，进入fin_wait_2
- server发送**结束请求**，进入last_ack，client接收到后发送**确认包**，进入time_wait
- server接收后，进⼊closed，client在⼀定时间没有收到ack也会进入closed

> webSocket协议

**是什么**

- 建⽴在TCP协议上
- 与HTTP协议兼容
- 数据较小，尤其是头部，所以开销较小
- 可以发送⽂本和二进制
- 没有同源策略

**与HTTP轮询相⽐**

- 头部很小，消耗比较少
- webSocket是**长连接**，它会**保持状态**
- 能够接收到服务端的push

**建立连接的过程**

- 首先，TCP三次握⼿
- 浏览器发送：key，protocol，version
- 服务器返回：accept，protocol

**webSocket常用的事件**

- onopen
- onclose
- onmessage
- onerror

> HTTPS和HTTP2

**HTTPS**

- HTTP是建立在TCP协议上，HTTPS是建立在SSL/TLS协议上，SSL/TLS运行在TCP上，会有⼀层加密
- HTTP端口为80，HTTPS端⼝为443
- HTTPS可以有效防⽌运营商劫持

**HTTP2**

- 多路复⽤。单连接多资源，减⼩了压力，提⾼了吞吐量
- header也压缩了。使⽤HPACK算法，header更小了
- HTTP2使用服务端推送

------

HPACK的原理是使用2个索引表（**静态索引表**和**动态索引表**）来把**头部映射**到索引值，并对不存在的头部使用哈夫曼编码，并**动态缓存**到索引，从而达到压缩头部的效果



# 安全

> ⚠️XSS和CSRF

**XSS：跨站脚本攻击**

想尽一切办法将可执行的代码注入网页，如果不过滤执⾏JS代码，可能导致cookie泄露等，比如在评论框输⼊JS脚本，获取到cookie等敏感信息

**XSS防御**

- 通过转义字符对输⼊来源进⾏过滤
- 为富文本编辑器等设置CSP白名单，通过设置 `HTTP Header Content Security Policy` 和 `meta` 来规定哪些**外部资源**可以执行加载，兼容性也不错

**CSRF：跨站请求伪造**

在已经授权的⽹站中发起某些请求，伪造一些恶意的请求，比如说构造出一个后端请求地址

**CSRF防御**

- 服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效
- 调用接口时，验证Referer来判断是否为第三方网站发起的请求
- cookie设置为SameSite不随着跨域请求发送
- 设置Get请求不可对数据进行修改，只能通过后台逻辑修改

> ⚠️前端异常监控

- `window.onerror`：全局错误处理，⽤于运⾏错误，**跨域脚本**会返回 `script error`
- 资源404：`window.addEventListener('error', fn, true)`，但是必须在**捕获**阶段处理，因为 `error` 事件不会冒泡
- Promise错误：`window.addEventListener('unhandledrejection', fn, false)`
- `try-catch`：⽤于可预⻅情况下监控特定的错误

上报错误

- 需要错误到⼀定量才会上报、上报采样率（防⽌PV过⾼对⽹⻚的压⼒过⼤）
- 压缩代码错误，并使⽤sourcemap找具体错误



