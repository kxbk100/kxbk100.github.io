---
title: 【Career】JS面试
date: 2019年04月08日 00:27:43
categories: Career
typora-root-url: ..
typora-copy-images-to: ../images
---

@[toc]
# 面试技巧

------

1. 当回答面试题的时候，尽量去引申出这个知识点的某些坑或者与这个知识点相关联的东西，多回答原理，谁都会用，使用

- 它的原理是……
- 它的本质是……
- 比如说/举个例子……

2. 给自己挖合适的坑
3. 面试中不要经常出现一问一答的情况


> ⚠️个人介绍

- 我叫冯天祥，就读于浙江科技学院软件工程专业
- 今天面试的岗位为前端工程师
- 我在大学本科期间参加了多次学科竞赛，也主持申报了多个项目，主要负责项目整体的统筹规划和前端的主要工作，也取得了一些成绩
- 我打小就对前端开发有着很浓烈的好奇心，那时候前端的概念还没有现在那么成熟，大概在小学四年级的时候，报了一个Frontpage的网页制作班
- 刚进入大一，跟着导师做项目，当时也就前端可以搭把手，看着自己的作品给大家看见和使用，非常有成就感，发现前端是越学习越喜欢的东西，后面越做就越进去了
- 我平时喜欢阅读一些技术博客，也爱看一些互联网行业公众号的软文
- 对，大概就是这样

# 变量类型和计算

> JS有哪些数据类型？

- 基本类型：String, Number, Boolean, Null, Undefined, Symbol（ES6）
- 引用类型：Object（Array、Function、Object）


**基本类型**
- 基本类型数据分块存放在内存中，数据之间不会相互影响
- 基本类型不能调用函数
- 基本类型中的number是浮点型，采用 IEEE 754，JS 采用的浮点数标准会裁剪掉我们的数字，就会出现精度丢失的问题，所以会出现`0.1 + 0.2 !== 0.3`
- `typeof null === object`，这其实是一个Bug，在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，`000` 开头代表是对象，然而 `null` 表示为全零，所以将它错误的判断为 `object` 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来

**引用类型**
- 引用类型中数据共享内存，变量存放的是指针，赋值也是指针，数据之间相互干预，很好的节约了内存空间
- 当我们需要复制出来一份引用类型的时候就需要使用到深浅拷贝
- 浅拷贝使用`let b = Object.assign({}, a)`，也可以使用展开运算符`let b = {...a}`，它的原理就拷贝所有的属性值到新的对象中，但当属性值是对象的时候，拷贝的仍是地址
- 深拷贝就是用来解决深层的问题，可以使用`let b = JSON.parse(JSON.stringfy(a))`，但是会忽略undefined，会忽略symbol，无法序列化函数，不能解决循环引用的问题
- 当含有内置类型，不含有函数时可以使用`messagechannel`
- 目前最完美的方案还是lodash深拷贝函数

**如何判断类型**
- typeof只能判断基本类型，instanceof只能判断引用类型
- `typeof null === object`，这其实是一个Bug，在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，`000` 开头代表是对象，然而 `null` 表示为全零，所以将它错误的判断为 `object` 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来
- instanceof用来判断引用类型的原理就是判断**引用类型**是属是否属于某个**构造函数**，通过对象的`__proto__`属性一层一层往上找看能否找到类型的`prototype`
- 但是`instanceof`也不是完全可靠的，因为可以通过改写`symbol.hasInstance`修改`instanceof`原本的内部逻辑，使得他可以判断基本类型，Array在多个frame中穿梭也会出现问题
- 所以我们可以通过 `Object.prototype.toString.call(obj) === '[object Array]'`来判断， 每个对象都有一个**内部属性**`[[Class]]`
- 不直接使用`toString()`是因为，虽然Array继承自Object，toString方法极有可能被重写而达不到我们的要求，而Object.prototype很少有人敢去碰它的，所以能一定程度保证其“纯洁性”
- **很多框架，比如jQuery等**，都借鉴这样的方法来进行**数组、正则表达式**等对象的类型判定，而且各大浏览器兼容性也很好

> 为什么 0.1 + 0.2 != 0.3？如何解决这个问题？

- 因为 JS 采用 IEEE 754 双精度版本（64位），并且只要采用 IEEE 754 的语言都有该问题
- 但是 JS 采用的浮点数标准却会裁剪掉我们的数字，就会出现精度丢失的问题
- console.log(0.1) 正确是因为二进制被转换为了十进制，十进制又被转换为了字符串，取了近似值
- 选用原生提供的方式来解决问题`parseFloat((0.1 + 0.2).toFixed(10)) === 0.3`

> V8 下的垃圾回收机制是怎么样的？

V8 实现了**准确式 GC**，GC 算法采用了**分代式垃圾回收机制**。所以，V8 将内存（堆）分为新生代和老生代两部分

**新生代**
- 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法
- 在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间
- 在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的
- 新分配的对象会被放入 From 空间中，当 From 空间被占满时，**新生代 GC 就会启动了**
- 算法会检查 From 空间中**存活的对象**并复制到 To 空间中，如果有失活的对象就会销毁
- 当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了

**老生代**
- 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是**标记清除算法**和**标记压缩算法**
- 新生代中的对象已经经历过一次 Scavenge 算法的会将对象从**新生代空间**移到**老生代空间**中。
- To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中

# 原型与原型链

> ⚠️从原型到原型链

 - **JS里的数据结构都是对象**，`__proto__`、`prototype`这些属性都是对象
- 每个对象都有一个`__proto__`的属性，指向它的**原型对象**
- 这个`__proto__`对象⼜具有⼀个⾃⼰的`__proto__`属性，这样⼀层层向上，形成了原型链
- 直到最后指向Object，而`Object.prototype`的`__proto__`是 `null`，这是原型链的终点
- 原型的`constructor`指向构造函数，构造函数使用`prototype`指向原型
- 比方说构造函数Person的原型对象是`Person.prototype`，`person`是实例对象，它的`__proto__ `属性指向对象的原型，所以 `person.__proto__ === Person.prototype`
- `Person.__proto__ === Object.prototype`，说明Person是Object的实例对象
- instanceof用来判断引用类型的原理就是判断引用类型是否属于某个构造函数，通过对象的`__proto__`属性一层一层往上找看能否找到类型`prototype`

**我们也可以通过原型实现继承**
- 可以使用**组合继承**，通过构造函数传参，可以复用父级的函数，不会与父类元素的引用属性发生共享，但是继承父级的时候调用了父级的构造函数，会继承很多父级的无用的属性，浪费了内存空间
- 我们也可以使用**寄生组合继承**，通过`Object.create`将父类的原型直接赋值给子类的原型，自己写constructor
- 现在用的比较多的是用ES6 class实现继承，它实际上是ES6构造函数的语法糖，`class` 实现继承的核心在于使用 `extends` 表明继承自哪个父类，父类中定义构造函数，并且在子类构造函数中必须调用 `super`，可以看成父类调用`call`传值，与ES5不同，class的属性方法不可枚举

> new一个对象的过程

- new就是根据构造函数的模板创建一个对象
- 首先new创建一个新对象
- 然后链接到原型
- 绑定this
- 执行构造函数
- 默认return this
- 对于创建一个对象来说，更推荐使用**字面量**的方式创建对象。因为你使用 `new Object() `的方式创建对象需要通过**作用域链**一层层找到 Object，但是你使用**字面量**的方式就没这个问题

> instanceof原理
- instanceof用来判断引用类型的原理就是判断引用类型是属是否属于某个构造函数，通过对象的`__proto__`属性一层一层往上找看能否找到类型`prototype`
- 首先获取类型的原型，然后获得对象的原型，然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null
- 通过改写`symbol.hasInstance`可修改`instanceof`原本的内部逻辑，Array在多个frame中穿梭也会出现问题，所以`instanceof`也不是完全可靠的
- 所以我们可以通过 `Object.prototype.toString.call(obj) === '[object Array]'`来判断， 每个对象都有一个**内部属性**`[[Class]]`
- 不直接使用`toString()`是因为，虽然Array继承自Object，toString方法极有可能被重写而达不到我们的要求，而Object.prototype很少有人敢去碰它的，所以能一定程度保证其“纯洁性”
- **很多框架，比如jQuery等**，都借鉴这样的方法来进行**数组、正则表达式**等对象的类型判定，而且各大浏览器兼容性也很好

# 闭包和作用域

> ⚠️作用域、执行上下文和上下文

- 作用域是程序中定义变量的地方，它规定了如何寻找变量，也就是确定了当前执行代码对变量的访问权限
- 执行上下文，当一个函数执行的时候，就会创建一个执行上下文
- 上下文，this在同一作用域内的值

> 作用域链

- 当查找变量的时候，会先从当前上下文的变量对象中查找
- 如果没有找到，就会从父级执行上下文的变量对象中查找
- 一直找到全局上下文的变量对象，也就是全局对象中查找

> 闭包

- 闭包就是能够读取其他函数内部变量的函数，比如说函数A内部有个函数B，函数B可以访问到函数A中的变量，函数B是闭包
- 使用闭包的**目的**呢就是保证数据安全不受污染，因为闭包间接访问函数内部变量，外部根本就不可能修改掉函数内部的变量
- 所以我们常用**立即执行函数**配合闭包来解决循环中`setTimeout`中`var`定义函数的问题
- **立即执行函数**将外部参数传入到函数内部，这个时候值就被固定在了立即执行函数的参数上面不会改变，当下次执行闭包的时候，就可以使用外部函数的参数，从而达到目的
- 闭包声明的函数保存在内存中，不会被**垃圾回收**，但也有可能发生内存泄漏，所以要及时释放内存，将形成循环引用的JS对象手动设置为空，切断引用

> ⚠️this

- this是JS的一个关键字，它指向函数调用时的对象
- this是在函数运行的时候才能确定的
- `new function()`，this固化在实例上，指向new的对象
- `function()`，this指向`window`，本质就是function.call(undefined)
- `obj.function()`，this指向`obj`，本质是function.call(obj)
- `call/apply/bind`，this指向它们的第一个参数
- 箭头函数，this指向第一个包裹箭头函数的普通函数的this

> 什么是立即执行函数？

- `(function(j) {})(i)`
- 它的作用是通过**隔离作用域**来解决命名冲突并且可以防止污染全局作用域
- 所以我们常用立即执行函数配合闭包来解决循环中`setTimeout`中`var`定义函数的问题
- **立即执行函数**将外部参数传入到函数内部，这个时候值就被固定在了立即执行函数的参数上面不会改变，当下次执行闭包的时候，就可以使用外部函数的参数，从而达到目的

> bind、call 和 apply 各自有什么区别？

**区别**

- 在JS中，这三者都是用来改变函数的this对象的指向的，第一个参数都是this要指向的对象
- call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以
- call后面的参数与方法中是一一对应的，而apply的第二个参数是一个数组，数组中的元素是和方法中一一对应的
- bind传参和call类似

**说到this**
- this是JS的一个关键字，它指向函数调用时的对象
- this是在函数运行的时候才能确定的
- `new function()`，this固化在实例上，指向new的对象
- `function()`，this指向`window`，本质就是function.call(undefined)
- `obj.function()`，this指向`obj`，本质是function.call(obj)
- `call/apply/bind`，this指向它们的第一个参数
- 箭头函数，this指向第一个包裹箭头函数的普通函数的this

**new**
- new就是根据构造函数的模板创建一个对象
- 首先new创建一个空对象
- 然后链接到原型
- 绑定this，`this = {}`
- 执行构造函数
- 默认return this
- 对于创建一个对象来说，更推荐使用**字面量**的方式创建对象。因为你使用 `new Object() `的方式创建对象需要通过**作用域链**一层层找到 Object，但是你使用**字面量**的方式就没这个问题
# 异步和单线程

> 并发和并行的区别

- 并发是**宏观概念**，如果我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，就称为并发
- 并行是**微观概念**，如何 CPU 中存在两个核心，那么我就可以同时完成任务 A、B

> 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？

- 回调函数有一个致命的弱点，如果有多个请求存在依赖性，就是容易写出回调地狱
- 回调地狱的根本问题就是，嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，嵌套函数一多，就很难处理错误
- 回调函数不能使用 `try catch` 捕获错误，不能直接 `return`
- 可以通过 `Generator` 函数返回的迭代器解决回调地狱的问题
- 也可以通过`Promise`解决回调地狱问题

> ⚠️promise的原理

`Promise` 代表承诺会在未来有一个确切的答复，承诺有三种状态：

- 等待态（pending）
- 完成态 （resolved）
- 拒绝态（rejected）

------

- 一旦状态变为 resolved 后，就不能再次改变
- `promise`是⽤来处理**异步操作**的对象，允许为异步操作的成功和失败分别绑定相应的处理方法
- `promise`是⼀个then-able的对象，构造函数内部的代码是立即执行的
- then⾥⾯的回调是异步延迟调用的，它的原理是临时存储在callback数组中，类似`setTimeout(handle(callbacks), 0)`，但是实现上是在微任务队列（microtask）中，在setTimeout之前，setTimeout属于宏观任务（macrotask）
- `Promise` 也有一些缺陷，比如无法取消 `Promise`，错误需要通过回调函数捕获

> 链式调用为什么要返回新的promise⽽不是this

- `Promise` 实现了链式调用，每次调用 `then` 之后返回的都是一个`Promise`，并且是一个全新的 `Promise`
- 因为状态不可变。如果在 `then` 中 使用了 `return`，`return` 的值会被 `Promise.resolve()` 包装
- 返回的状态可能不⼀样，⼀旦是resolve或者reject，状态应该不能改变

> async/await原理

- 一个函数如果加上 `async` ，那么该函数就会返回一个 `Promise`，`async` 就是将函数返回值使用 `Promise.resolve()` 包裹了下，和 `then` 中处理返回值一样
- `async` 和 `await` 可以说是**异步**终极解决方案了， 通过yield和promise实现，`await` 只能配套 `async` 使用，⽤同步写法去做异步操作的处理，解决了使用`promise`写一大堆`then`的问题，也能解决回调地狱问题
- `await` 就是 `generator` 加上 `Promise`的语法糖，且内部实现了自动执行 `generator`
- 因为 `await` 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 `await` 会导致性能上的降低
- 可以使用`try-catch`直接处理异常

> setTimeout、setInterval、requestAnimationFrame 各有什么特点？

**setTimeout**

- 很多人认为 `setTimeout` 是延时多久，然后多久后执行，其实这个观点是错误的
- JS 是单线程执行的
- 如果前面的代码影响了性能，就会导致 `setTimeout` 不会按期执行
- 当然了，我们可以通过代码去修正 `setTimeout`，将时间戳与当前时间比较，看是否已经过指定的毫秒数 ，时间未够，则继续setTimeout，步长可改为1秒 ，否则执行，从而使定时器相对准确

**setInterval**

- `setInterval`作用和 `setTimeout` 基本一致，只是该函数是每隔一段时间执行一次回调函数
- 我们通常不使用 `setInterval`。因为第一，它和 `setTimeout` 一样，不能保证在预期的时间执行任务。第二，它存在**执行累积**的问题
- 比如说我进行了sleep操作，多个回调函数会在耗时操作结束后同时执行，带来性能上的问题

**requestAnimationFrame**

- 如果有循环定时器的需求我们一般使用`requestAnimationFrame`来实现
- 首先 `requestAnimationFrame` 自带**函数节流**功能，基本可以保证在 16.6 毫秒内只执行一次，因为浏览器的刷新频率60FPS（不掉帧的情况下）
- 延时效果是绝对精确的，没有其他定时器时间不准的问题

> 进程与线程区别？JS 单线程带来的好处？

- 进程描述了 CPU 在**运行指令及加载和保存上下文所需的时间**，放在应用上来说就代表了一个程序
- 线程是进程中的更小单位，描述了执行**一段指令**所需的时间
- 比如在浏览器中，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁
- JS引擎和渲染引擎的两个线程是互斥的，JS 运行的时候可能会阻止 UI 渲染，因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI
- 这就是个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题

> 什么是执行栈？
- 执行栈是一个存储**函数调用**的栈结构，遵循**先进后出**的原则
- 首先会执行一个`main`函数，需执行的函数入栈，执行完后从栈中弹出
- 平时开发时，在报错信息Uncaught Error中就可以找到执行栈的痕迹
- 栈可存放的函数是有限制的，当我们使用递归的时候，一旦存放了过多的函数且没有得到释放的话，就会出现**爆栈**的问题

> 异步代码执行顺序？解释一下什么是 Event Loop ？
- 当我们执行JS代码的时候其实就是往执行栈中放入函数
- 当遇到异步的代码时，会被挂起并在**需要执行的时候**加入到 Task队列中，有多种 Task队列
- 一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，**所以本质上来说 JS 中的异步还是同步行为**
- 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，微任务被称为 jobs，宏任务被称为 task

**所以 Event Loop 执行顺序是**

- 首先执行同步代码，这属于**宏任务**
- 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
- 如果有异步代码则执行所有微任务
- 当执行完所有微任务后，如有必要会渲染页面
- 然后开始下一轮 Event Loop，执行宏任务中的异步代码

微任务包括 `process.nextTick` ，`promise` ，`MutationObserver`

宏任务包括 `script` ， `setTimeout` ，`setInterval` ，`setImmediate` ，`I/O` ，`UI rendering`
# ES6
> ES6 中有使用过什么？

**使用过ES6 class**

- 它实际上是ES6构造函数的语法糖
- 是实现继承的一种方式
- `class` 实现继承的核心在于使用 `extends` 表明继承自哪个父类，父类中定义构造函数，并且在子类构造函数中必须调用 `super`，可以看成父类调用`call`传值
- 与ES5不同，class的属性方法不可枚举

**我们也可以通过原型实现继承**
- 可以使用组合继承，通过构造函数传参，可以复用父级的函数，不会与父类元素的引用属性发生共享，但是继承父级的时候调用了父级的构造函数，会继承很多父级的无用的属性，浪费了内存空间
- 我们也可以使用寄生组合继承，通过Object.create将父类的原型直接赋值给子类的原型，自己写constructor

**原本都是通过var来定义变量，现在比较多用let和const**
- 原本var的话是存在变量提升的，并挂载到window上，let/const即使在全局作用域下声明也不会挂载到window上
- let和const也存在提升，告知在这块作用域可以访问，但是访问受限，因为存在**暂时性死区**，所以不能在声明前使用变量
- const和let的区别在于不能再次赋值，但如果定义的是对象的话可以对对象进行操作
- let和const使得JS存在块级作用域
---
- 变量提升，是将声明挪到顶部为undefined
- 函数提升，是将整个函数挪到顶部
- 函数提升优于变量提升

**还使用过箭头函数**

- 箭头函数类似于匿名函数简写
- 但和匿名函数还是存在一定区别的
- 匿名函数的this挂载在window上
- 而箭头函数的this指向词法作用域，由上下文确定，所以call/apply/bind的第一个参数失效

		
> Set和Map数据类型

- Set：类似数组，但是值不重复
- Map：类似kv对象，key可以不局限于字符串

# 模块化

> JS模块化原理（Commonjs、AMD、UMD、ES6 Module）

**目的**

- 解决命名冲突
- 提高代码复用性
- 提高代码可维护性

**webpack**一般配合**CommonJS**一起使用

- 基于nodeJS环境
- 同步加载
- 它的本质还是用了立即执行函数

**ES6 Module**

- 基于浏览器环境
- ES Module会编译成require/exports来执行
- ES Module采用静态导入，CommonJS采用动态导入
- ES Module采用异步导入，基于浏览器环境，需要下载文件，如果也采用同步导入会对渲染产生很大影响
- CommonJS采用同步导入，基于nodeJS环境，文件在本地，导入卡住对主线程影响不大
- ES Module中的数据是实时绑定的，导入导出指向同一内存地址，导入值会跟随导出值变化
- CommonJS中数据是值拷贝，导出的值变了导入的值也不会变，如果要更新值，必须重新导入一次

**AMD**

- 基于浏览器环境
- define了就可以直接用，异步加载
- 利⽤onload事件执行代码实现依赖前置，和defer类似

**CMD**

- define之后需要require才可以使用，同步加载
- require写在函数体的任意地方实现延迟加载
- 依赖后置，⽤到才加载，和async类似

**UMD**

- 兼容AMD和CommonJS
- 利⽤立即执行函数

> ⚠️require.js的实现原理

**原理**

- require.js是AMD，利用define
- 依赖的JS是靠动态创建`<script>`插入的
- onload事件来处理回调，保证JS提前加载完毕

**作用**

- 实现JS⽂件的异步加载，避免⽹⻚失去响应
- 管理模块之间的依赖性，便于代码的维护

**与Sea.js的区别**

- Sea.js是使用时加载的，加载顺序与require一致
- require.js是提前加载，加载顺序不一定

# JS实际应用
> JS 是如何运行的？
> 
**JS是单线程运行的**

- 进程描述了 CPU 在**运行指令及加载和保存上下文所需的时间**，放在应用上来说就代表了一个程序
- 线程是进程中的更小单位，描述了执行**一段指令**所需的时间
- 比如在浏览器中，当你打开一个 Tab 页时，其实就是创建了一个进程，一个进程中可以有多个线程，比如渲染线程、JS 引擎线程、HTTP 请求线程等等。当你发起一个请求时，其实就是创建了一个线程，当请求结束后，该线程可能就会被销毁
- JS引擎和渲染引擎的两个线程是互斥的，JS 运行的时候可能会阻止 UI 渲染，因为 JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI
- 这就是个单线程的好处，得益于 JS 是单线程运行的，可以达到节省内存，节约上下文切换时间，没有锁的问题

**JS中存在一个执行栈**
- 执行栈是一个存储**函数调用**的栈结构，遵循**先进后出**的原则
- 首先会执行一个`main`函数，需执行的函数入栈，执行完后从栈中弹出
- 平时开发时，在报错信息Uncaught Error中就可以找到执行栈的痕迹
- 栈可存放的函数是有限制的，当我们使用递归的时候，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题

**JS中代码的执行顺序依赖于Event Loop**
- 当我们执行JS代码的时候其实就是往**执行栈**中放入函数
- 当遇到异步的代码时，会被挂起并在**需要执行的时候**加入到 Task队列中，有多种 Task队列
- 一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，**所以本质上来说 JS 中的异步还是同步行为**
- 不同的任务源会被分配到不同的 Task 队列中，任务源可以分为微任务（microtask）和宏任务（macrotask）。在 ES6 规范中，微任务被称为 jobs，宏任务被称为 task

**所以 Event Loop 执行顺序是**

- 首先执行同步代码，这属于**宏任务**
- 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行
- 如果有异步代码则执行所有微任务
- 当执行完所有微任务后，如有必要会渲染页面
- 然后开始下一轮 Event Loop，执行宏任务中的异步代码

微任务包括 `process.nextTick` ，`promise` ，`MutationObserver`

宏任务包括 `script` ， `setTimeout` ，`setInterval` ，`setImmediate` ，`I/O` ，`UI rendering`

**JS中还存在垃圾回收机制**

V8 实现了**准确式 GC**，GC 算法采用了**分代式垃圾回收机制**。所以，V8 将内存（堆）分为新生代和老生代两部分

**新生代**
- 新生代中的对象一般存活时间较短，使用 Scavenge GC 算法
- 在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间
- 在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的
- 新分配的对象会被放入 From 空间中，当 From 空间被占满时，**新生代 GC 就会启动了**
- 算法会检查 From 空间中**存活的对象**并复制到 To 空间中，如果有失活的对象就会销毁
- 当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了

**老生代**
- 老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是**标记清除算法**和**标记压缩算法**
- 新生代中的对象已经经历过一次 Scavenge 算法的会将对象从**新生代空间**移到**老生代空间**中。
- To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中

> ⚠️实现图片懒加载

- 懒加载就是将不关键的资源延后加载
- 只加载自定义区域内需要加载的东西
- 对于图片来说，加载的图片地址不是直接写在src，而是写在data-src，src放默认图
- 监听浏览器的scroll事件，当图片DOM滚动到视口位置，将src替换为data-src
- 使用`getBoundingRect`函数获取元素相对于**视口左上角**的坐标，判断元素是否出现在视口
- 因为scroll事件密集发生，计算量很大，容易造成性能问题，我们并不希望用户在滚动过程中一直发起请求，而是**隔一段时间发起一次**，所以对scroll要进行**节流**处理
- 替换的img标签需要从imgList删除
- 目前有一个新的 `IntersectionObserver` API，可以自动"观察"元素是否可见，所以`visible`的本质是，目标元素与视口产生一个交叉区

> 实现页面加载进度条

- 进度条的DOM结构需要放在body最前⾯
- 进度条的JS需要放在页⾯顶部，防止阻塞页面渲染，保证模拟效果

> ⚠️实现extend函数

主要是深浅拷贝问题

- 浅拷贝可以使用Object.assign和...展开运算符
- 深拷贝可以使用JSON.parse(JSON.stringfy(obj))，但是会忽略symbol，undefined，函数不能序列化，不能解决循环引用问题
- 如果含有内置对象但没有函数，可以使用MessageChannel
- 否则只能用lodash的深拷贝函数

> 实现快速数组去重（ES6）

- ES6新增了Set数据结构
- Set数据类似数组结构，但是值不会重复
- 扩展运算符可以展开数组对象，如果是Iterator（遍历器）接口的对象，都可以转化为数组

------

- 任何数据结构只要部署Iterator接口，就可以完成遍历操作
- ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of使用的
- 遍历器对象本质上，就是一个指针对象
- 不断调用指针对象的next方法，直到它指向数据结构的结束位置

```js
let array = Array.from(new Set([1, 1, 1, 2, 3, 2, 4]));
console.log(array);
// => [1, 2, 3, 4]
```

> ⚠️实现节流和防抖的应用场景

- 节流：throttle，⿏标移动，隔一段时间发起一次，将当前时间和上一次执行函数时间对比，如果差值大于设置的等待时间就执行函数，设置setInterval不断调用
- 防抖：debounce，input输入，scroll，一段时间后没有再次点击的情况才去发起网络请求，设置一个定时器，延迟执行用户传入的方法，如果已经设定过定时器了就清空上一次的定时器，调用setTimeout函数

> 实现parseInt，简单实现转化数字符串

- 核⼼是进制转换 `arr[i] * Math.pow(radix, i)`
- radix进制数

> 数组操作

？？？

> 函数科里化的原理和作用

- 将使用多个参数的一个函数转换成一系列使⽤⼀个参数的函数的技术
- 为的就是参数复用、提前返回、延迟计算
- 比如说，⼀个ajax请求`ajax(method, url, params)`都是post请求，可以柯⾥化为`ajaxPost(url, params)`
