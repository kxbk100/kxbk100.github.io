{"meta":{"title":"冯天祥","subtitle":"前端小白的技术博客","description":"前端小白冯天祥的技术博客","author":"冯天祥","url":"http://fengtx.tk","root":"/"},"pages":[{"title":"","date":"2020-05-03T15:21:18.500Z","updated":"2019-03-31T02:53:35.000Z","comments":false,"path":"categories/index.html","permalink":"http://fengtx.tk/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-03T15:21:18.498Z","updated":"2019-03-31T02:53:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://fengtx.tk/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Sass的使用","slug":"yuque/Sass的使用","date":"2020-05-03T14:06:25.000Z","updated":"2020-05-03T15:25:20.561Z","comments":true,"path":"2020/05/03/yuque/Sass的使用/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Sass的使用/","excerpt":"","text":"文件后缀名12345678910111213141516//文件后缀名为sass的语法body background: #eee font-size:12pxp background: #0982c1 //文件后缀名为scss的语法body &#123; background: #eee; font-size: 12px;&#125;p &#123; background: #0982c1;&#125; 导入css 文件：@import ‘reset.css’跟普通 CSS 导入样式文件一样，导入的 css 文件不会合并到编译后的文件中，而是以@import 方式存在 sass 文件：@import ‘reset’被导入 sass 文件 a.scss 1234//a.scssbody &#123; background: #eee;&#125; 需要导入样式的 sass 文件 b.scss 12345@import \"reset.css\";@import \"a\";p &#123; background: #0982c1;&#125; 转译出来的 b.css 样式 12345678@import \"reset.css\";body &#123; background: #eee;&#125;p &#123; background: #0982c1;&#125; 变量 sass 的变量必须是\\$开头，后面紧跟变量名 变量值和变量名之间就需要使用冒号(:)分隔开 值后面加上!default 则表示默认值 普通变量：定义之后可以在全局范围内使用12345678910//sass style$fontSize: 12px;body &#123; font-size: $fontSize;&#125;//css stylebody &#123; font-size: 12px;&#125; 默认变量 sass 的默认变量仅需要在值后面加上 !default 123456789//sass style$baseLineHeight: 1.5 !default;body &#123; line-height: $baseLineHeight;&#125;//css stylebody &#123; line-height: 1.5;&#125; sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，只需要在默认变量之前重新声明下变量即可 12345678910//sass style$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body &#123; line-height: $baseLineHeight;&#125;//css stylebody &#123; line-height: 2;&#125; 特殊变量一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下，如运算、拼接等则必须要以 #{\\$variables}形式使用 12345678910111213141516171819//sass style$borderDirection: top !default;$baseFontSize: 12px !default;$baseLineHeight: 1.5 !default;//应用于class和属性.border-#&#123;$borderDirection&#125; &#123; border-#&#123;$borderDirection&#125;: 1px solid #ccc;&#125;//应用于复杂的属性值body &#123; font: #&#123;$baseFontSize&#125;/#&#123;$baseLineHeight&#125;;&#125;//css style.border-top &#123; border-top: 1px solid #ccc;&#125;body &#123; font: 12px/1.5;&#125; 全局变量在选择器中声明的变量会覆盖外面全局声明的变量 嵌套选择器嵌套可以使用 &amp;表示父元素选择器 1234567891011121314151617181920212223242526272829303132333435//sass style#top_nav &#123; line-height: 40px; text-transform: capitalize; background-color: #333; li &#123; float: left; &#125; a &#123; display: block; padding: 0 10px; color: #fff; &amp;:hover &#123; color: #ddd; &#125; &#125;&#125;//css style#top_nav &#123; line-height: 40px; text-transform: capitalize; background-color: #333;&#125;#top_nav li &#123; float: left;&#125;#top_nav a &#123; display: block; padding: 0 10px; color: #fff;&#125;#top_nav a:hover &#123; color: #ddd;&#125; 混合sass 中使用 @mixin 声明混合，可以传递参数，参数名以\\$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的 @mixin 通过 @include 来调用。 (1) 无参数 mixin//sass style//——————————-@mixin center-block {margin-left:auto;margin-right:auto;}.demo{@include center-block;} //css style//——————————-.demo{margin-left:auto;margin-right:auto;} (2) 有参数 mixin(3) 多个参数 mixin(4) 多组值参数 mixin(5) @content 7 继承(1) 继承 @extend //sass style//——————————-h1{border: 4px solid #ff9aa9;}.speaker{@extend h1;border-width: 2px;} //css style//——————————-h1,.speaker{border: 4px solid #ff9aa9;}.speaker{border-width: 2px;} (2) 占位选择器 %定义了两个占位选择器 %ir 和 %clearfix，其中 %clearfix 这个没有调用，所以解析出来的 css 样式也就没有 clearfix 部分。占位选择器的出现，使 css 文件更加简练可控，没有多余。所以可以用其定义一些基础的样式文件，然后根据需要调用产生相应的 css //sass style//——————————-%ir{color: transparent;text-shadow: none;background-color: transparent;border: 0;}%clearfix{@if \\$lte7 {*zoom: 1;}&amp;:before,&amp;:after {content: “”;display: table;font: 0/0 a;}&amp;:after {clear: both;}} #header{h1{@extend %ir;width:300px;}}.ir{@extend %ir;} //css style//——————————- #header h1,.ir{color: transparent;text-shadow: none;background-color: transparent;border: 0;} #header h1{width:300px;} 8 函数实际项目中我们使用最多的应该是颜色函数，而颜色函数中又以 lighten 减淡和 darken 加深为最，其调用方法为 lighten($color,$amount)和 darken($color,$amount)，它们的第一个参数都是颜色值，第二个参数都是百分比 //sass style//——————————-$baseFontSize: 10px !default;$gray: #ccc !defualt; // pixels to rems@function pxToRem($px) {@return $px / \\$baseFontSize * 1rem;} body{font-size:$baseFontSize;color:lighten($gray,10%);}.test{font-size:pxToRem(16px);color:darken(\\$gray,10%);} //css style//——————————-body{font-size:10px;color:#E6E6E6;}.test{font-size:1.6rem;color:#B3B3B3;} 9 运算sass 具有运算的特性，可以对数值型的 Value(如：数字、颜色、变量等)进行加减乘除四则运算。请注意运算符前后请留一个空格，不然会出错 $baseFontSize: 14px !default;$baseLineHeight: 1.5 !default;$baseGap: $baseFontSize * $baseLineHeight !default;$halfBaseGap: $baseGap / 2 !default;$samllFontSize: \\$baseFontSize - 2px !default; //grid$_columns: 12 !default; // Total number of columns$_column-width: 60px !default; // Width of a single column\\$_gutter: 20px !default; // Width of the gutter $_gridsystem-width: $_columns * ($_column-width + $_gutter); //grid system width 10 条件判断及循环(1) @if 判断@if 可一个条件单独使用，也可以和 @else 结合多条件使用 //sass style//——————————-$lte7: true;$type: monster;.ib{display:inline-block;@if $lte7 {display:inline; zoom:1;}}p {@if $type == ocean {color: blue;} @else if $type == matador {color: red;} @else if $type == monster {color: green;} @else {color: black;}} //css style//——————————-.ib{display:inline-block;display:inline; zoom:1;}p {color: green;} (2) 三目判断语法为： if($condition, $if_true, \\$if_false) 。三个参数分别表示：条件，条件为真的值，条件为假的值 if(true, 1px, 2px) =&gt; 1pxif(false, 1px, 2px) =&gt; 2px (3) for 循环for 循环有两种形式，分别为： @for $var from through 和 @for $var from to 。\\$i 表示变量，start 表示起始值，end 表示结束值，这两个的区别是关键字 through 表示包括 end 这个数，而 to 则不包括 end 这个数。 //sass style//——————————-@for $i from 1 through 3 {.item-#{$i} { width: 2em * \\$i; }} //css style//——————————-.item-1 {width: 2em;}.item-2 {width: 4em;}.item-3 {width: 6em;} (4) @each 循环语法为： @each $var in 。其中 $var 表示变量，而 list 和 map 表示 list 类型数据和 map 类型数据。sass 3.3.0 新加入了多字段循环和 map 数据循环。 单个字段 list 数据循环 //sass style//——————————-$animal-list: puma, sea-slug, egret, salamander;@each $animal in $animal-list {.#{$animal}-icon {background-image: url(‘/images/#{\\$animal}.png’);}} //css style//——————————-.puma-icon {background-image: url(‘/images/puma.png’);}.sea-slug-icon {background-image: url(‘/images/sea-slug.png’);}.egret-icon {background-image: url(‘/images/egret.png’);}.salamander-icon {background-image: url(‘/images/salamander.png’);} 多个字段 list 数据循环 //sass style//——————————-$animal-data: (puma, black, default),(sea-slug, blue, pointer),(egret, white, move);@each $animal, $color, $cursor in $animal-data {.#{$animal}-icon {background-image: url(‘/images/#{$animal}.png’);border: 2px solid $color;cursor: \\$cursor;}} //css style//——————————-.puma-icon {background-image: url(‘/images/puma.png’);border: 2px solid black;cursor: default;}.sea-slug-icon {background-image: url(‘/images/sea-slug.png’);border: 2px solid blue;cursor: pointer;}.egret-icon {background-image: url(‘/images/egret.png’);border: 2px solid white;cursor: move;} 多个字段 map 数据循环 //sass style//——————————-$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings { #{$header} {font-size: $size;}} //css style//——————————-h1 {font-size: 2em;}h2 {font-size: 1.5em;}h3 {font-size: 1.2em;}","categories":[],"tags":[]},{"title":"如何将vue-cli创建的项目关联到github或gitlab远程仓库","slug":"yuque/如何将vue-cli创建的项目关联到github或gitlab远程仓库","date":"2020-05-03T10:32:05.000Z","updated":"2020-05-03T15:25:20.569Z","comments":true,"path":"2020/05/03/yuque/如何将vue-cli创建的项目关联到github或gitlab远程仓库/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/如何将vue-cli创建的项目关联到github或gitlab远程仓库/","excerpt":"","text":"进入需要关联到远程仓库的项目文件夹中，执行以下命令： 1、git init 使用 git 初始化项目 2、git remote add origin &lt;remote-project-repository-address&gt; 将项目关联到远程仓库， 为远程项目仓库的地址，在 github 或 gitlab 中按如下图所示获取： 3、git add . 将本地项目添加到暂存区 4、git commit -m &#39;自己提交的描述&#39; 将项目提交本地版本库 5、git push -u origin master 将项目推送到远程仓库","categories":[],"tags":[]},{"title":"webpack大拷问","slug":"yuque/webpack大拷问","date":"2020-05-03T10:02:46.000Z","updated":"2020-05-03T15:25:20.746Z","comments":true,"path":"2020/05/03/yuque/webpack大拷问/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/webpack大拷问/","excerpt":"","text":"1 webpack 与 grunt、gulp 的不同？三者都是前端构建工具，grunt 和 gulp 在早期比较流行，现在 webpack 相对来说比较主流，不过一些轻量化的任务还是会用 gulp 来处理，比如单独打包 CSS 文件等。 grunt 和 gulp 是基于任务和流（Task、Stream）的。类似 jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个 web 的构建流程。 webpack 是基于入口的。webpack 会自动地递归解析入口所需要加载的所有资源文件，然后用不同的 Loader 来处理不同的文件，用 Plugin 来扩展 webpack 功能。 所以总结一下： 从构建思路来说 gulp 和 grunt 需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系 webpack 需要开发者找到入口，并需要清楚对于不同的资源应该使用什么 Loader 做何种解析和加工 对于知识背景来说 gulp 更像后端开发者的思路，需要对于整个流程了如指掌 webpack 更倾向于前端开发者的思路 2 与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？同样是基于入口的打包工具还有以下几个主流的： webpack rollup parcel 从应用场景上来看： webpack 适用于大型复杂的前端站点构建 rollup 适用于基础库的打包，如 vue、react parcel 适用于简单的实验性项目，他可以满足低门槛的快速看到效果 由于 parcel 在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用 parcel 3 有哪些常见的 Loader？他们是解决什么问题的？ file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码 4 有哪些常见的 Plugin？他们是解决什么问题的？ define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码 5 Loader 和 Plugin 的不同？不同的作用 Loader 直译为”加载器”。Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。 Plugin 直译为”插件”。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 - Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法 Loader 在 module.rules 中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个 Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin 在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入 6 webpack 的构建流程是什么?Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件； 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 7 是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？Loader 像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个 Loader 通过链式操作，将源文件一步步翻译成想要的样子。 编写 Loader 时要遵循单一原则，每个 Loader 只做一种”转义”工作。 每个 Loader 的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用 this.callback()方法，将内容返回给 webpack。 还可以通过 this.async()生成一个 callback 函数，再用这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发 loader 的工具函数集——loader-utils。 相对于 Loader 而言，Plugin 的编写就灵活了许多。 webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 8 webpack 的热更新是如何做到的？说明其原理？webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 原理： 首先要知道 server 端和 client 端都做了处理工作 第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。 第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API 对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。 第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。 第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。 webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。 HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。 而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。 最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。 9 如何利用 webpack 来优化前端性能？（提高性能和体验）用 webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运行快速高效。 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用 webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS 文件， 利用 cssnano（css-loader?minimize）来压缩 css 利用 CDN 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径。可以利用 webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动 webpack 时追加参数–optimize-minimize 来实现 提取公共代码。 10 如何提高 webpack 的构建速度？ 多入口情况下，使用 CommonsChunkPlugin 来提取公共代码 通过 externals 配置来提取常用库 利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 使用 Happypack 实现多线程加速编译 使用 webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采用了多核并行压缩来提升压缩速度 使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码 11 怎么配置单页应用？怎么配置多页应用？单页应用可以理解为 webpack 的标准模式，直接在 entry 中指定单页应用的入口即可，这里不再赘述 多页应用的话，可以使用 webpack 的 AutoWebPlugin 来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是： 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套 css 样式表 随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置 12 npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？Npm 是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是 JS 模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于 NPM 模块上传的方法可以去官网上进行学习，这里只讲解如何利用 webpack 来构建。 NPM 模块需要注意以下问题： 要支持 CommonJS 模块化规范，所以要求打包后的最后结果也遵守该规则。 Npm 模块使用者的环境是不确定的，很有可能并不支持 ES6，所以打包的最后结果应该是采用 ES5 编写的。并且如果 ES5 是经过转换的，请最好连同 SourceMap 一同上传。 Npm 包大小应该是尽量小（有些仓库会限制包大小） 发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。 UI 组件类的模块应该将依赖的其它资源文件，例如.css 文件也需要包含在发布的模块里。 基于以上需要注意的问题，我们可以对于 webpack 配置做以下扩展和优化： CommonJS 模块化规范的解决方案： 设置 output.libraryTarget=’commonjs2’使输出的代码符合 CommonJS2 模块化规范，以供给其它模块导入使用 输出 ES5 代码的解决方案：使用 babel-loader 把 ES6 代码转换成 ES5 的代码。再通过开启 devtool: ‘source-map’输出 SourceMap 以发布调试。 Npm 包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc 文件，为其加入 transform-runtime 插件 不能将依赖模块打包到 NPM 模块中的解决方案：使用 externals 配置项来告诉 webpack 哪些模块不需要打包。 对于依赖的资源文件打包的解决方案：通过 css-loader 和 extract-text-webpack-plugin 来实现，配置如下： 12345678910111213141516171819202122const ExtractTextPlugin = require(\"extract-text-webpack-plugin\");module.exports = &#123; module: &#123; rules: [ &#123; // 增加对 CSS 文件的支持 test: /\\.css/, // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: [\"css-loader\"], &#125;), &#125;, ], &#125;, plugins: [ new ExtractTextPlugin(&#123; // 输出的 CSS 文件名称 filename: \"index.css\", &#125;), ],&#125;; 13 如何在 vue 项目中实现按需加载？Vue UI 组件库的按需加载 为了快速开发前端项目，经常会引入现成的 UI 组件库如 ElementUI、iView 等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。 不过很多组件库已经提供了现成的解决方案，如 Element 出品的 babel-plugin-component 和 AntDesign 出品的 babel-plugin-import 安装以上插件后，在.babelrc 配置中或 babel-loader 的参数中进行设置，即可实现组件按需加载了。 123456789101112&#123; \"presets\": [[\"es2015\", &#123; \"modules\": false &#125;]], \"plugins\": [ [ \"component\", &#123; \"libraryName\": \"element-ui\", \"styleLibraryName\": \"theme-chalk\" &#125; ] ]&#125; 单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。 通过import(*)语句来控制加载时机，webpack 内置了对于import(*)的解析，会将import(*)中引入的模块作为一个新的入口在生成一个 chunk。 当代码执行到import(*)语句时，会去加载 Chunk 对应生成的文件。import()会返回一个 Promise 对象，所以为了让浏览器支持，需要事先注入 Promise polyfill。","categories":[],"tags":[]},{"title":"Vue学习小记","slug":"yuque/Vue学习小记","date":"2020-05-03T10:02:41.000Z","updated":"2020-05-03T15:25:21.097Z","comments":true,"path":"2020/05/03/yuque/Vue学习小记/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Vue学习小记/","excerpt":"","text":"title: Vue 学习小记 date: 2019 年 04 月 08 日 00:27:43categories: Frameworktypora-root-url: ..typora-copy-images-to: ../images Vue 的安装及语法 解析 页面中的数据与内存中的数据双向绑定 v-mdodel v-show：暂时隐藏 v-if：直接从dom中删除 v-for 指令v-bind 指令（v-bind:可简写为:） 绑定数据和元素属性：src、href 12345678&lt;style&gt; .active &#123; background: #a10; &#125;&lt;/style&gt;&lt;a :class=\"&#123;active: isActive&#125;\" :href=\"url\"&gt; 点我&lt;/a&gt; 123456789var app = new Vue(&#123; el: \"#app\", data: &#123; url: \"http://baidu.com\", img: \"https://dummyimage.com/100x100/ffcc00/ffffff\", klass: \"btn btn-default\", isActive: true, &#125;,&#125;); v-on 指令（v-on:可简写为@，v-on=不可简写） v-on=”{事件:函数, 事件:函数}” v-on:事件=”函数()” 一定要都写在 div#app 中 更多事件参考：https://cn.vuejs.org/v2/guide/events.html v-model 指令及其修饰符 适用于：input、textarea、select v-model对变量进行绑定并操作，输出变量 v-model.lazy 失焦更新 v-model.trim 删去空格 v-model.number 字符串转为 number v-model 在其他元素及类型上的用法控制流指令 v-if v-else-if v-else 计算属性 和method的区别：缓存数据，提高了性能 123456789computed: &#123; sum: function () &#123; return parseFloat(this.math) + parseFloat(this.physics) + parseFloat(this.english); &#125;, average: function () &#123; return Math.round(this.sum / 3); &#125; &#125;,&#125;); 12345678&lt;tr&gt; &lt;td&gt;总分&lt;/td&gt; &lt;td&gt;&#123;&#123;sum&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;平均分&lt;/td&gt; &lt;td&gt;&#123;&#123;average&#125;&#125;&lt;/td&gt;&lt;/tr&gt; 组件 - 全局及局部组件 全局组件 123Vue.component(\"like\", &#123; template: \"\",&#125;); 局部组件 123456789101112131415var alert_component = &#123; template: '&lt;button @click=\"on_click\"&gt;弹弹弹&lt;/button&gt;', methods: &#123; on_click: function () &#123; alert(\"Yo.\"); &#125;, &#125;,&#125;;new Vue(&#123; el: \"#seg1\", components: &#123; alert: alert_component, &#125;,&#125;); 组件 - 配置组件 template 必须放在 el 外面 1234567891011121314151617Vue.component(\"like\", &#123; template: \"#like-component-tpl\", data: function () &#123; return &#123; like_count: 10, liked: false, &#125;; &#125;, methods: &#123; toggle_like: function () &#123; if (!this.liked) this.like_count++; else this.like_count--; this.liked = !this.liked; &#125;, &#125;,&#125;); 123456789&lt;div id=\"app\"&gt; &lt;like&gt;&lt;/like&gt;&lt;/div&gt;&lt;template id=\"like-component-tpl\"&gt; &lt;button :class=\"&#123;liked: liked&#125;\" @click=\"toggle_like()\"&gt; 👍👍 &#123;&#123;like_count&#125;&#125; &lt;/button&gt;&lt;/template&gt; 组件 - 父子通信 自定义传参 12345Vue.component(\"user\", &#123; template: \"&lt;a :href=\\\"'/user/' + username\\\"&gt;&#123;&#123;username&#125;&#125;&lt;/a&gt;\", props: [\"username\"], methods: &#123;&#125;,&#125;); 123&lt;div id=\"app\"&gt; &lt;user username=\"biaoyansu\"&gt;&lt;/user&gt;&lt;/div&gt; 组件 - 子父通信123456789101112131415161718192021222324252627282930313233Vue.component(\"balance\", &#123; template: ` &lt;div&gt; &lt;show @show-balance=\"show_balance\"&gt;&lt;/show&gt; //监听事件 &lt;div v-if=\"show\"&gt; 您的余额：￥98逸 &lt;/div&gt; &lt;/div&gt; `, methods: &#123; show_balance: function (data) &#123; this.show = true; console.log(\"data:\", data); &#125;, &#125;, data: function () &#123; return &#123; show: false, &#125;; &#125;,&#125;);Vue.component(\"show\", &#123; template: '&lt;button @click=\"on_click()\"&gt;显示余额&lt;/button&gt;', methods: &#123; on_click() &#123; this.$emit(\"show-balance\", &#123; a: 1, b: 2 &#125;); //$emit向父级元素传递事件，触发一个事件 &#125;, &#125;,&#125;);new Vue(&#123; el: \"#app\",&#125;); 组件 - 任意及平行组件间通信 模板必须有最外层根元素div等 12345678910111213141516171819202122232425262728293031323334353637var Event = new Vue(); //调度器Vue.component(\"huahua\", &#123; template: ` &lt;div&gt; 我说：&lt;input @keyup=\"on_change\" v-model=\"i_said\"/&gt; &lt;/div&gt;`, methods: &#123; on_change: function () &#123; Event.$emit(\"huahua-said-something\", this.i_said); //$emit触发器返回函数名和函数值 &#125;, &#125;, data: function () &#123; return &#123; i_said: \"\", &#125;; &#125;,&#125;);Vue.component(\"shuandan\", &#123; template: `&lt;div&gt;花花说：&#123;&#123;huahua_said&#125;&#125;&lt;/div&gt;`, data: function () &#123; return &#123; huahua_said: \"\", &#125;; &#125;, mounted: function () &#123; //钩子，生命周期完成后，成熟后触发事件 var me = this; Event.$on(\"huahua-said-something\", function (data) &#123; me.huahua_said = data; &#125;); &#125;,&#125;);new Vue(&#123; el: \"#app\",&#125;); 过滤器 filter和计算属性类似，简单的用filter，复杂的用计算属性，计算属性有缓存 12345678910111213141516171819Vue.filter(\"meter\", function (val, unit) &#123; val = val || 0; //无val默认值为0 unit = unit || \"m\"; //无unit默认值为m return (val / 1000).toFixed(2) + unit;&#125;);Vue.filter(\"currency\", function (val, unit) &#123; val = val || 0; unit = unit || \"元\"; return val + unit;&#125;);new Vue(&#123; el: \"#app\", data: &#123; price: 10, length: 10, &#125;,&#125;); 1234567891011&lt;div&gt; &lt;input v-model=\"length\" /&gt; mm &lt;br /&gt; &#123;&#123;length | meter&#125;&#125;&lt;/div&gt;&lt;hr /&gt;&lt;div&gt; &lt;input v-model=\"price\" /&gt; &lt;br /&gt; &#123;&#123; price | currency('USD') &#125;&#125;&lt;/div&gt; 自定义指令 - 基础配置1234567891011121314151617181920212223Vue.directive(\"pin\", function (el, binding) &#123; var pinned = binding.value; //默认为false console.log(pinned); if (pinned) &#123; el.style.position = \"fixed\"; el.style.top = \"10px\"; el.style.left = \"10px\"; &#125; else &#123; el.style.position = \"static\"; &#125;&#125;);new Vue(&#123; el: \"#app\", data: &#123; card1: &#123; pinned: false, &#125;, card2: &#123; pinned: false, &#125;, &#125;,&#125;); 12345678&lt;div v-pin=\"card1.pinned\" class=\"card\"&gt; &lt;button @click=\"card1.pinned = !card1.pinned\"&gt;钉住/取消&lt;/button&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt;&lt;div v-pin=\"card2.pinned\" class=\"card\"&gt; &lt;a @click=\"card2.pinned = !card2.pinned\" href=\"#\"&gt;pin it&lt;/a&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt; 自定义指令 - 配置传参及修饰符123456789101112131415161718192021222324252627282930313233Vue.directive(\"pin\", function (el, binding) &#123; var pinned = binding.value; //modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。 var position = binding.modifiers; var warning = binding.arg; //arg紧跟: if (pinned) &#123; el.style.position = \"fixed\"; for (var key in position) &#123; if (position[key]) &#123; el.style[key] = \"10px\"; &#125; &#125; if (warning === \"true\") &#123; el.style.background = \"yellow\"; &#125; &#125; else &#123; el.style.position = \"static\"; &#125;&#125;);new Vue(&#123; el: \"#app\", data: &#123; card1: &#123; pinned: false, &#125;, card2: &#123; pinned: false, &#125;, &#125;,&#125;); 12345678&lt;div v-pin:true.bottom.left=\"card1.pinned\" class=\"card\"&gt; &lt;button @click=\"card1.pinned = !card1.pinned\"&gt;钉住/取消&lt;/button&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt;&lt;div v-pin=\"card2.pinned\" class=\"card\"&gt; &lt;a @click=\"card2.pinned = !card2.pinned\" href=\"#\"&gt;pin it&lt;/a&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt; ###混合 mixins component中代码复用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var base = &#123; methods: &#123; show: function () &#123; this.visible = true; &#125;, hide: function () &#123; this.visible = false; &#125;, toggle: function () &#123; this.visible = !this.visible; &#125;, &#125;, data: function () &#123; return &#123; visible: false, &#125;; &#125;,&#125;;Vue.component(\"tooltip\", &#123; template: ` &lt;div&gt; &lt;span @mouseenter=\"show\" @mouseleave=\"hide\"&gt;bys&lt;/span&gt; &lt;div v-if=\"visible\"&gt; 白岩松 &lt;/div&gt; &lt;/div&gt; `, mixins: [base], data: function () &#123; return &#123; visible: true, &#125;; &#125;,&#125;);Vue.component(\"popup\", &#123; template: ` &lt;div&gt; &lt;button @click=\"toggle\"&gt;Popup&lt;/button&gt; &lt;div v-if=\"visible\"&gt; &lt;span @click=\"hide\"&gt;X&lt;/span&gt; &lt;h4&gt;title&lt;/h4&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Amet dolorum, iusto non nostrum porro ratione. Dolor dolorem id impedit. Dolore excepturi exercitationem incidunt iste magnam odio quas temporibus. Assumenda, magni. &lt;/div&gt; &lt;/div&gt; `, mixins: [base],&#125;);new Vue(&#123; el: \"#app\", data: &#123;&#125;,&#125;); 1234&lt;div id=\"app\"&gt; &lt;tooltip&gt;&lt;/tooltip&gt; &lt;popup&gt;&lt;/popup&gt;&lt;/div&gt; 插槽 slots 相当于component中的变量 1234567891011121314151617181920212223242526&lt;div id=\"app\"&gt; &lt;panel&gt; &lt;div slot=\"title\"&gt; Yo. &lt;/div&gt; &lt;div slot=\"content\"&gt; Yo Yo Yo &lt;/div&gt; &lt;/panel&gt;&lt;/div&gt;&lt;template id=\"panel-tpl\"&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"title\"&gt; &lt;slot name=\"title\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;slot name=\"content\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;slot name=\"footer\"&gt; 更多信息 &lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; vue-router 是什么和怎么用 无整页刷新，表单数据点回来仍保留 安装和基本配置12345678910111213141516171819202122232425262728293031var routes = [ &#123; path: \"/\", component: &#123; template: ` &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;, &#123; path: \"/about\", component: &#123; template: ` &lt;div&gt; &lt;h1&gt;关于我们&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;);new Vue(&#123; el: \"#app\", router: router,&#125;); 123456789&lt;div id=\"app\"&gt; &lt;div&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于我们&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 传参及获取传参123456789path: '/user/:name',component: &#123; template: ` &lt;div&gt; &lt;div&gt;我叫：&#123;&#123;$route.params.name&#125;&#125;&lt;/div&gt; &lt;div&gt;我今年：&#123;&#123;$route.query.age&#125;&#125;岁了&lt;/div&gt; &lt;/div&gt; `,&#125;, 1234567891011&lt;div id=\"app\"&gt; &lt;div&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于我们&lt;/router-link&gt; &lt;router-link to=\"/user/王花花\"&gt;王花花&lt;/router-link&gt; &lt;router-link to=\"/user/李拴蛋\"&gt;李拴蛋&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 子路由123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var routes = [ &#123; path: \"/\", component: &#123; template: ` &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;, &#123; path: \"/about\", component: &#123; template: ` &lt;div&gt; &lt;h1&gt;关于我们&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;, &#123; path: \"/user/:name\", component: &#123; template: ` &lt;div&gt; &lt;div&gt;我叫：&#123;&#123;$route.params.name&#125;&#125;&lt;/div&gt; &lt;router-link to=\"more\" append&gt;更多信息&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `, &#125;, children: [ &#123; path: \"more\", component: &#123; template: ` &lt;div&gt; 用户&#123;&#123;$route.params.name&#125;&#125;的详细信息 Lorem ipsum dolor sit amet, consectetur adipisicing elit. Adipisci cum deleniti doloribus expedita inventore natus officiis quod quos similique voluptate! Distinctio nisi sequi tenetur voluptatum? Debitis iste neque pariatur voluptatibus? &lt;/div&gt; `, &#125;, &#125;, ], &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;); 1234567891011&lt;div id=\"app\"&gt; &lt;div&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于我们&lt;/router-link&gt; &lt;router-link to=\"/user/王花花\"&gt;王花花&lt;/router-link&gt; &lt;router-link to=\"/user/李拴蛋\"&gt;李拴蛋&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 手动访问和传参命名视图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var routes = [ &#123; path: \"/\", component: &#123; template: ` &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;, &#123; path: \"/user\", components: &#123; sidebar: &#123; template: ` &lt;div&gt; &lt;ul&gt; &lt;li&gt;用户列表&lt;/li&gt; &lt;li&gt;权限管理&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, &#125;, content: &#123; template: ` &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Deleniti in, laborum molestias necessitatibus optio perferendis quaerat quas qui quisquam sapiente. Architecto corporis eos eum libero optio, perspiciatis quo rem vel!&lt;/div&gt; `, &#125;, &#125;, &#125;, &#123; path: \"/post\", components: &#123; sidebar: &#123; template: ` &lt;div&gt; &lt;ul&gt; &lt;li&gt;帖子列表&lt;/li&gt; &lt;li&gt;标签管理&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, &#125;, content: &#123; template: ` &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Deleniti in, laborum molestias necessitatibus optio perferendis quaerat quas qui quisquam sapiente. Architecto corporis eos eum libero optio, perspiciatis quo rem vel!&lt;/div&gt; `, &#125;, &#125;, &#125;,]; 导航钩子 访问限制，中间件，组件的生命周期 123456789101112131415161718192021222324252627282930313233var routes = [ &#123; path: \"/\", component: &#123; template: `&lt;h1&gt;首页&lt;/h1&gt;`, &#125;, &#125;, &#123; path: \"/login\", component: &#123; template: `&lt;h1&gt;登录&lt;/h1&gt;`, &#125;, &#125;, &#123; path: \"/post\", component: &#123; template: `&lt;h1&gt;帖子管理&lt;/h1&gt;`, &#125;, &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;);router.beforeEach(function (to, from, next) &#123; var logged_in = true; if (!logged_in &amp;&amp; to.path == \"/post\") next(\"/login\"); else next();&#125;);router.afterEach(function (to, from) &#123;&#125;); 元数据及路由匹配 使用 meta 元数据进行访问限制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var routes = [ &#123; path: \"/\", component: &#123; template: `&lt;h1&gt;首页&lt;/h1&gt;`, &#125;, &#125;, &#123; path: \"/a\", meta: &#123; login_required: true, &#125;, component: &#123; template: `&lt;h1&gt;A&lt;/h1&gt;`, &#125;, &#125;, &#123; path: \"/login\", component: &#123; template: `&lt;h1&gt;登录&lt;/h1&gt;`, &#125;, &#125;, &#123; path: \"/post\", meta: &#123; login_required: true, &#125;, component: &#123; template: `&lt;div&gt; &lt;h1&gt;帖子管理&lt;/h1&gt; &lt;router-link to=\"rain\" append&gt;后座&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;`, &#125;, children: [ &#123; path: \"rain\", component: &#123; template: `&lt;h2&gt;雨天asdf后座&lt;/h2&gt;`, &#125;, &#125;, ], &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;);router.beforeEach(function (to, from, next) &#123; var logged_in = true; if ( !logged_in &amp;&amp; to.matched.some(function (item) &#123; return item.meta.login_required; &#125;) ) next(\"/login\"); else next();&#125;);","categories":[],"tags":[]},{"title":"ThinkPHP学习小记","slug":"yuque/ThinkPHP学习小记","date":"2020-05-03T10:02:36.000Z","updated":"2020-05-03T15:25:21.122Z","comments":true,"path":"2020/05/03/yuque/ThinkPHP学习小记/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/ThinkPHP学习小记/","excerpt":"","text":"ID 不从 1 开始truncate table 你的表名 无法访问可能保存了带bom的utf编码 部署到 iis 服务器将runtime设定到支持写入的目录 数据不为空显示123456789&lt;!-- 不等于 --&gt;&lt;if condition=\"$result[0]['jiyao_id'] neq null\"&gt; &lt;tr&gt; &lt;td style=\"vertical-align: middle;text-align:center;width: 20%\"&gt; &lt;span&gt;&lt;b&gt;机要编号&lt;/b&gt;&lt;/span&gt; &lt;/td&gt; &lt;td class=\"description\"&gt;&#123;$result[0]['jiyao_id']&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/if&gt; 1 0 转换12&lt;!-- 字符串用'' --&gt;&lt;if condition=\"$student.is_searched eq 1\"&gt;已查询&lt;else/&gt;未查询&lt;/if&gt;&lt;/td&gt;","categories":[],"tags":[]},{"title":"Spring学习小记","slug":"yuque/Spring学习小记","date":"2020-05-03T10:02:31.000Z","updated":"2020-05-03T15:25:21.128Z","comments":true,"path":"2020/05/03/yuque/Spring学习小记/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Spring学习小记/","excerpt":"","text":"IOC image.png AOP image.png HibernateSpringMVC image.png","categories":[],"tags":[]},{"title":"Java学习小记","slug":"yuque/Java学习小记","date":"2020-05-03T10:02:26.000Z","updated":"2020-05-03T15:25:21.145Z","comments":true,"path":"2020/05/03/yuque/Java学习小记/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Java学习小记/","excerpt":"","text":"Scanner123456789101112131415161718192021222324252627282930313233343536373839404142Scanner s = new Scanner(System.in);// 使用hasNextXxx()方法进行验证，再使用nextXxx()来读取// next()// next() 不能得到带有空格的字符串import java.util.Scanner;public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 //next方式接收字符串 System.out.println(\"next方式接收：\"); // 判断是否还有输入 if(scan.hasNext())&#123; String str1 = scan.next(); System.out.println(\"输入的数据为：\"+str1); &#125; &#125;&#125;// nextLine()// 以Enter为结束符，可以获得空白import java.util.Scanner;public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 //nextLine方式接收字符串 System.out.println(\"nextLine方式接收：\"); // 判断是否还有输入 if(scan.hasNextLine())&#123; String str2 = scan.nextLine(); System.out.println(\"输入的数据为：\"+str2); &#125; &#125;&#125;scanner.close(); 数组大小用 size()1students.size(); 数组访问用 get()1temp = students.get(i); 数组修改用 set()1students.set(i, stu); for 的遍历1234567891011// 打印所有学生的信息public void displayAllStudent() &#123; if (students.size() &gt; 0) &#123; for (Student stu : students) &#123; System.out.println(\"学号: \" + stu.getSno() + \"\\t姓名: \" + stu.getSname() + \"\\t系部: \" + stu.getSdept()); &#125; &#125;else &#123; System.out.println(\"数据库中无学生记录!\"); &#125;&#125; 读取文件123456789101112131415161718192021// 读取文件获得原始数据private void getData() &#123; try &#123; FileReader in_ = new FileReader(\"StudentDAO.txt\"); BufferedReader in = new BufferedReader(in_); String line; String reg1 = \"\\\\s+\"; String str[] = new String[3]; while ((line = in.readLine()) != null) &#123; Student temp = new Student(); str = line.split(reg1); temp.setSno(str[0]); temp.setSname(str[1]); temp.setSdept(str[2]); students.add(temp); &#125; in.close(); &#125; catch (IOException e) &#123; System.out.println(e); &#125;&#125; 写入文件12345678910111213141516//更新数据库,把数据输入文件private void updateData() &#123; try &#123; FileWriter out_ = new FileWriter(\"StudentDAO.txt\"); BufferedWriter out = new BufferedWriter(out_); Student temp = new Student(); for (int i = 0; i &lt; students.size(); i++) &#123; temp = students.get(i); out.write(temp.getSno() + \" \" + temp.getSname() + \" \" + temp.getSdept() + \"\\r\\n\"); &#125; out.close(); &#125; catch (IOException e) &#123; System.out.println(e); &#125;&#125; BufferedReader12345678910do &#123; // 从输入流读取一个字符并把该字符作为整数值返回， 当流结束的时候返回 -1 c = (char)br.read(); System.out.println(c);&#125; while (c != 'q');do &#123; str = br.readLine(); System.out.println(str);&#125; while(!str.equals(\"end\")); FileInputStream（从文件读取数据）1234InputStream f = new FileInputStream(\"C:/java/hello\");File f = new File(\"C:/java/hello\");InputStream out = new FileInputStream(f); FileOutputStream（向文件中写数据）1234OutputStream f = new FileOutputStream(\"C:/java/hello\")File f = new File(\"C:/java/hello\");OutputStream f = new FileOutputStream(f); 读取写入流最后都要 close();读写一定要用 byte12byte bWrite[] = &#123; 11, 21, 3, 40, 5 &#125;;byte bWrite[] = \"zhouzhiwenishandsome\".getBytes();","categories":[],"tags":[]},{"title":"IEEE LaTeX模板使用BibTeX","slug":"yuque/IEEE LaTeX模板使用BibTeX","date":"2020-05-03T10:02:21.000Z","updated":"2020-05-03T15:25:21.166Z","comments":true,"path":"2020/05/03/yuque/IEEE LaTeX模板使用BibTeX/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/IEEE LaTeX模板使用BibTeX/","excerpt":"","text":"最近在写 IEEE 的论文，就为了参考文献不愿意下载那么大的 LaxTex，发现了一个在线的 LaTeX editor https://www.sharelatex.com/ ， 发现还挺好用的。 在 Google Scholar 获得的文献引用格式一般是 BibTex 的，而 IEEE Transactions 的模板默认用的是 BibItem。目前没有什么自动化的 BibTeX 转 BibItem 的工具或网站。 使用方法 在 Google Scholar 搜索到的文献结果，点击下面的“Cite”，然后点击“BibTeX”即可得到类似如下的文献信息 12345678910@article&#123;b1, // b1为正文引用时的名字 title=&#123;Reading behavior in the digital environment: Changes in reading behavior over the past ten years&#125;, author=&#123;Liu, Ziming&#125;, journal=&#123;Journal of documentation&#125;, volume=&#123;61&#125;, number=&#123;6&#125;, pages=&#123;700--712&#125;, year=&#123;2005&#125;, publisher=&#123;Emerald Group Publishing Limited&#125;&#125; 将以上信息添加到侧边栏中的 references.bib 文件中，文件名随意，与.tex 文件在同一目录 在 IEEE Transactions 模板中，默认的引用文献是这样写的 123456789\\begin&#123;thebibliography&#125;&#123;00&#125;\\bibitem&#123;b1&#125; G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,&apos;&apos; Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.\\bibitem&#123;b2&#125; J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.\\bibitem&#123;b3&#125; I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,&apos;&apos; in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.\\bibitem&#123;b4&#125; K. Elissa, ``Title of paper if known,&apos;&apos; unpublished.\\bibitem&#123;b5&#125; R. Nicole, ``Title of paper with only first word capitalized,&apos;&apos; J. Name Stand. Abbrev., in press.\\bibitem&#123;b6&#125; Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,&apos;&apos; IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].\\bibitem&#123;b7&#125; M. Young, The Technical Writer&apos;s Handbook. Mill Valley, CA: University Science, 1989.\\end&#123;thebibliography&#125; 将上述部分换成如下代码 12\\bibliographystyle&#123;IEEEtran&#125;\\bibliography&#123;references&#125;&#123;&#125; 点击重新编译即可看到效果 注意正文中必须要使用\\cite{b1}引用后，正文中的参考文献才会显示引用的条目，否则编译无数次也没有效果 😢","categories":[],"tags":[]},{"title":"IDEA构建SSH项目（hibernate自动生成+jetty的使用）","slug":"yuque/IDEA构建SSH项目（hibernate自动生成+jetty的使用）","date":"2020-05-03T10:02:16.000Z","updated":"2020-05-03T15:25:21.203Z","comments":true,"path":"2020/05/03/yuque/IDEA构建SSH项目（hibernate自动生成+jetty的使用）/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/IDEA构建SSH项目（hibernate自动生成+jetty的使用）/","excerpt":"","text":"1 创建 Maven 项目 GroupId 和 ArtifactId 被统称为“坐标”，是为了保证项目唯一性而提出的，如果你要把你项目弄到 maven 本地仓库去，你想要找到你的项目就必须根据这两个 id 去查找。 GroupId=域+公司名称。域又分为 org、com、cn 等，其中 org 为非营利组织，com 为商业组织。 apache 公司的 tomcat 项目：这个项目的 GroupId 是 org.apache，它的域是 org（因为 tomcat 是非营利项目），公司名称是 apache，ArtifactId 是 tomcat。 我一般会将 GroupId 设置为 cn.ftx，cn 表示域为中国，ftx 是我个人姓名缩写，ArtifactId 设置为 testProject，表示这个项目的名称是 testProject。 依照这个设置，在创建 Maven 工程后，新建包的时候，包结构最好是 cn.ftx.testProject 打头的，如果有个 StudentDao，它的全路径就是 cn.ftx.testProject.dao.StudentDao 2 修改目录结构默认生成的目录结构 标准的 Maven 项目结构java 目录需 mark didectory as source root，resources 目录需 mark directory as resources root Java 源代码结构 配置文件 3 在 pom.xml 中添加依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.ftx&lt;/groupId&gt; &lt;artifactId&gt;testProject&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;testProject Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.3.17.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.3.7.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-jpa --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.11.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-commons --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-commons&lt;/artifactId&gt; &lt;version&gt;1.13.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.18.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--aspectj切面依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;!--用于springMVC验证的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.7.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!--处理json用到的依赖，用于对应的HttpMessageConverter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--jetty依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;version&gt;9.3.2.v20150730&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt; &lt;version&gt;9.3.2.v20150730&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;apache-jsp&lt;/artifactId&gt; &lt;version&gt;9.3.2.v20150730&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;apache-jstl&lt;/artifactId&gt; &lt;version&gt;9.3.2.v20150730&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;sy5-web&lt;/finalName&gt; &lt;!--防止maven构建时忽略xml文件--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.20.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;!--jetty插件--&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.3.12.v20160915&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 4 新建 Resource Bundel config.properties123456789101112################### JDBC Configuration ##########################jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost/sy5?useSSL=false&amp;serverTimezone=Asia/Shanghaijdbc.username=rootjdbc.password=123456789################### Hibernate Configuration ##########################hibernate.dialect=org.hibernate.dialect.MySQLDialecthibernate.show_sql=falsehibernate.hbm2ddl.auto=updatehibernate.format_sql=truehibernate.generate_statistics=true 5 在 resources 中添加 web 容器 dispatcher-servlet.xml 最常用的 URL 文件应该就是 jsp 页面了，InternalResourceViewResolver 解析器可以解析该资源 prefix 和 suffix 属性可以指定资源页面的前缀和后缀，可以直接把资源位置定位到项目的/WEB-INF/下面 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;mvc:annotation-driven/&gt; &lt;context:component-scan base-package=\"cn.ftx.testProject\"/&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/views/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 6 在 resources 中添加 spring 容器 applicationContext.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;!-- 自动扫描所有注解该路径 --&gt; &lt;context:component-scan base-package=\"cn.ftx.testProject\"/&gt; &lt;tx:annotation-driven transaction-manager=\"txManage\"/&gt; &lt;!--引入配置文件--&gt; &lt;bean id=\"propertyConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:config.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--数据库连接--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"mappingDirectoryLocations\"&gt; &lt;list&gt; &lt;value&gt;classpath:cn/ftx/testProject/model&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;prop key=\"hibernate.dialect\"&gt;$&#123;hibernate.dialect&#125;&lt;/prop&gt; &lt;prop key=\"hibernate.show_sql\"&gt;$&#123;hibernate.show_sql&#125;&lt;/prop&gt; &lt;prop key=\"format_sql\"&gt;$&#123;hibernate.format_sql&#125;&lt;/prop&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;$&#123;hibernate.hbm2ddl.auto&#125;&lt;/prop&gt; &lt;prop key=\"generate_statistics\"&gt;$&#123;hibernate.generate_statistics&#125;&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=\"packagesToScan\" value=\"cn.ftx.testProject\"&gt;&lt;/property&gt; &lt;!--映射文件地址--&gt; &lt;property name=\"mappingLocations\"&gt; &lt;list&gt; &lt;value&gt;classpath:cn/ftx/testProject/model/Tequipment.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"txManage\" class=\"org.springframework.orm.hibernate4.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 7 配置 webapp/WEB-INF/web.xml 在 web.xml 中添加监听器，为了加载 spring 容器的配置文件，指定 spring web 容器配置文件的目录 /表示从 webapp 开始，例如：使用/layout/style.css访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt; &lt;!-- 项目名称 --&gt; &lt;display-name&gt;testProject&lt;/display-name&gt; &lt;!-- 指定spring相关文件的位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 开启spring功能 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置spring mvc --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 配置spring mvc mapping --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置字符集过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 配置项目的编码mapping --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 防止内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置静态资源不经过spring mvc --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.json&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ico&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.doc&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.xls&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.docx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.xlsx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.txt&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.swf&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置session超时时间，单位分钟 --&gt; &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!-- 设置欢迎页面 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;/init.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 找不到页错误转向 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error/404.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;!-- 系统内部错误转向 --&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error/500.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;!-- druid数据源Web监控配置 --&gt; &lt;filter&gt; &lt;filter-name&gt;druidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;/css/*,/style/*,/jslib/*,*.js,*.css,/druid*,/attached/*,*.jsp&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;principalSessionName&lt;/param-name&gt; &lt;param-value&gt;sessionInfo&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;profileEnable&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- druid数据源Web监控配置mapping --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;druidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- druid监控页面，使用$&#123;pageContext.request.contextPath&#125;/druid/index.html访问 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;druidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- druid监控页面mapping --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;druidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 8 hibernate 自动创建 9 使用 jetty *如何打开一个别人的项目 修改成自己的 maven 配置 一直 next，直到 finish 即可","categories":[],"tags":[]},{"title":"Hexo使用心得","slug":"yuque/Hexo使用心得","date":"2020-05-03T10:02:11.000Z","updated":"2020-05-03T15:25:21.214Z","comments":true,"path":"2020/05/03/yuque/Hexo使用心得/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Hexo使用心得/","excerpt":"","text":"新建文章hexo new &quot;Hexo使用心得&quot; 上传图片到 github 并使用 将_config.yml中有的post_asset_folder设置为true 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save 完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹 使用![test](Hexo使用心得/test.jpg)就可以插入图片。其中[]里面不写文字则没有图片标题 Hexo-admin本地的文章编辑器，不支持在线/admin访问，github.io都是静态界面 更新文章hexo d -g","categories":[],"tags":[]},{"title":"Django入门与实践","slug":"yuque/Django入门与实践","date":"2020-05-03T10:02:05.000Z","updated":"2020-05-03T15:25:21.216Z","comments":true,"path":"2020/05/03/yuque/Django入门与实践/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Django入门与实践/","excerpt":"","text":"image.png","categories":[],"tags":[]},{"title":"Axure使用心得","slug":"yuque/Axure使用心得","date":"2020-04-05T00:56:51.000Z","updated":"2020-05-03T15:25:21.220Z","comments":true,"path":"2020/04/05/yuque/Axure使用心得/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/Axure使用心得/","excerpt":"","text":"按住 Ctrl 时，可以旋转 按住 Ctrl 时，拖动曲线 右键转换曲线的类型","categories":[],"tags":[]},{"title":"Android学习小记","slug":"yuque/Android学习小记","date":"2020-04-05T00:56:46.000Z","updated":"2020-05-03T15:25:21.251Z","comments":true,"path":"2020/04/05/yuque/Android学习小记/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/Android学习小记/","excerpt":"","text":"禁止 Android 不跟随屏幕密度加载不同文件夹的资源在 AndroidManifest.xml 文件中添加 android:anyDensity=”false”字段 高分辨率，一般我们把图片丢这里 mipmap-hdpi调试时默认生成的 apk 在：app/build/outputs/apk 目录下Android Studio 打包时 Signature Version V1 V2 同时勾选 V1 和 V2 则所有机型都没问题 生成目录 E:\\wamp64\\www\\EAider\\app\\release 发布 apk 做代码混淆 爱加密match_parent 和 fill_parent fill_parent = match_parent（一般用 match_parent） wrap_content 设置一个视图的尺寸为 wrap_content 将强制性地使视图扩展以显示全部内容。以 TextView 和 ImageView 控件为例，设置为 wrap_content 将完整显示其内部的文本和图像。布局元素将根据内容更改大小。设置一个视图的尺寸为 wrap_content 大体等同于设置 Windows 控件的 Autosize 属性为 True。 layout_gravity 和 gravity android:gravity属性是对该view中内容的限定，比如一个 button 上面的 text，你可以设置该 text 相对于 view 的靠左，靠右等位置 android:layout_gravity是用来设置该 view 相对与父 view 的位置，比如一个 button 在 linearlayout 里，你想把该 button 放在 linearlayout 里靠左、靠右等位置就可以通过该属性设置 android:gravity用于设置 View 中内容相对于 View 组件的对齐方式 android:layout_gravity用于设置 View 组件相对于 Container 的对齐方式 线性布局 权重用途很大 当android:orientation=&quot;vertical&quot;时，只有水平方向的设置才起作用，垂直方向的设置不起作用。即：left,right,center_horizontal是生效的 当android:orientation=&quot;horizontal&quot;时，只有垂直方向的设置才起作用，水平方向的设置不起作用。即：top,bottom,center_vertical是生效的 分隔线1234&lt;View android:layout_width=\"match_parent\" android:layout_height=\"1px\" android:background=\"#000000\"/&gt; 布局使用RelativeLayout+LinearLayout的weight属性搭配使用相对布局广告弹出框 Demo12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/RelativeLayout1\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#00CCCCFF\"&gt; &lt;ImageView android:id=\"@+id/img1\" android:background=\"#000\" android:layout_centerInParent=\"true\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" /&gt; &lt;ImageView android:id=\"@+id/imgCancle\" android:layout_alignRight=\"@id/img1\" android:layout_alignTop=\"@id/img1\" android:background=\"#5555\" android:layout_marginTop=\"-15dp\" android:layout_marginRight=\"-10dp\" android:layout_width=\"28dp\" android:layout_height=\"28dp\" /&gt;&lt;/RelativeLayout&gt; 表格布局帧布局 FrameLayout android:foreground:设置改帧布局容器的前景图像 android:foregroundGravity:设置前景图像显示的位置 网格布局 GridLayout 默认每个组件都是占一行一列 通过android:layout_rowSpan与android:layout_columnSpan设置了组件横跨多行或者多列的话，如果你要让组件填满横越过的行或列的话，需要添加android:layout_gravity = &quot;fill&quot; 低版本 sdk 如何使用 GridLayout&lt;android.support.v7.widget.GridLayout&gt;，v7包一般在sdk下的sdk\\extras\\android\\support\\v7\\gridlayout目录下 几个单位 dp(dip): device independent pixels(设备独立像素)，不同设备有不同的显示效果，这个和设备硬件有关，一般我们为了支持 WVGA、HVGA 和 QVGA 推荐使用这个，不依赖像素 px: pixels(像素)，不同设备显示效果相同，一般我们 HVGA 代表 320x480 像素，这个用的比较多 pt: point，是一个标准的长度单位，1pt ＝ 1/72 英寸，用于印刷业，非常简单易用 sp: scaled pixels(放大像素)，主要用于字体显示 best for textsize 布局层次越少，性能越好设置的 drawable 并不能自行设置大小，在 XML 是无法直接设置的，所以需要在 Java 代码中来进行修改","categories":[],"tags":[]},{"title":"一图看懂React diff","slug":"yuque/一图看懂React diff","date":"2020-04-05T00:56:41.000Z","updated":"2020-05-03T15:25:21.290Z","comments":true,"path":"2020/04/05/yuque/一图看懂React diff/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/一图看懂React diff/","excerpt":"","text":"React 中最值得称道的部分莫过于 Virtual DOM 与 diff 的完美结合，特别是其高效的 diff 算法，让用户可以无需顾忌性能问题而”任性自由”的刷新页面，让开发者也可以无需关心 Virtual DOM 背后的运作原理，因为 React diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染，因此 Virtual DOM 与 diff 是保证 React 性能口碑的幕后推手。 1 diff 策略 Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分 以上三个策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。 2 tree diff基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。 既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。 如果出现 dom 节点跨层级的移动操作，因为该节点已经不在原来的 dom 树层， 所以会直接删除该节点，在移动后的 dom 层重建该节点， 可见这种操作的性能代价非常大，所以不推荐这样做。 可以通过 css 样式控制节点的隐藏和显示来代替节点跨层级移动的操作。 3 component diffReact 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。 如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。 如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。 4 element diff当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。 INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。 MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。 REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。 开发者对同一层级的子节点，可以添加唯一索引进行区分，这样在 diff 时，涉及到只是位置变化的，可以只移动元素，避免删除创建等重复的操作。","categories":[],"tags":[]},{"title":"我的博客目录","slug":"yuque/我的博客目录","date":"2020-04-05T00:56:36.000Z","updated":"2020-05-03T15:25:21.357Z","comments":true,"path":"2020/04/05/yuque/我的博客目录/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/我的博客目录/","excerpt":"","text":"title: 我的博客目录date: 2019年04月08日 00:27:43categories: Careertypora-root-url: ..typora-copy-images-to: ../images JavaScript 简介 汇总 变量类型和计算1. 内置类型 2. typeof 3. 类型转换 转 Boolean 对象转基本类型 四则运算符 ==操作符 比较运算符 原型与原型链1. new 2. instanceof 闭包和作用域1. 执行上下文 2. this 3. call, apply, bind 区别 模拟实现 call 和 apply 异步和单线程其它1. 日期 2. Math 3. 常用 API JS-Web-API1. DOM 2. BOM ES6深浅拷贝1. 浅拷贝 2. 深拷贝 模块化1. CommonJS 2. AMD 防抖节流继承Promise 实现Generator 实现Map、FlapMap 和 Reduceasync 和 awaitProxy为什么 0.1 + 0.2 != 0.3正则表达式1. 元字符 2. 修饰语 3. 字符简写 Browser 事件机制 事件触发三阶段 注册事件 事件代理 跨域 JSONP CORS document.domain postMessage Event loop Node 中的 Event loop 浏览器中的 Event loop 存储 cookie, localStorage, sessionStorage, indexDB Service Worker 渲染机制 Load 和 DOMContentLoaded 区别 图层 重绘(Repaint)和回流(Reflow) 减少重绘和回流 Performance 网络相关- DNS 预解析 - 缓存 - 强缓存 - 协商缓存 - Last-Modifhed和If-Modifhed-Since - ETag和If-None-Match - 选择合适的缓存策略 - 使用 HTTP/2.0 - 预加载 - 预渲染 优化渲染过程 懒执行 懒加载 文件优化- 图片优化 计算图片大小 图片加载优化- 其他文件优化 - CDN 其他 使用 Webpack 优化项目 监控 Safety XSS 如何攻击 如何防御 CSP CSRF- 如何攻击 - 如何预防 SameSite 验证 Referer Token 密码安全 加盐 Framework 通识- MVVM 脏数据检测 数据劫持 Proxy 与 Obeject.defineProperty 对比- Virtual Dom 为什么需要 Virtual Dom Virtual Dom 算法简述 Virtual Dom 算法实现 Vue 生命周期分析 NextTick 原理分析 React 生命周期分析 V16 生命周期函数用法建议 setState Redux 源码分析 Network UDP 不可靠性 面向报文 高效 传输方式 TCP- 头部 - 状态机 建立连接三次握手 断开链接四次握手- ARQ 协议 停止等待 ARQ 连续 ARQ 累计确认- 滑动窗口 Zero 窗口- 拥塞处理 慢开始算法 拥塞避免算法 快速重传 TCP New Ren 改进后的快恢复 HTTP Post 和 Get 的区别 常见状态码 HTTP 首部 HTTPS TLS HTTP 2.0 二进制传输 多路复用 Header 压缩 服务端 Push QUIC DNS从输入 URL 到页面加载完成的过程DataStruct 栈队列链表树Trie并查集堆Algorithm 时间复杂度位运算 左移&lt;&lt; 算数右移&gt;&gt; 按位操作 排序 冒泡排序 插入排序 选择排序 归并排序 快排 堆排序 系统自带排序实现 链表 反转单向链表 树 二叉树的先序，中序，后序遍历 中序遍历的前驱后继节点 树的深度 动态规划 斐波那契数列 0-1 背包问题 最长递增子序列 Git RebasestashreflogresetCareer 花时间补基础，读文档学会搜索学点英语画个图，想一想再做利用好下班时间学习列好 ToDo反思和整理","categories":[],"tags":[]},{"title":"软件工程项目管理体系","slug":"yuque/软件工程项目管理体系","date":"2020-04-05T00:56:31.000Z","updated":"2020-05-03T15:25:21.359Z","comments":true,"path":"2020/04/05/yuque/软件工程项目管理体系/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/软件工程项目管理体系/","excerpt":"","text":"image.png","categories":[],"tags":[]},{"title":"如何写好论文","slug":"yuque/如何写好论文","date":"2020-04-05T00:56:26.000Z","updated":"2020-05-03T15:25:21.419Z","comments":true,"path":"2020/04/05/yuque/如何写好论文/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/如何写好论文/","excerpt":"","text":"1 题名要精练准确地表达最核心的内容题名、摘要、论文这 3 项，首先是论文要好，学术质量要高，这一点毫无疑问。然而论文好而不被收录，这也屡见不鲜。 2002 年没被检索的 4 篇学报论文中，有 3 篇是国家自然科学基金项目资助论文，从专家评审意见看，学术质量是高的；2004 年第 1 期的第 1 篇文章《基于整形小波变换的零树编码算法的改进》，也是学术水平很高的，但钟先生第 1 眼看到“??的改进”这一题名，就马上反映：学术水平不高，不会收录。当作为计算机专家的钟先生仔细阅读了全文后，却认为它是前 3 篇最好的，并提议将题名改为《用整形小波变换简化零树编码算法》。经与作者沟通，也认为改后的题名，能够更加精练准确地表达文章最核心的内容，更加吸引人，改得好。此外，钟先生还指出，20 篇论文题名中，有 2 篇为“XX 的研究”，4 篇为“XX 的应用”。 这些论文的题名，往往不会引起 EI 收录人员的兴趣。所以从这个角度说，论文题名是题名、摘要、论文这 3 项的重中之重，被读者看到的机会最多，可称为画龙点睛之笔，决定整篇论文的命运：这一笔写得有神，可吸引读者进一步读下去，收录利用和引用其成果；否则就再没有被光顾利用的机会。 2 摘要中 4 项内容都不能缺摘要的 4 项是指：目的、方法和过程、结果、结论。 摘要应有独立性和自含性，是一个独立的短文，即不阅读文献全文，就能获得必要的信息。其中要突出创新点，把创新点写清楚了，其引用率必然会高。钟先生指出，第 1 期 20 篇论文摘要中，半数以上没有写目的，有的没有写明方法和过程，有的没有写结果和结论，或结果只有形容词的叙述而没有量化。有的中文摘要虽写了出来，但英文没有翻译，还等于没写。 例如，第 1 篇论文，中文摘要虽写明了研究目的，但英文没有翻译出来；其结果“使零树编码在整形小波中得到高效应用”中的“高效”没有量化。这些残缺不全的摘要，不能清楚、准确地把文章的核心内容表达出来。尽管一些文章内容很好，但由于英文摘要没有认真写好，将没有机会被 EI 收录，这是很可惜、很遗憾的。 所以作者在完成一篇优秀的学术论文的同时，下大力气写好中英文摘要，一点也不为过。用钟先生的话说，英文摘要应该是：可读通俗、精练准确、清晰紧凑、客观完整，语言有逻辑性，不要太专业化。能用最少的词，清楚、准确地把最核心的内容表达出来。 3 要有最新的一定数量的参考文献文后是否有与该文相关的、一定数量的、最新的和标注准确的期刊论文作参考文献，往往被看作是衡量作者吸纳这一领域最新科研成果能力的大小，研究学问的态度是否科学严谨和该论文是否有创新性的标志，不容忽视。 在学报的审稿过程中发现，有的看起来不错，但评审意见认为没有创新性的论文，往往都是文后参考文献偏少、不新，或多为教科书。在某一层面反映了作者对新的学术成果没有研究和吸纳，对旧的东西没有比较，其论文的创新性自然也不会凸现出来。 据统计，国际期刊篇均引文数为 28 条。国内期刊则仅为 6.99 ～ 14 条。学报第 1 期篇均引文数为 8.45 条，还是有一定差距的。刊物的影响因子，被引用频次是通过对参考文献的统计得到的，因此参考文献的正确标引，在某种程度上表明了一篇论文，一个刊物的学术水平，进而也在一定程度上反映了一个国家的学术水平。 要想被 EI 核心库收录，学报的作者和编辑一定要重视学报论文参考文献的正确著录，严格遵循“著录直接引用文献，最必要、最主要、最新的文献和正式出版的文献”的著录原则，并把中文和其他非英文的参考文献，准确地翻译成英文(EI 对非英文参考文献超过 50 的论文不予收录)，让中外读者和文献统计调查人员能够通过对学报论文后参考文献的检索，方便地进入国际联机检索系统。否则将有损于学报及作者本人的声誉。 4 用清楚的语言介绍自己的研究成果提纲挈领，摘要写好了，写文章的思路就清晰了。 IMRAD (Introduction，Methods，Results And Discussions)结构包括 Introduction 为什么提出这个问题（背景） 要研究的问题是什么 为什么要做这个研究（意义） Methods 描述研究的方法 试验手段和材料（技术） Results And Discussions 结果是什么 得到了什么结论 这 3 部分就分别对应摘要中的目的、方法和过程、结果和结论。与文学作品及政治论述不同，科学论文要使用准确的语言来论述，文风要简洁、结果要量化，自己的工作和成果要说清楚。即“要有创新性”，不能把已有的成果与自己的混为一谈，否则有侵犯他人著作权之嫌。","categories":[],"tags":[]},{"title":"认识并使用 Promise","slug":"yuque/认识并使用 Promise","date":"2020-04-05T00:56:21.000Z","updated":"2020-05-03T15:25:21.451Z","comments":true,"path":"2020/04/05/yuque/认识并使用 Promise/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/认识并使用 Promise/","excerpt":"","text":"title: 认识并使用 Promisedate: 2020 年 04 月 04 日 10:23:22categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 1 什么是 PromisePromise 是一个异步操作返回的对象，用来传递异步操作的消息。 可以解决的问题： 解决了回调地狱问题，不会导致难以维护； 合并多个异步请求，节约时间。 Promise 有三种状态： Pending Promise 对象实例创建时的初始态； Fulfilled 成功时的状态； Rejected 失败时的状态。 2 使用 PromisePromise.then()：用来指定 Promise 对象的状态改变时要执行的操作。 12345678910111213let promise = new Promise(function (resolve, reject) &#123; resolve(\"成功\"); //reject('失败');&#125;);promise.then( function (data) &#123; console.log(\"data: \", data); &#125;, function (err) &#123; console.log(\"err: \", err); &#125;); Promise.all()：接收一个数组，数组内是 Promise 实例，必须都成功呢才表示成功。 Promise.race()：接收一个数组，数组内是 Promise 实例，最早返回的对象成功了，就变为成功态，如果失败了，就改变状态为失败态。 123456789101112131415161718192021222324252627let fs = require(\"fs\");function read(url) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(url, \"utf8\", function (err, data) &#123; if (err) reject(err); resolve(data); &#125;); &#125;);&#125;Promise.all([read(\"1.txt\"), read(\"2.txt\")]).then( function (data) &#123; console.log(data); &#125;, function (err) &#123; console.log(\"err: \", err); &#125;);Promise.race([read(\"1.txt\"), read(\"2.txt\")]).then( function (data) &#123; console.log(data); &#125;, function (err) &#123; console.log(\"err: \", err); &#125;); Promise.resolve()：返回一个 Promise 实例，这个 Promise 实例处于 resolve 状态。 123Promise.resolve([1, 2, 3]).then(function (data) &#123; console.log(data);&#125;); 输出：[ 1, 2, 3 ] Promise.reject()：返回一个 Promise 实例，这个 Promise 实例处于 reject 状态。 123Promise.reject([1, 2, 3]).then(null, function (err) &#123; console.log(\"err\", err);&#125;); 输出：err [ 1, 2, 3 ]","categories":[],"tags":[]},{"title":"前端开发笔记","slug":"yuque/前端开发笔记","date":"2020-04-05T00:56:16.000Z","updated":"2020-05-03T15:25:21.610Z","comments":true,"path":"2020/04/05/yuque/前端开发笔记/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/前端开发笔记/","excerpt":"","text":"title: 前端开发笔记 date: 2019 年 04 月 08 日 00:27:43categories: Careertypora-root-url: ..typora-copy-images-to: ../images aria-expanded=”false” aria-expanded表示展开状态。默认为undefined, 表示当前展开状态未知。其它可选值：true表示元素是展开的；false表示元素不是展开的 aria-hidden 字符串 可选值为true和false，true表示元素隐藏(不可见)，false表示元素可见 快捷键 Ctrl + Enter 光标不在末尾回车 Ctrl + Backspace 删除一个词 Ctrl + -&gt; 以词为单位后移 col-xs-n 中放图片不生效1234img &#123; display: block; max-width: 100%;&#125; display block 默认，此元素将显示为块级元素，此元素前后会带有换行符 inline 此元素会被显示为内联元素，元素前后没有换行符 inline-block 行内块元素 使用 col 就要在母元素上清除浮动，因为 col 栅格也是浮动的使用 flag 覆盖叠加新的属性 css中使用.side-bar-card.flag {}来调用 html中用&lt;div class=&quot;side-bar-card flag clearfix&quot;&gt; a 标签链接不带下划线，并列换行写1234567a,a:hover,a:visited,a:link,a:active &#123; text-decoration: none;&#125; line-heigh 不要写 px表格居中1&lt;table align=\"center\"&gt;&lt;/table&gt; bootstrap 响应式表格1&lt;div class=\"table-responsive\"&gt;&lt;/div&gt; 表格内容水平垂直居中12345678&lt;!-- 水平居中 --&gt;&lt;th style=\"text-align: center;\"&gt;host&lt;/th&gt;&lt;!-- 垂直居中 --&gt;&lt;td rowspan=\"$row_host1\" style=\"vertical-align: middle;\"&gt;host1&lt;/td&gt;&lt;!-- 既水平又垂直居中 --&gt;&lt;td rowspan=\"$rowspan\" style=\"vertical-align: middle;text-align: center;\"&gt; hello&lt;/td&gt; 图片撑满1background-size: cover; input/select/textarea/… + .form-control.form-group 单独的表单控件会被自动赋予一些全局样式。所有设置了.form-control类的&lt;input&gt;、&lt;textarea&gt;和&lt;select&gt;元素都将被默认设置宽度属性为width: 100%;。将label元素和前面提到的控件包裹在.form-group中可以获得最好的排列 响应式表格 将任何.table元素包裹在&lt;div class=&quot;table-responsive&quot;&gt;元素内 垂直方向的内容截断 响应式表格使用了overflow-y: hidden属性，这样就能将超出表格底部和顶部的内容截断。特别是，也可以截断下拉菜单和其他第三方组件 .form-inline 输入框和单选/多选框控件默认被设置为width: 100%;。在内联表单，我们将这些元素的宽度设置为width: auto;，因此，多个控件可以排列在同一行。根据布局需求，手动设置宽度 一定要添加label标签，对于内联表单，可以通过为label设置.sr-only类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如aria-label、aria-labelledby或title属性 .form-horizontal 无需再添加.row了 margin 对 span 无效12display: block;line-height: 1.5; button 后退123&lt;button class=\"btn btn-danger ycx\" onclick=\"javascript :history.back(-1);\"&gt; 返回&lt;/button&gt; 居中 文本内容居中：text-center 图片居中：center-block 其他类型元素居中：col-md-offset-X 在 form 标签上加 novalidate 属性，可以禁用 h5 默认的表单验证效果div置顶的方法12position: relative;z-index: 99999; margin:auto 实现绝对定位元素的居中12345678910.element &#123; width: 600px; height: 400px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;&#125; ajax 中 dataType 为预期服务器返回的数据类型，不写有默认值，开发过程中不要写服务器只返回单个String类型数据，则一定要写dataType: &#39;text&#39; ajax 表单序列化传输1234567891011121314$(\"#submit\").on(\"touchstart\", function () &#123; var form = $(\"#handouts\").serialize(); $.ajax(&#123; url: \"http://192.168.1.111:8686/EAnnotation/addPassage\", type: \"post\", data: form, cache: false, success: function (data) &#123; window.location.href = \"course.html\"; &#125;, error: function (e) &#123;&#125;, &#125;); return false;&#125;); ajax 表单传递键值对12345678910111213141516171819202122$.ajax(&#123; url: ip + \"/scm\", type: \"POST\", cache: false, data: &#123; username: username, password: password, &#125;, success: function (data) &#123; console.log(1); if (data == 0) &#123; alert(\"密码错误\"); &#125; else if (data == -1) &#123; alert(\"账号不存在\"); &#125; else &#123; console.log(data); // window.location.href = \"index.html\" localStorage.name = data; &#125; &#125;, error: function (e) &#123;&#125;,&#125;); ajax 传递 formDataformData 既可以传键值对，也可以传文件 1234567891011121314151617$(\"#submit\").on(\"touchstart\", function () &#123; var form = new FormData($(\"#homework\")[0]); $.ajax(&#123; url: \"https://bitcandy.one/EAnnotation/addPassage\", type: \"POST\", cache: false, data: form, processData: false, contentType: false, success: function (data) &#123; window.location.href = \"classteacher.html\"; console.log(form); &#125;, error: function (e) &#123;&#125;, &#125;); return false;&#125;); ajax 拿到 json 后如何使用123456789101112131415161718192021222324252627282930313233343536373839404142434445$.ajax(&#123; url: \"http://192.168.1.111:8686/EAnnotation/getAllPassages\", type: \"post\", cache: false, success: function (data) &#123; console.log(data); $.each(data, function (i, item) &#123; var time = getDateDiff(item.releaseTime); if (item.photo) &#123; &#125; else &#123; $(\"ul[class=index]\").append( `&lt;div class=\"card\"&gt; &lt;div class=\"card-header\"&gt;` + item.title + `&lt;/div&gt; &lt;div class=\"card-content card-content-padding\"&gt; &lt;p class=\"date index\"&gt;` + item.theme + `·` + time + `&lt;/p&gt; &lt;a href=\"www.baidu.com\" class=\"link\" style=\"color: black\"&gt;&lt;p style=\"margin-top: 0; margin-bottom: 0;\"&gt;` + getcontent(item.content).substring(0, 70) + ` ...&lt;/p&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"card-footer\"&gt; &lt;a href=\"#\" class=\"link\" style=\"color\"&gt; &lt;i class=\"f7-icons size-18\"&gt;heart_fill&lt;/i&gt;` + 1 + `喜欢&lt;/a&gt; &lt;a href=\"#\" class=\"link\"&gt; ` + 22 + `人批注过，共计` + 44 + `条批注 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;` ); &#125; &#125;); &#125;, error: function (e) &#123;&#125;,&#125;); 多行文字限制字数显示…1234567.text_overflow &#123; /* width:27rem; */ display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;&#125; 单行文字限制字数显示…1234567.text_overflow &#123; width: 27em; white-space: nowrap; text-overflow: ellipsis; -o-text-overflow: ellipsis; overflow: hidden;&#125; 从 html 代码中获取纯文本函数1234function getcontent(text) &#123; var html = text; return html.replace(/&lt;[^&gt;]*&gt;|/g, \"\");&#125; 时间戳转化函数1234567891011121314151617181920212223242526272829303132333435363738// 2014-05-08 00:22:11function getDateDiff(dateTimeStamp) &#123; var dateTimeStamp = new Date(Date.parse(dateTimeStamp.replace(/-/g, \"/\"))); dateTimeStamp = dateTimeStamp.getTime(); var result; var minute = 1000 * 60; var hour = minute * 60; var day = hour * 24; var halfamonth = day * 15; var month = day * 30; var now = new Date().getTime(); var diffValue = now - dateTimeStamp; if (diffValue &lt; 0) &#123; return; &#125; var monthC = diffValue / month; var weekC = diffValue / (7 * day); var dayC = diffValue / day; var hourC = diffValue / hour; var minC = diffValue / minute; if (monthC &gt;= 1) &#123; if (monthC &lt;= 12) result = \"\" + parseInt(monthC) + \"个月前\"; else &#123; result = \"\" + parseInt(monthC / 12) + \"年前\"; &#125; &#125; else if (weekC &gt;= 1) &#123; result = \"\" + parseInt(weekC) + \"周前\"; &#125; else if (dayC &gt;= 1) &#123; result = \"\" + parseInt(dayC) + \"天前\"; &#125; else if (hourC &gt;= 1) &#123; result = \"\" + parseInt(hourC) + \"小时前\"; &#125; else if (minC &gt;= 1) &#123; result = \"\" + parseInt(minC) + \"分钟前\"; &#125; else &#123; result = \"刚刚\"; &#125; return result;&#125; js 变量生命周期 全局变量 12345var n = 999;function f1() &#123; alert(n);&#125;f1(); // 输出999,说明全局变量n在函数内部被读取 函数中的全局变量：在函数内部声明变量没有使用var，实际上是声明了一个全局变量，前提是需要先调用函数 12345678910111213var func1 = function()&#123; a1 = 1; console.log(a1); //输出:1 function func2() &#123;//func2()是一个闭包 a2 = 2; console.log(a2); &#125; func2()；//闭包函数中的变量在调用函数之后，变量也是全局变量 console.log(a2);//输出2&#125;;func1();//调用函数，才会使变量生效console.log(a1);//输出1console.log(a2);//输出2，说明闭包中没有用var声明的变量也是全局变量。 局部变量：在函数内部声明的变量。函数内部的变量，外部无法读取。 1234function f1() &#123; var n = 999;&#125;alert(n); // 没有定义，说明函数内部的变量，外部无法读取。 JavaScript解释器在执行脚本时，是按块来执行的。通俗地说，就是浏览器在解析HTML文档流时，如果遇到一个&lt;script&gt;标签，则JavaScript解释器会等到这个代码块都加载完后，先对代码块进行预编译，然后再执行。执行完毕后，浏览器会继续解析下面的HTML文档流，同时JavaScript解释器也准备好处理下一个代码块。由于JavaScript是按块执行的，所以如果在一个JavaScript块中调用后面块中声明的变量或函数就会提示语法错误。虽然说，JavaScript是按块执行的，但是不同块都属于同一个全局作用域，也就是说，块之间的变量和函数是可以共享的。 jquery 获取 radio 被选中的值 三种方法都可以 123$('input:radio:checked').val()；$(\"input[type='radio']:checked\").val();$(\"input[name='rd']:checked\").val(); jquery 获取 select 被选中的值 获取选中项的value值 123$(\"select#sel option:selected\").val();或者;$(\"select#sel\").find(\"option:selected\").val(); 获取选中项的text值 123$(\"select#seloption:selected\").text();或者;$(\"select#sel\").find(\"option:selected\").text(); 获取当前选中项的索引值 1$(\"select#sel\").get(0).selectedIndex; jquery 获取 checkbox 被选中的值 获取单个checkbox选中项 12345$(\"input:checkbox:checked\").val();或者;$(\"input:[type='checkbox']:checked\").val();或者;$(\"input:[name='ck']:checked\").val(); 获取多个checkbox选中项 123$(\"input[name='favour']:checked\").each(function () &#123; alert($(this).val());&#125;); jquery 获取 span 和 input 的值12$(\"span\").html();$(\"input\").val(); jquery 数组对象获取 value 值 需将数组对象再次封装为jquery对象 12345// 错误$(\"input[name='jQueryArray']\")[0].val();// 正确$($(\"input[name='jQueryArray']\")[0]).val();0; this 必须用\\$包装成 JQuery 对象才能使用用 let 和 const 的声明可以产生块级作用域，解决闭包循环事件绑定1234567for (var i = 0; i &lt; 2; i++) &#123; let ii = i; //const也可以，块级作用域 var bt = document.getElementById(\"bt\" + ii); bt.onclick = function () &#123; console.log(ii); &#125;;&#125; JavaScript 中有 5 种简单数据类型（也称为基本数据类型）： Undefined、Null、Boolean、Number 和 String 。还有 1 种复杂数据类型—— Object ，Object 本质上是由一组无序的名值对组成的。backgroundColor 要加.style 属性设置元素的背景颜色；bgcolor 不用加.stylejson 中 key 也是个字符串，要加引号，key 和 value 之间是用:号来表示的CSS 样式表和选择器 CSS 和 HTML 结合的三种方式：行内样式表、内嵌样式表、外部样式表 CSS 四种基本选择器：标签选择器、类选择器、ID 选择器、通用选择器 CSS 几种扩展选择器：后代选择器、交集选择器、并集选择器、伪类选择器","categories":[],"tags":[]},{"title":"跨域问题","slug":"yuque/跨域问题","date":"2020-04-05T00:56:11.000Z","updated":"2020-05-03T15:25:21.777Z","comments":true,"path":"2020/04/05/yuque/跨域问题/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/跨域问题/","excerpt":"","text":"title: 跨域问题 date: 2019 年 04 月 08 日 00:27:43categories: Browsertypora-root-url: ..typora-copy-images-to: ../images 什么是同源策略通常来说，浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不许读写对方的资源，本域指的是 同协议：比如都是 http 或者 https 同域名：比如都是 http://baidu.com/a 和 http://baidu.com/b 同端口：比如都是 80 端口 同源 http://baidu.com/a/b.js 和 http://baidu.com/index.php 不同源 http://baidu.com/main.js 和 https://baidu.com/a.php 协议不同 http://baidu.com/main.js 和 http://bbs.baidu.com/a.php 域名不同，域名必须完全相同才可以 http://baidu.com/main.js 和 http://baidu.com:8080/a.php 端口不同，第一个默认是 80 对于当前页面来说页面存放 JS 文件的域不重要，重要的是加载该 JS 的页面所在什么域 什么是跨域 在 JavaScript 中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于 JavaScript 代码能够访问的页面内容做了很重要的限制，即 JavaScript 只能访问与包含它的文档在同一域下的内容 JavaScript 的同源策略在进行多 iframe 或多窗口编程、以及 Ajax 编程时显得尤为重要 根据这个策略，在 baidu.com 下的页面中包含的 JavaScript 代码，不能访问在 google.com 域名下的页面内容 不同的子域名之间的页面也不能通过 JavaScript 代码互相访问 对于 Ajax 的影响在于，通过 XMLHttpRequest 实现的 Ajax 请求，不能向不同的域提交请求，例如，在 abc.example.com 下的页面，不能向 def.example.com 提交 Ajax 请求 注意要点 如果是协议和端口造成的跨域问题前台是无能为力的 在跨域问题上，域仅仅是通过URL 的首部来识别而不会去尝试判断相同的 IP 地址对应着两个域或两个域是否在同一个 ip 上。比如http://www.a.com/a.js和http://70.32.92.74/b.js，虽然域名和域名的 ip 对应，不过还是被认为是跨域 URL 的首部指 window.location.protocol +window.location.host，其中 window.location.protocol：含有 URL 第一部分的字符串，如：http: window.location.host：包含有 URL 中主机名 + 端口号 + 部分的字符串，如：//www.cenpok.net/server/ 为什么要实现同源限制 比如一个黑客，他利用 iframe 把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名和密码登录时，如果没有同源限制，他的页面就可以通过 JavaScript 读取到你的表单中输入的内容，这样用户名和密码就轻松到手了 又比如你登录了 OSC，同时浏览了恶意网站，如果没有同源限制，该恶意网站就可以构造 Ajax 请求频繁在 OSC 发广告帖 常用的跨域处理方法JSONP(JSON with padding)原理在页面上有三种资源是可以与页面本身不同源的 js 脚本 css 样式文件 图片 像淘宝等大型网站，肯定会将这些静态资源放入 cdn 中，然后在页面上连接，如下所示，所以它们是可以链接访问到不同源的资源的 &lt;script type=&quot;text/javascript&quot; src=&quot;某某cdn地址&quot; &gt;&lt;/script&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;某个cdn地址&quot; /&gt; &lt;img src=&quot;某个cdn地址&quot; alt=&quot;&quot;/&gt; 而 jsonp 就是利用了script 标签的src 属性是没有跨域的限制的，从而达到跨域访问的目的。因此它的最基本原理就是：动态添加一个&lt;script&gt;标签来实现 实现方法我们使用 Ajax 来请求的，看起来和 Ajax 没啥区别，其实还是有区别的 ajax 的核心是通过 XmlHttpRequest 获取非本页内容，而 jsonp 的核心则是动态添加&lt;script&gt;标签来调用服务器提供的 js 脚本 123456789$.ajax(&#123; url: \"http://crossdomain.com/services.php\", dataType: \"jsonp\", data: \"\", jsonp: \"callback\", success: function (result) &#123; // some code &#125;,&#125;); 上面的代码中，callback 是必须的，callback 是什么值要跟后台拿。获取到的 jsonp 数据格式如下 12345flightHandler(&#123; code: \"CA1998\", price: 1780, tickets: 5,&#125;); jsonp 的全称为 json with padding，上面的数据中，flightHandler 就是那个 padding 优缺点优点 不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持 在请求完毕后可以通过调用 callback 的方式回传结果 缺点 只能使用 get 方法，不能使用 post 方法 script，link, img 等标签引入外部资源，都是 get 请求的，那么就决定了 jsonp 一定是 get 请求 但有时候我们使用的 post 请求也成功，这是因为当我们指定dataType: &#39;jsonp&#39;，不论你指定type: &quot;post&quot;或者type: &quot;get&quot;，其实质上进行的都是 get 请求 没有关于 JSONP 调用的错误处理 如果动态脚本插入有效，就执行调用 如果无效，就静默失败 失败是没有任何提示的 例如，不能从服务器捕捉到 404 错误，也不能取消或重新开始请求 只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题 CORS 策略原理 CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 Ajax 只能同源使用的限制 CORS 系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，但比起简单地允许所有这些的要求来说更加安全 实现方法 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与 对于开发者来说，CORS 通信与同源的 Ajax 通信没有差别，代码完全一样 浏览器一旦发现 A 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉 前端实现 以前我们使用 Ajax，使用如下代码 1234var xhr = new XMLHttpRequest();xhr.open(\"GET\", \"/hfahe\", true);xhr.send();// 这里的“/hfahe”是本域的相对路径。 如果我们要使用 CORS，使用如下代码 1234var xhr = new XMLHttpRequest();xhr.open(\"GET\", \"http://blog.csdn.net/hfahe\", true);xhr.send();// 请注意，代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址 服务器方面 服务器端对于 CORS 的支持，主要就是通过设置 Access-Control-Allow-Origin 来进行的。如果浏览器检测到相应的设置，就可以允许 Ajax 进行跨域的访问 优缺点：优点 CORS 支持所有类型的 HTTP 请求 使用 CORS，开发者可以使用普通的 XMLHttpRequest 发起请求和获得数据，比起 JSONP 有更好的错误处理 缺点 兼容性方面相对差一点，IE10+才支持 document.domain+iframe只有在主域相同的时候才能使用该方法 原理 浏览器中不同域的框架之间是不能进行 js 的交互操作的，但是不同的框架之间（父子或同辈），是能够获取到彼此的 window 对象的，但是，我们也只能获取到一个几乎无用的 window 对象 比如，有一个页面，它的地址是 http://www.example.com/a.html ， 在这个页面里面有一个 iframe，它的 src 是 http://example.com/b.html , 很显然这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的 这个时候，document.domain 就可以派上用场了，我们只要把http://www.example.com/a.html 和 http://example.com/b.html 这两个页面的 document.domain 都设成相同的域名就可以了 但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的 document.domain 可以设成 a.b.example.com、b.example.com 、example.com 中的任意一个，但是不可以设成 c.a.b.example.com，因为这是当前域的子域，也不可以设成 baidu.com， 因为主域已经不相同了 实现方法比如在 http://www.example.com/a.html 的页面里要访问 http://example.com/b.html 里面的东西，则在页面 http://www.example.com/a.html 中设置 document.domain 1234567891011121314151617181920212223// http://www.example.com/a.html&lt;html&gt;&lt;head&gt; &lt;title&gt;A页面&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;A页面&lt;/div&gt; &lt;iframe id=\"iframe\" src=\"http://example.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt; // 相当于用一个隐藏的iframe来做代理 &lt;script&gt; $(function()&#123; try&#123; document.domain = \"example.com\"; // 这里将document.domain设置成一样 &#125;catch(e)&#123;&#125; $(\"#iframe\").load(function()&#123; var iframe = $(\"#iframe\").contentDocument.$; iframe.get(\"http://example.com/接口\", function(data)&#123;&#125;); &#125;); &#125;); &lt;/script&gt;&lt;body&gt;&lt;/html&gt; 在页面 http://example.com/b.html 中也设置 document.domain，而且这也是必须的，虽然这个文档的 domain 就是 example.com，但是还是必须显示的设置 document.domain 的值 1234567891011121314151617// http://example.com/b.html&lt;html&gt; &lt;head&gt; &lt;title&gt;B页面&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;B页面&lt;/div&gt; &lt;script&gt; $(function () &#123; try &#123; document.domain = \"example.com\"; // 这里将document.domain设置成一样 &#125; catch (e) &#123;&#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ⚠️ 注意 在 A 页面中，要等 iframe 标签完成加载 B 页面之后，再取 iframe 对象的 contentDocument，否则如果 B 页面没有被 iframe 完全加载，在 A 页面中通过 contentDocument 属性就取不到 B 页面中的 jQuery 对象 一旦取到 B 页面中的 jQuery 对象，就可以直接发 Ajax 请求了，这种类似“代理”方式可以解决主子域的跨域问题。 优缺点只有在主域相同的时候才能使用该方法 HTML5 postMessage原理 一个 html5 所提供的一个 API，HTML5 window.postMessage 是一个安全的、基于事件的消息 API 在需要发送消息的源窗口调用 postMessage 方法即可发送消息 源窗口可以是全局的 window 对象，也可以是以下类型的窗口 文档窗口中的 iframe: 12var iframe = document.getElementById(\"my-iframe\");var win = iframe.documentWindow; JavaScript 打开的弹窗： 1var win = window.open(); 当前文档窗口的父窗口： 1var win = window.parent; window.opener() 1var win = window.opener(); 发送消息 找到源 window 对象后，即可调用 postMessage API 向目标窗口发送消息 1win.postMessage(msg, targetOrigin); 说明 postMessage 函数接收 2 个参数 msg：将要发送的消息，可以是一切 JavaScript 参数，如字符串，数字，对象，数组等 targetOrigin：这个参数称作“目标域”，⚠️ 注意，是目标域不是本域！比如，你想在 2.com 的网页上往 1.com 网页上传消息，那么这个参数就是 http://1.com/ ，而不是 2.com 协议 一个完整的域名包括：主机名，端口号，如：http://g.cn:80/ 接收消息 只要监听 window 的 message 事件就可以接收了 1234567891011var onmessage = function (event) &#123; var data = event.data; var origin = event.origin; //do someing&#125;;if (typeof window.addEventListener != \"undefined\") &#123; window.addEventListener(\"message\", onmessage, false);&#125; else if (typeof window.attachEvent != \"undefined\") &#123; //for ie window.attachEvent(\"onmessage\", onmessage);&#125; message 事件监听函数接收一个参数，Event 对象实例，该对象有 3 个属性 data：消息 origin：消息的来源地址 source：发送消息窗口的 window 对象引用 实现方法http://test.com/index.html 发送消息的页面 123456789&lt;div&gt; &lt;!-- 要给下面的页面传一个妹子过去 --&gt; &lt;iframe id=\"child\" src=\"http://lsLib.com/lsLib.html\"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function () &#123; window.frames[0].postMessage(\"苍老师\", \"http://lslib.com\"); &#125;;&lt;/script&gt; http://lslib.com/lslib.html 接收消息的页面 123456&lt;script type=\"text/javascript\"&gt; window.addEventListener(\"message\", function (e) &#123; console.log(e.origin, e.data); alert(\"收到妹子一枚：\" + e.data); &#125;);&lt;/script&gt; 优缺点优点 方便，安全，有效的解决了跨域问题 是 html5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源 目前 IE8+、FireFox、Chrome、Opera 等浏览器都已经支持 window.postMessage 方法。如果是现代浏览器，首选 缺点 IE8+才支持，而且 IE8+&lt;IE10 只支持 iframe 的方式 window.name 属性相对比较完美的方法 原理 当 iframe 的页面跳到其他地址时，其 window.name 值保持不变，并且可以支持非常长的 name 值（2MB） 浏览器跨域 iframe 禁止互相调用/传值，但是调用 iframe 时 window.name 却不变，正是利用这个特性来互相传值，当然跨域下是不容许读取 ifram 的 window.name 值 实现方法 准备三个页面 http://www.a.com/main.html 应用页面 http://www.a.com/other.html 代理页面，要求和应用页面在同一个域，一般是一个空的 html http://www.b.com/data.html 应用页面获取数据的页面，简称：数据页面 数据页面将数据传到 window.name 中去 http://www.b.com/data.html 中的 data.html 12// 可以是其他类型的数据，比如数组，对象等等window.name = \"苍老师\"; http://www.a.com/main.html 应用页面 获取数据以后销毁这个 iframe，释放内存；这也保证了安全（不被其他域 frame js 访问）。 123iframe.contentWindow.document.write(\"\");iframe.contentWindow.close();document.body.removeChild(iframe); 优缺点优点 主要是应用当 iframe 的页面跳到其他地址时，其 window.name 值保持不变的原理 兼容性好，需要照顾落后的浏览器时，首选 参考资料 [1]http://www.cnblogs.com/xianyulaodi/p/5755108.html","categories":[],"tags":[]},{"title":"关于事件委托的尝试","slug":"yuque/关于事件委托的尝试","date":"2020-04-05T00:56:06.000Z","updated":"2020-05-03T15:25:21.787Z","comments":true,"path":"2020/04/05/yuque/关于事件委托的尝试/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/关于事件委托的尝试/","excerpt":"","text":"1 常写代码12345ul.addEventListener(\"click\", function (e) &#123; if (e.target.tagName.toLowerCase() === \"li\") &#123; fn(); // 执行某个函数 &#125;&#125;); 之前一直用的很好，但是在某次 li 中有 span 的时候发现了 bug，如果用户点击的是 li 里面的 span，就没法触发 fn，这显然不对。 2 代码改良思路是点击 span 后，递归遍历 span 的祖先元素看其中有没有 ul 里面的 li。 1234567891011121314function delegate(element, eventType, selector, fn) &#123; element.addEventListener(eventType, (e) =&gt; &#123; let el = e.target; while (!el.matches(selector)) &#123; if (element === el) &#123; el = null; break; &#125; el = el.parentNode; &#125; el &amp;&amp; fn.call(el, e, el); &#125;); return element;&#125;","categories":[],"tags":[]},{"title":"尝试实现一个简单的Promise","slug":"yuque/尝试实现一个简单的Promise","date":"2020-04-05T00:56:01.000Z","updated":"2020-05-03T15:25:21.823Z","comments":true,"path":"2020/04/05/yuque/尝试实现一个简单的Promise/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/尝试实现一个简单的Promise/","excerpt":"","text":"1 Promise 是一个异步操作返回的对象，用来传递异步操作的消息2 根据自己对 Promise 的理解，实现一个 PromisePromise 有三种状态：Pending 初始态； Fulfilled 成功态； Rejected 失败态。 123456789101112131415161718192021222324252627282930313233343536373839function Promise(executor) &#123; let self = this; self.status = \"pending\"; //等待态 self.value = undefined; //成功的返回值 self.reason = undefined; //失败的原因 function resolve(value) &#123; if (self.status === \"pending\") &#123; self.status = \"resolved\"; self.value = value; &#125; &#125; function reject(reason) &#123; if (self.status === \"pending\") &#123; self.status = \"rejected\"; self.reason = reason; &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); // 捕获时发生异常，就直接失败 &#125;&#125;//onFufiled 成功的回调//onRejected 失败的回调Promise.prototype.then = function (onFufiled, onRejected) &#123; let self = this; if (self.status === \"resolved\") &#123; onFufiled(self.value); &#125; if (self.status === \"rejected\") &#123; onRejected(self.reason); &#125;&#125;;module.exports = Promise; 3 代码测试1234567891011121314let Promise = require(\"./Promise\");let promise = new Promise(function (resolve, reject) &#123; resolve(100);&#125;);promise.then( function (data) &#123; console.log(\"data:\", data); &#125;, function (err) &#123; console.log(\"err:\", err); &#125;); 输出：data: 100 Promise 实例可以多次 then，当成功后会将 then 中的成功方法按顺序执行，我们可以先将 then 中成功的回调和失败的回调存到数组内。当成功的时候调用成功的数组即可。 1234567891011121314151617181920self.onResolvedCallbacks = []; /* 存放then成功的回调*/self.onRejectedCallbacks = []; /* 存放then失败的回调*/function resolve(value) &#123; if (self.status === \"pending\") &#123; self.status = \"resolved\"; self.value = value; self.onResolvedCallbacks.forEach(function (fn) &#123; fn(); &#125;); &#125;&#125;function reject(reason) &#123; if (self.status === \"pending\") &#123; self.status = \"rejected\"; self.reason = reason; self.onRejectedCallbacks.forEach(function (fn) &#123; fn(); &#125;); &#125;&#125; 12345678if (self.status === \"pending\") &#123; self.onResolvedCallbacks.push(function () &#123; onFufiled(self.value); &#125;); self.onRejectedCallbacks.push(function () &#123; onRejected(self.reason); &#125;);&#125; 4 实现链式调用众所周知 Promise 的一大特点，就是链式调用。而 Promise 实现链式调用就是通过 then 方法返回一个新的 Promise。 如果第一个 then 中返回了一个结果，会将 Promise 的结果继续传给下一个 then 中；如果有错误则走下一个 then 的失败。 12345678910111213141516171819202122232425262728// 添加 resolvePromise 方法 处理链式调用问题function resolvePromise(p2, x, resolve, reject) &#123; if (p2 === x) &#123; return reject(new TypeError(\"循环引用\")); &#125; if (x !== null || typeof x === \"object\" || typeof x === \"function\") &#123; try &#123; let then = x.then; if (typeof then === \"function\") &#123; then.call( x, function (y) &#123; resolvePromise(promise2, y, resolve, reject); &#125;, function (err) &#123; reject(err); &#125; ); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;","categories":[],"tags":[]},{"title":"【Safety】简介","slug":"yuque/【Safety】简介","date":"2020-04-05T00:55:56.000Z","updated":"2020-05-03T15:25:21.941Z","comments":true,"path":"2020/04/05/yuque/【Safety】简介/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【Safety】简介/","excerpt":"","text":"title: 【Safety】简介date: 2019年04月08日 00:27:43categories: Safetytypora-root-url: ..typora-copy-images-to: ../images XSS 涉及面试题：什么是 XSS 攻击？如何防范 XSS 攻击？什么是 CSP？ XSS 是什么 XSS 简单点来说，就是攻击者想尽一切办法将可执行的代码注入到网页中 XSS 分类边界 XSS 可以分为多种类型，但是总体上认为分为两类 持久型 非持久型 持久型 XSS 是什么 持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。 EX1 对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容 这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。 EX2 在新浪博客写一篇文章，同时偷偷插入一段&lt;script&gt; 攻击代码中，获取 cookie，发送到自己的服务器 发布博客，有人查看博客内容 会把查看者的 cookie 发送到攻击者的服务器 非持久型 XSS 是什么 非持久型相比于前者危害就小的多了，一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。 举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行 12&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 非持久型 XSS 条件 但是对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。 XSS 组合 对于 XSS 攻击来说，通常有两种方式可以用来防御。 转义字符转义字符是什么 首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;') str = str.replace(/&lt;/g, '&lt;') str = str.replace(/&gt;/g, '&gt;') str = str.replace(/\"/g, '&amp;quto;') str = str.replace(/'/g, ''') str = str.replace(/`/g, '`') str = str.replace(/\\//g, '/') return str&#125; 通过转义可以将攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 变成 12// -&gt; &lt;script&gt;alert(1)&lt;/script&gt;escape(\"&lt;script&gt;alert(1)&lt;/script&gt;\"); 转义字符条件 但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 1234const xss = require(\"xss\");let html = xss('&lt;h1 id=\"title\"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(\"xss\");&lt;/script&gt;');// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(\"xss\");&lt;/script&gt;console.log(html); 以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。 CSPCSP 是什么 CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。 CSP 组合 通常可以通过两种方式来开启 CSP： 开启 CSP 分类边界 设置 HTTP Header 中的 Content-Security-Policy 设置 meta 标签的方式 &lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; HTTP Header 分类边界 这里以设置 HTTP Header 来举例 只允许加载本站资源 1Content-Security-Policy: default-src ‘self’ 只允许加载 HTTPS 协议图片 1Content-Security-Policy: img-src https://* 允许加载任何来源框架 1Content-Security-Policy: child-src &apos;none&apos; 当然可以设置的属性远不止这些，你可以通过查阅 文档 的方式来学习，这里就不过多赘述其他的属性了。 Tips 对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。 CSRF 涉及面试题：什么是 CSRF 攻击？如何防范 CSRF 攻击？ CSRF 是什么 CSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。 EX1 假设网站中有一个通过 GET 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 1&lt;img src=\"http://www.domain.com/xxx?comment='attack'\" /&gt; 那么你是否会想到使用 POST 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 POST 请求。 EX2 你已登录一个购物网站，正在浏览器商品 该网站付费接口是 xxx.com/pay?id=100 ，但是没有任何验证 然后你收到一封邮件，隐藏着&lt;img src=xxx&gt; 你查看邮件的时候，就已经悄悄的付费购买了 CSRF 组合 如何防御防范 CSRF 攻击可以遵循以下几种规则： Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 Token SameSite可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。 验证 Referer对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。 Token服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。 点击劫持 涉及面试题：什么是点击劫持？如何防范点击劫持？ 是什么 点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 对于这种攻击方式，推荐防御的方法有两种。 X-FRAME-OPTIONSX-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头就是为了防御用 iframe 嵌套的点击劫持攻击。 该响应头有三个值可选，分别是 DENY，表示页面不允许通过 iframe 的方式展示 SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示 ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示 JS 防御对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。 1234567891011121314151617&lt;head&gt; &lt;style id=\"click-jack\"&gt; html &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; if (self == top) &#123; var style = document.getElementById(\"click-jack\"); document.body.removeChild(style); &#125; else &#123; top.location = self.location; &#125; &lt;/script&gt;&lt;/body&gt; 以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。 中间人攻击 涉及面试题：什么是中间人攻击？如何防范中间人攻击？ 中间人攻击是什么 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。 通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。 中间人攻击条件 当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。 小结 在这一章中，我们学习到了一些常见的前端安全方面的知识及如何防御这些攻击。但是安全的领域相当大，这些内容只是沧海一粟，如果大家对于安全有兴趣的话，可以阅读 这个仓库的内容 来学习和实践这方面的知识。","categories":[],"tags":[]}]}