{"meta":{"title":"冯天祥","subtitle":"前端小白的技术博客","description":"前端小白冯天祥的技术博客","author":"冯天祥","url":"http://fengtx.tk","root":"/"},"pages":[{"title":"","date":"2020-05-03T15:21:18.500Z","updated":"2019-03-31T02:53:35.000Z","comments":false,"path":"categories/index.html","permalink":"http://fengtx.tk/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-05-03T15:21:18.498Z","updated":"2019-03-31T02:53:44.000Z","comments":false,"path":"tags/index.html","permalink":"http://fengtx.tk/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"React学习小记","slug":"yuque/React学习小记","date":"2020-05-03T14:08:48.000Z","updated":"2020-06-07T13:19:50.291Z","comments":true,"path":"2020/05/03/yuque/React学习小记/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/React学习小记/","excerpt":"","text":"React 文档入门 React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库 使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件” 创建 React 项目，npx create-react-app my-app ShoppingList 是一个 React 组件类，或者说是一个 React 组件类型 一个组件接收一些参数，我们把这些参数叫做 props 然后通过 render 方法返回需要展示在屏幕上的视图的层次结构，render 方法的返回值描述了你希望在屏幕上看到的内容 在 JSX 中你可以任意使用 JavaScript 表达式，只需要用一个大括号把表达式括起来 在 React 中，有一个命名规范，通常会将代表事件的监听 prop 命名为 on[Event]，将处理事件的监听方法命名为 handle[Event] 这样的格式。 创建新的 React 应用123456npx create-react-app my-appcd my-appyarn start// 构建yarn build JSX 简介 在 React 中配合使用 JSX，JSX 可以很好地描述 UI 应该呈现出它应有交互的本质形式 JSX 里的 class 变成了 className，而 tabindex 则变为 tabIndex 在 JSX 语法中，你可以在大括号内放置任何有效的 JavaScript 表达式 建议将内容包裹在括号中，这样可以避免遇到自动插入分号陷阱 Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用 元素渲染与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象，React DOM 会负责更新 DOM 来与 React 元素保持一致 将一个元素渲染为 DOM想要将一个 React 元素渲染到根 DOM 节点中，只需把它们一起传入 ReactDOM.render() 12const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;ReactDOM.render(element, document.getElementById(&apos;root&apos;)); 更新已渲染的元素 React 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性 一个元素就像电影的单帧：它代表了某个特定时刻的 UI。 更新 UI 唯一的方式是创建一个全新的元素，并将其传入 ReactDOM.render() React 只更新它需要更新的部分React DOM 会将元素和它的子元素与它们之前的状态进行比较，并只会进行必要的更新来使 DOM 达到预期的状态 组件 &amp; Props函数组件与 class 组件 组件允许你将 UI 拆分为独立可复用的代码片段，并对每个片段进行独立构思 组件，从概念上类似于 JavaScript 函数。它接受任意的入参（即 “props”），并返回用于描述页面展示内容的 React 元素 函数组件 12345function Welcome(props) &#123; return ( &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;; )&#125; class 组件 1234567class Welcome extends React.Component &#123; render() &#123; return ( &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; ) &#125;&#125; 上述两个组件在 React 里是等效的 渲染组件123456789function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;ReactDOM.render( element, document.getElementById(&apos;root&apos;)); React 元素也可以是用户自定义的组件 组件名称必须以大写字母开头 Props 的只读性所有 React 组件都必须像纯函数一样保护它们的 props 不被更改 State &amp; 生命周期StateState 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。 将函数组件转换成 class 组件 创建一个同名的 ES6 class，并且继承于 React.Component。 添加一个空的 render() 方法。 将函数体移动到 render() 方法之中。 在 render() 方法中使用 this.props 替换 props。 删除剩余的空函数声明。 向 class 组件中添加局部的 state 把 render() 方法中的 this.props.date 替换成 this.state.date 添加一个 class 构造函数，然后在该函数中为 this.state 赋初值，Class 组件应该始终使用 props 参数来调用父类的构造函数 移除 &lt;Clock /&gt; 元素中的 date 属性 将生命周期方法添加到 Class 中 当 Clock 组件第一次被渲染到 DOM 中的时候，就为其设置一个计时器。这在 React 中被称为“挂载（mount）” 当 DOM 中 Clock 组件被删除的时候，应该清除计时器。这在 React 中被称为“卸载（umount）”。 1234567891011121314151617181920212223242526272829303132333435363738394041import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; date: new Date() &#125;; &#125; componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ) &#125; componentWillMount() &#123; clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById(&apos;root&apos;)); 当 &lt;Clock /&gt; 被传给 ReactDOM.render()的时候，React 会调用 Clock 组件的构造函数。 因为 Clock 需要显示当前的时间，所以它会用一个包含当前时间的对象来初始化 this.state。我们会在之后更新 state。 之后 React 会调用组件的 render() 方法。这就是 React 确定该在页面上展示什么的方式。然后 React 更新 DOM 来匹配 Clock 渲染的输出。 当 Clock 的输出被插入到 DOM 中后， React 就会调用 ComponentDidMount() 生命周期方法。在这个方法中，Clock 组件向浏览器请求设置一个计时器来每秒调用一次组件的 tick()方法。 浏览器每秒都会调用一次 tick() 方法。 在这方法之中，Clock 组件会通过调用 setState() 来计划进行一次 UI 更新。得益于 setState() 的调用，React 能够知道 state 已经改变了，然后会重新调用 render() 方法来确定页面上该显示什么。这一次，render() 方法中的 this.state.date 就不一样了，如此以来就会渲染输出更新过的时间。React 也会相应的更新 DOM。 一旦 Clock 组件从 DOM 中被移除，React 就会调用 componentWillUnmount() 生命周期方法，这样计时器就停止了。 正确地使用 State 不要直接修改 State，构造函数是唯一可以给this.state赋值的地方 12345// Wrongthis.state.comment = &apos;Hello&apos;;// Correctthis.setState(&#123;comment: &apos;Hello&apos;&#125;); State 的更新可能是异步的，因为 this.props 和 this.state 可能会异步更新，所以你不要依赖他们的值来更新下一个状态 State 的更新会被合并，可以分别调用 setState() 来单独地更新它们 数据是向下流动的如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。 事件处理 React 事件的命名采用小驼峰式（camelCase），而不是纯小写 使用 JSX 语法时你需要传入一个函数作为事件处理函数，而不是一个字符串 在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。你必须显式的使用 preventDefault 为了在回调中使用 this，在 constructor 中 这个绑定是必不可少的 this.handleClick = this.handleClick.bind(this); 1234567// 无参数&lt;button onClick=&#123;activateLasers&#125;&gt; Activate Lasers&lt;/button&gt;// 有参数&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; 条件渲染 可以使用变量来储存元素。 它可以帮助你有条件地渲染组件的一部分，而其他的渲染部分并不会因此而改变 在 JSX 中调用变量使用{XXX} 使用 JavaScript 运算符if或者条件运算符去创建元素来表现当前的状态，然后让 React 根据它们来更新 UI class 组件 if、let、const 等只能写在 Render() {…}中 组织组件渲染 return null; 列表 &amp; Key123456789const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; &lt;li&gt;&#123;number&#125;&lt;/li&gt;);ReactDOM.render( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt;, document.getElementById(&apos;root&apos;)); 1234567891011121314151617function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt; ); return ( &lt;ul&gt;&#123;listItems&#125;&lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); key key 帮助 React 识别哪些元素改变了，比如被添加或删除。因此你应当给数组中的每一个元素赋予一个确定的标识 1234567const numbers = [1, 2, 3, 4, 5];const listItems = numbers.map((number) =&gt; // 一定要toString() &lt;li key=&#123;number.toString()&#125;&gt; &#123;number&#125; &lt;/li&gt;); 一个元素的 key 最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据 id 来作为元素的 key 12345const todoItems = todos.map((todo) =&gt; &lt;li key=&#123;todo.id&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); 当元素没有确定 id 的时候，万不得已你可以使用元素索引 index 作为 key 123456const todoItems = todos.map((todo, index) =&gt; // Only do this if items have no stable IDs &lt;li key=&#123;index&#125;&gt; &#123;todo.text&#125; &lt;/li&gt;); 记忆：在 map() 方法中的元素需要设置 key 属性。 1234567891011121314151617181920212223function ListItem(props) &#123; // 正确！这里不需要指定 key： return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;;&#125;function NumberList(props) &#123; const numbers = props.numbers; const listItems = numbers.map((number) =&gt; // 正确！key 应该在数组的上下文中被指定 &lt;ListItem key=&#123;number.toString()&#125; value=&#123;number&#125; /&gt; ); return ( &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; );&#125;const numbers = [1, 2, 3, 4, 5];ReactDOM.render( &lt;NumberList numbers=&#123;numbers&#125; /&gt;, document.getElementById(&apos;root&apos;)); key 只是在兄弟节点之间必须唯一，当我们生成两个不同的数组时，我们可以使用相同的 key 值 key 会传递信息给 React ，但不会传递给你的组件，所以 组件可以读出 props.id，但是不能读出 props.key JSX 允许在大括号中嵌入任何表达式 如果一个 map() 嵌套了太多层级，那可能就是你提取组件的一个好时机 表单input/textarea 在 React 中，&lt;textarea&gt; 使用 value 属性代替文本内容，这样使用 &lt;textarea&gt; 的表单和使用单行 input 的表单非常类似 12345678910111213141516171819202122232425262728293031class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;value: &apos;&apos;&#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125; handleSubmit(event) &#123; alert(&apos;提交的名字: &apos; + this.state.value); // 注意！！！ event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;label&gt; 名字: &lt;input type=&quot;text&quot; value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; ); &#125;&#125; select React 并不会使用 selected 属性，而是在根 select 标签上使用 value 属性。这在受控组件中更便捷，因为您只需要在根标签中更新它 &lt;input type=&quot;text&quot;&gt;, &lt;textarea&gt; 和 &lt;select&gt; 之类的标签都非常相似—它们都接受一个 value 属性 可以将数组传递到 value 属性中，以支持在 select 标签中选择多个选项 1&lt;select multiple=&#123;true&#125; value=&#123;[&apos;B&apos;, &apos;C&apos;]&#125;&gt; 文件 input 标签因为它的 value 只读，所以它是 React 中的一个非受控组件 1&lt;input type=&quot;file&quot; /&gt; 处理多个输入当需要处理多个 input 元素时，我们可以给每个元素添加 name 属性，并让处理函数根据 event.target.name 的值选择要执行的操作 状态提升在 React 中，将多个组件中需要共享的 state 向上移动到它们的最近共同父组件中，便可实现共享 state。这就是所谓的“状态提升” 组合 vs 继承包含关系&lt;FancyBorder&gt; JSX 标签中的所有内容都会作为一个 children prop 传递给 FancyBorder组件。因为 FancyBorder 将 {props.children} 渲染在一个 &lt;div&gt; 中 123456789101112131415161718192021222324function SplitPane(props) &#123; return ( &lt;div className=&quot;SplitPane&quot;&gt; &lt;div className=&quot;SplitPane-left&quot;&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className=&quot;SplitPane-right&quot;&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; );&#125;function App() &#123; return ( &lt;SplitPane left=&#123; &lt;Contacts /&gt; &#125; right=&#123; &lt;Chat /&gt; &#125; /&gt; );&#125; Ant Design style 使用双花括号 1style=&#123;&#123; width: &apos;64px&apos;, height: &apos;64px&apos;, borderRadius: &apos;32px&apos; &#125;&#125; 对于这种不能直接控制状态的组件，我们称之为“非受控组件” exports.routes 需要是一个数组，数组中的每一个对象是一个路由信息 path 表示页面访问路径，component 表示 page 下的文件名，比如 App, User 分别表示 page/App，page/User 我们用 Link 组件（相当于) 实现路由的跳转 React 小书前端组件化（二）：优化 DOM 操作 一旦状态发生改变，就重新调用 render 方法，构建一个新的 DOM 元素 新增一个 setState 函数，这个函数接受一个对象作为参数；它会设置实例的 state，然后重新调用一下 render 方法 用户每次点击，changeLikeText 都会调用改变组件状态然后调用 setState ；setState 会调用 render ，render 方法会根据 state 的不同重新构建不同的 DOM 元素 一个组件有自己的显示形态（上面的 HTML 结构和内容）行为，组件的显示形态和行为可以由数据状态（state）和配置参数（props）共同决定。数据状态和配置参数的改变都会影响到这个组件的显示形态 React.js 基本环境安装 使用 React.js 不管在开发阶段生产阶段都需要一堆工具和库辅助，编译阶段你需要借助 Babel；需要 Redux 等第三方的状态管理工具来组织代码；如果你要写单页面应用那么你需要 React-router。这就是所谓的“React.js 全家桶” 使用 JSX 描述 UI 信息 ReactDOM 可以帮助我们把 React 组件渲染到页面上去，没有其它的作用了 React.js 就把 JavaScript 的语法扩展了一下，让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法，这样写起来就方便很多了。编译的过程会把类似 HTML 的 JSX 结构转换成 JavaScript 的对象结构 所谓的 JSX 其实就是 JavaScript 对象 image.png 有些同学可能会问，为什么不直接从 JSX 直接渲染构造 DOM 结构，而是要经过中间这么一层呢？ 第一个原因是，当我们拿到一个表示 UI 的结构和信息的对象以后，不一定会把元素渲染到浏览器的普通页面上，我们有可能把这个结构渲染到 canvas 上，或者是手机 App 上。所以这也是为什么会要把 react-dom 单独抽离出来的原因，可以想象有一个叫 react-canvas 可以帮我们把 UI 渲染到 canvas 上，或者是有一个叫 react-app 可以帮我们把它转换成原生的 App（实际上这玩意叫 ReactNative）。 第二个原因是，有了这样一个对象。当数据变化，需要更新组件的时候，就可以用比较快的算法操作这个 JavaScript 对象，而不用直接操作页面上的 DOM，这样可以尽量少的减少浏览器重排，极大地优化性能 组件的 render 方法我们在编写 React.js 组件的时候，一般都需要继承 React.js 的 Component（还有别的编写组件的方式我们后续会提到）。一个组件类必须要实现一个 render 方法，这个 render 方法必须要返回一个 JSX 元素。但这里要注意的是，必须要用一个外层的 JSX 元素把所有内容包裹起来。返回并列多个 JSX 元素是不合法的 React 单车视频1-1 导学前端部分分为三层架构： image.png 前端核心框架库 中间件和插件 公共机制 2-1 React 基本介绍 声明式编码 组件化编码 高效的 DOM diff 算法，最小化页面重绘 单向数据流 Vue 生态：Vue + Vue-Router + Vuex + Axios + Babel + Webpack React 生态：React + React-Router + Redux + Axios + Babel + Webpack 2-2 React 脚手架、Yarn 介绍脚手架：辅助工具，提高开发项目，用来初始化配置，构建基础的模型 yarn 和 npm 一样都是包管理工具，但是 yarn 是新一代包管理工具，修复了 npm 的一些问题，是 facebook 出的 速度快 安装版本统一、更安全 yarn.lock 锁定版本 更简洁的输出 更好的语义化 如何使用 yarn yarn intit yarn add yarn remove yarn/yarn install 安装项目所有的依赖包 初始化一个 react 项目 123npx create-react-app my-appyarnyarn start 2-3 React 生命周期React 的声明周期包括 getDefaultProps getlnitialState componentWillMount：初始化接口 render ComponentDidMount：组件更新后的处理 componentWillReceiveProps shouldComponentUpdate componentWillUpdate componentDidUpdate componentWillUnmount image.png 每个页面实际上就是一个组件 React 必须只有一个根元素 项目中所有的变量，render 中所有的变量都通过 state 来调用，里面的值也都通过 state 去取值 变量是{} style 是双花括号，里面的{}指的是一个对象 组件名字开头大写 state 是组件内部数据传递，props 是组件间数据传递 render 必须 return return 必须只有一个根元素，不能同时有两个 div 使用 bind 直接声明函数，不使用 bind 用箭头函数 3-1 基础插件安装，Less 文件加载配置 安装 React-Router、Axios 安装 AntD 1yarn add react-router-dom axios less-loader 暴露 webpack 配置文件，为了可以修改支持 less，https://juejin.im/post/5c3d67066fb9a049f06a8323 1yarn eject 安装 less-loader 修改 less-loader 安装 node-sass babel 可以实现按需加载 3-3 项目主页结构开发 页面结构定义 目录结构定义 栅格系统使用 calc 计算方法使用 components 是用来放公共组件的 3-3 菜单组件开发 获取到一个对象后要通过 setState 方法将变量保存进去 一旦调用 setState 之后就会调用 Render Update 强制更新的时候也会去调用 Render 3-4 头部组件开发 import 当前目录一定要写./ 创建 utils -&gt; utils.js 来暴露一些公共机制（公共的函数或方法）- 3-5 底部组件开发","categories":[],"tags":[]},{"title":"Sass的使用","slug":"yuque/Sass的使用","date":"2020-05-03T14:06:25.000Z","updated":"2020-06-07T13:19:50.429Z","comments":true,"path":"2020/05/03/yuque/Sass的使用/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Sass的使用/","excerpt":"","text":"文件后缀名12345678910111213141516//文件后缀名为sass的语法body background: #eee font-size:12pxp background: #0982c1 //文件后缀名为scss的语法body &#123; background: #eee; font-size: 12px;&#125;p &#123; background: #0982c1;&#125; 导入css 文件：@import ‘reset.css’跟普通 CSS 导入样式文件一样，导入的 css 文件不会合并到编译后的文件中，而是以@import 方式存在 sass 文件：@import ‘reset’被导入 sass 文件 a.scss 1234//a.scssbody &#123; background: #eee;&#125; 需要导入样式的 sass 文件 b.scss 12345@import \"reset.css\";@import \"a\";p &#123; background: #0982c1;&#125; 转译出来的 b.css 样式 12345678@import \"reset.css\";body &#123; background: #eee;&#125;p &#123; background: #0982c1;&#125; 变量 sass 的变量必须是\\$开头，后面紧跟变量名 变量值和变量名之间就需要使用冒号(:)分隔开 值后面加上!default 则表示默认值 普通变量：定义之后可以在全局范围内使用12345678910//sass style$fontSize: 12px;body &#123; font-size: $fontSize;&#125;//css stylebody &#123; font-size: 12px;&#125; 默认变量 sass 的默认变量仅需要在值后面加上 !default 123456789//sass style$baseLineHeight: 1.5 !default;body &#123; line-height: $baseLineHeight;&#125;//css stylebody &#123; line-height: 1.5;&#125; sass 的默认变量一般是用来设置默认值，然后根据需求来覆盖的，只需要在默认变量之前重新声明下变量即可 12345678910//sass style$baseLineHeight: 2;$baseLineHeight: 1.5 !default;body &#123; line-height: $baseLineHeight;&#125;//css stylebody &#123; line-height: 2;&#125; 特殊变量一般我们定义的变量都为属性值，可直接使用，但是如果变量作为属性或在某些特殊情况下，如运算、拼接等则必须要以 #{\\$variables}形式使用 12345678910111213141516171819//sass style$borderDirection: top !default;$baseFontSize: 12px !default;$baseLineHeight: 1.5 !default;//应用于class和属性.border-#&#123;$borderDirection&#125; &#123; border-#&#123;$borderDirection&#125;: 1px solid #ccc;&#125;//应用于复杂的属性值body &#123; font: #&#123;$baseFontSize&#125;/#&#123;$baseLineHeight&#125;;&#125;//css style.border-top &#123; border-top: 1px solid #ccc;&#125;body &#123; font: 12px/1.5;&#125; 全局变量在选择器中声明的变量会覆盖外面全局声明的变量 嵌套选择器嵌套可以使用 &amp;表示父元素选择器 1234567891011121314151617181920212223242526272829303132333435//sass style#top_nav &#123; line-height: 40px; text-transform: capitalize; background-color: #333; li &#123; float: left; &#125; a &#123; display: block; padding: 0 10px; color: #fff; &amp;:hover &#123; color: #ddd; &#125; &#125;&#125;//css style#top_nav &#123; line-height: 40px; text-transform: capitalize; background-color: #333;&#125;#top_nav li &#123; float: left;&#125;#top_nav a &#123; display: block; padding: 0 10px; color: #fff;&#125;#top_nav a:hover &#123; color: #ddd;&#125; 混合sass 中使用 @mixin 声明混合，可以传递参数，参数名以\\$符号开始，多个参数以逗号分开，也可以给参数设置默认值。声明的 @mixin 通过 @include 来调用。 (1) 无参数 mixin//sass style//——————————-@mixin center-block {margin-left:auto;margin-right:auto;}.demo{@include center-block;} //css style//——————————-.demo{margin-left:auto;margin-right:auto;} (2) 有参数 mixin(3) 多个参数 mixin(4) 多组值参数 mixin(5) @content 7 继承(1) 继承 @extend //sass style//——————————-h1{border: 4px solid #ff9aa9;}.speaker{@extend h1;border-width: 2px;} //css style//——————————-h1,.speaker{border: 4px solid #ff9aa9;}.speaker{border-width: 2px;} (2) 占位选择器 %定义了两个占位选择器 %ir 和 %clearfix，其中 %clearfix 这个没有调用，所以解析出来的 css 样式也就没有 clearfix 部分。占位选择器的出现，使 css 文件更加简练可控，没有多余。所以可以用其定义一些基础的样式文件，然后根据需要调用产生相应的 css //sass style//——————————-%ir{color: transparent;text-shadow: none;background-color: transparent;border: 0;}%clearfix{@if \\$lte7 {*zoom: 1;}&amp;:before,&amp;:after {content: “”;display: table;font: 0/0 a;}&amp;:after {clear: both;}} #header{h1{@extend %ir;width:300px;}}.ir{@extend %ir;} //css style//——————————- #header h1,.ir{color: transparent;text-shadow: none;background-color: transparent;border: 0;} #header h1{width:300px;} 8 函数实际项目中我们使用最多的应该是颜色函数，而颜色函数中又以 lighten 减淡和 darken 加深为最，其调用方法为 lighten($color,$amount)和 darken($color,$amount)，它们的第一个参数都是颜色值，第二个参数都是百分比 //sass style//——————————-$baseFontSize: 10px !default;$gray: #ccc !defualt; // pixels to rems@function pxToRem($px) {@return $px / \\$baseFontSize * 1rem;} body{font-size:$baseFontSize;color:lighten($gray,10%);}.test{font-size:pxToRem(16px);color:darken(\\$gray,10%);} //css style//——————————-body{font-size:10px;color:#E6E6E6;}.test{font-size:1.6rem;color:#B3B3B3;} 9 运算sass 具有运算的特性，可以对数值型的 Value(如：数字、颜色、变量等)进行加减乘除四则运算。请注意运算符前后请留一个空格，不然会出错 $baseFontSize: 14px !default;$baseLineHeight: 1.5 !default;$baseGap: $baseFontSize * $baseLineHeight !default;$halfBaseGap: $baseGap / 2 !default;$samllFontSize: \\$baseFontSize - 2px !default; //grid$_columns: 12 !default; // Total number of columns$_column-width: 60px !default; // Width of a single column\\$_gutter: 20px !default; // Width of the gutter $_gridsystem-width: $_columns * ($_column-width + $_gutter); //grid system width 10 条件判断及循环(1) @if 判断@if 可一个条件单独使用，也可以和 @else 结合多条件使用 //sass style//——————————-$lte7: true;$type: monster;.ib{display:inline-block;@if $lte7 {display:inline; zoom:1;}}p {@if $type == ocean {color: blue;} @else if $type == matador {color: red;} @else if $type == monster {color: green;} @else {color: black;}} //css style//——————————-.ib{display:inline-block;display:inline; zoom:1;}p {color: green;} (2) 三目判断语法为： if($condition, $if_true, \\$if_false) 。三个参数分别表示：条件，条件为真的值，条件为假的值 if(true, 1px, 2px) =&gt; 1pxif(false, 1px, 2px) =&gt; 2px (3) for 循环for 循环有两种形式，分别为： @for $var from through 和 @for $var from to 。\\$i 表示变量，start 表示起始值，end 表示结束值，这两个的区别是关键字 through 表示包括 end 这个数，而 to 则不包括 end 这个数。 //sass style//——————————-@for $i from 1 through 3 {.item-#{$i} { width: 2em * \\$i; }} //css style//——————————-.item-1 {width: 2em;}.item-2 {width: 4em;}.item-3 {width: 6em;} (4) @each 循环语法为： @each $var in 。其中 $var 表示变量，而 list 和 map 表示 list 类型数据和 map 类型数据。sass 3.3.0 新加入了多字段循环和 map 数据循环。 单个字段 list 数据循环 //sass style//——————————-$animal-list: puma, sea-slug, egret, salamander;@each $animal in $animal-list {.#{$animal}-icon {background-image: url(‘/images/#{\\$animal}.png’);}} //css style//——————————-.puma-icon {background-image: url(‘/images/puma.png’);}.sea-slug-icon {background-image: url(‘/images/sea-slug.png’);}.egret-icon {background-image: url(‘/images/egret.png’);}.salamander-icon {background-image: url(‘/images/salamander.png’);} 多个字段 list 数据循环 //sass style//——————————-$animal-data: (puma, black, default),(sea-slug, blue, pointer),(egret, white, move);@each $animal, $color, $cursor in $animal-data {.#{$animal}-icon {background-image: url(‘/images/#{$animal}.png’);border: 2px solid $color;cursor: \\$cursor;}} //css style//——————————-.puma-icon {background-image: url(‘/images/puma.png’);border: 2px solid black;cursor: default;}.sea-slug-icon {background-image: url(‘/images/sea-slug.png’);border: 2px solid blue;cursor: pointer;}.egret-icon {background-image: url(‘/images/egret.png’);border: 2px solid white;cursor: move;} 多个字段 map 数据循环 //sass style//——————————-$headings: (h1: 2em, h2: 1.5em, h3: 1.2em);@each $header, $size in $headings { #{$header} {font-size: $size;}} //css style//——————————-h1 {font-size: 2em;}h2 {font-size: 1.5em;}h3 {font-size: 1.2em;}","categories":[],"tags":[]},{"title":"如何将vue-cli创建的项目关联到github或gitlab远程仓库","slug":"yuque/如何将vue-cli创建的项目关联到github或gitlab远程仓库","date":"2020-05-03T10:32:05.000Z","updated":"2020-06-07T13:19:50.439Z","comments":true,"path":"2020/05/03/yuque/如何将vue-cli创建的项目关联到github或gitlab远程仓库/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/如何将vue-cli创建的项目关联到github或gitlab远程仓库/","excerpt":"","text":"进入需要关联到远程仓库的项目文件夹中，执行以下命令： 1、git init 使用 git 初始化项目 2、git remote add origin &lt;remote-project-repository-address&gt; 将项目关联到远程仓库， 为远程项目仓库的地址，在 github 或 gitlab 中按如下图所示获取： 3、git add . 将本地项目添加到暂存区 4、git commit -m &#39;自己提交的描述&#39; 将项目提交本地版本库 5、git push -u origin master 将项目推送到远程仓库","categories":[],"tags":[]},{"title":"webpack大拷问","slug":"yuque/webpack大拷问","date":"2020-05-03T10:02:46.000Z","updated":"2020-06-07T13:19:50.657Z","comments":true,"path":"2020/05/03/yuque/webpack大拷问/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/webpack大拷问/","excerpt":"","text":"1 webpack 与 grunt、gulp 的不同？三者都是前端构建工具，grunt 和 gulp 在早期比较流行，现在 webpack 相对来说比较主流，不过一些轻量化的任务还是会用 gulp 来处理，比如单独打包 CSS 文件等。 grunt 和 gulp 是基于任务和流（Task、Stream）的。类似 jQuery，找到一个（或一类）文件，对其做一系列链式操作，更新流上的数据， 整条链式操作构成了一个任务，多个任务就构成了整个 web 的构建流程。 webpack 是基于入口的。webpack 会自动地递归解析入口所需要加载的所有资源文件，然后用不同的 Loader 来处理不同的文件，用 Plugin 来扩展 webpack 功能。 所以总结一下： 从构建思路来说 gulp 和 grunt 需要开发者将整个前端构建过程拆分成多个Task，并合理控制所有Task的调用关系 webpack 需要开发者找到入口，并需要清楚对于不同的资源应该使用什么 Loader 做何种解析和加工 对于知识背景来说 gulp 更像后端开发者的思路，需要对于整个流程了如指掌 webpack 更倾向于前端开发者的思路 2 与 webpack 类似的工具还有哪些？谈谈你为什么最终选择（或放弃）使用 webpack？同样是基于入口的打包工具还有以下几个主流的： webpack rollup parcel 从应用场景上来看： webpack 适用于大型复杂的前端站点构建 rollup 适用于基础库的打包，如 vue、react parcel 适用于简单的实验性项目，他可以满足低门槛的快速看到效果 由于 parcel 在打包过程中给出的调试信息十分有限，所以一旦打包出错难以调试，所以不建议复杂的项目使用 parcel 3 有哪些常见的 Loader？他们是解决什么问题的？ file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去 source-map-loader：加载额外的 Source Map 文件，以方便断点调试 image-loader：加载并且压缩图片文件 babel-loader：把 ES6 转换成 ES5 css-loader：加载 CSS，支持模块化、压缩、文件导入等特性 style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。 eslint-loader：通过 ESLint 检查 JavaScript 代码 4 有哪些常见的 Plugin？他们是解决什么问题的？ define-plugin：定义环境变量 commons-chunk-plugin：提取公共代码 uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码 5 Loader 和 Plugin 的不同？不同的作用 Loader 直译为”加载器”。Webpack 将一切文件视为模块，但是 webpack 原生是只能解析 js 文件，如果想将其他文件也打包的话，就会用到 loader。 所以 Loader 的作用是让 webpack 拥有了加载和解析非 JavaScript 文件的能力。 Plugin 直译为”插件”。Plugin 可以扩展 webpack 的功能，让 webpack 具有更多的灵活性。 在 - Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 不同的用法 Loader 在 module.rules 中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个 Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options） Plugin 在 plugins 中单独配置。 类型为数组，每一项是一个 plugin 的实例，参数都通过构造函数传入 6 webpack 的构建流程是什么?Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数； 开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译； 确定入口：根据配置中的 entry 找出所有的入口文件； 编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理； 完成模块编译：在经过第 4 步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； 输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会； 输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 7 是否写过 Loader 和 Plugin？描述一下编写 loader 或 plugin 的思路？Loader 像一个”翻译官”把读到的源文件内容转义成新的文件内容，并且每个 Loader 通过链式操作，将源文件一步步翻译成想要的样子。 编写 Loader 时要遵循单一原则，每个 Loader 只做一种”转义”工作。 每个 Loader 的拿到的是源文件内容（source），可以通过返回值的方式将处理后的内容输出，也可以调用 this.callback()方法，将内容返回给 webpack。 还可以通过 this.async()生成一个 callback 函数，再用这个 callback 将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发 loader 的工具函数集——loader-utils。 相对于 Loader 而言，Plugin 的编写就灵活了许多。 webpack 在运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 8 webpack 的热更新是如何做到的？说明其原理？webpack 的热更新又称热替换（Hot Module Replacement），缩写为 HMR。 这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。 原理： 首先要知道 server 端和 client 端都做了处理工作 第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。 第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API 对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。 第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了 devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。 第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。 webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。 HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。 而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。 最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。 9 如何利用 webpack 来优化前端性能？（提高性能和体验）用 webpack 优化前端性能是指优化 webpack 的输出结果，让打包的最终结果在浏览器运行快速高效。 压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用 webpack 的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩 JS 文件， 利用 cssnano（css-loader?minimize）来压缩 css 利用 CDN 加速。在构建过程中，将引用的静态资源路径修改为 CDN 上对应的路径。可以利用 webpack 对于 output 参数和各 loader 的 publicPath 参数来修改资源路径 删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动 webpack 时追加参数–optimize-minimize 来实现 提取公共代码。 10 如何提高 webpack 的构建速度？ 多入口情况下，使用 CommonsChunkPlugin 来提取公共代码 通过 externals 配置来提取常用库 利用 DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引用但是绝对不会修改的 npm 包来进行预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 使用 Happypack 实现多线程加速编译 使用 webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采用了多核并行压缩来提升压缩速度 使用 Tree-shaking 和 Scope Hoisting 来剔除多余代码 11 怎么配置单页应用？怎么配置多页应用？单页应用可以理解为 webpack 的标准模式，直接在 entry 中指定单页应用的入口即可，这里不再赘述 多页应用的话，可以使用 webpack 的 AutoWebPlugin 来完成简单自动化的构建，但是前提是项目的目录结构必须遵守他预设的规范。 多页应用中要注意的是： 每个页面都有公共的代码，可以将这些代码抽离出来，避免重复的加载。比如，每个页面都引用了同一套 css 样式表 随着业务的不断扩展，页面可能会不断的追加，所以一定要让入口的配置足够灵活，避免每次添加新页面还需要修改构建配置 12 npm 打包时需要注意哪些？如何利用 webpack 来更好的构建？Npm 是目前最大的 JavaScript 模块仓库，里面有来自全世界开发者上传的可复用模块。你可能只是 JS 模块的使用者，但是有些情况你也会去选择上传自己开发的模块。 关于 NPM 模块上传的方法可以去官网上进行学习，这里只讲解如何利用 webpack 来构建。 NPM 模块需要注意以下问题： 要支持 CommonJS 模块化规范，所以要求打包后的最后结果也遵守该规则。 Npm 模块使用者的环境是不确定的，很有可能并不支持 ES6，所以打包的最后结果应该是采用 ES5 编写的。并且如果 ES5 是经过转换的，请最好连同 SourceMap 一同上传。 Npm 包大小应该是尽量小（有些仓库会限制包大小） 发布的模块不能将依赖的模块也一同打包，应该让用户选择性的去自行安装。这样可以避免模块应用者再次打包时出现底层模块被重复打包的情况。 UI 组件类的模块应该将依赖的其它资源文件，例如.css 文件也需要包含在发布的模块里。 基于以上需要注意的问题，我们可以对于 webpack 配置做以下扩展和优化： CommonJS 模块化规范的解决方案： 设置 output.libraryTarget=’commonjs2’使输出的代码符合 CommonJS2 模块化规范，以供给其它模块导入使用 输出 ES5 代码的解决方案：使用 babel-loader 把 ES6 代码转换成 ES5 的代码。再通过开启 devtool: ‘source-map’输出 SourceMap 以发布调试。 Npm 包大小尽量小的解决方案：Babel 在把 ES6 代码转换成 ES5 代码时会注入一些辅助函数，最终导致每个输出的文件中都包含这段辅助函数的代码，造成了代码的冗余。解决方法是修改.babelrc 文件，为其加入 transform-runtime 插件 不能将依赖模块打包到 NPM 模块中的解决方案：使用 externals 配置项来告诉 webpack 哪些模块不需要打包。 对于依赖的资源文件打包的解决方案：通过 css-loader 和 extract-text-webpack-plugin 来实现，配置如下： 12345678910111213141516171819202122const ExtractTextPlugin = require(\"extract-text-webpack-plugin\");module.exports = &#123; module: &#123; rules: [ &#123; // 增加对 CSS 文件的支持 test: /\\.css/, // 提取出 Chunk 中的 CSS 代码到单独的文件中 use: ExtractTextPlugin.extract(&#123; use: [\"css-loader\"], &#125;), &#125;, ], &#125;, plugins: [ new ExtractTextPlugin(&#123; // 输出的 CSS 文件名称 filename: \"index.css\", &#125;), ],&#125;; 13 如何在 vue 项目中实现按需加载？Vue UI 组件库的按需加载 为了快速开发前端项目，经常会引入现成的 UI 组件库如 ElementUI、iView 等，但是他们的体积和他们所提供的功能一样，是很庞大的。 而通常情况下，我们仅仅需要少量的几个组件就足够了，但是我们却将庞大的组件库打包到我们的源码中，造成了不必要的开销。 不过很多组件库已经提供了现成的解决方案，如 Element 出品的 babel-plugin-component 和 AntDesign 出品的 babel-plugin-import 安装以上插件后，在.babelrc 配置中或 babel-loader 的参数中进行设置，即可实现组件按需加载了。 123456789101112&#123; \"presets\": [[\"es2015\", &#123; \"modules\": false &#125;]], \"plugins\": [ [ \"component\", &#123; \"libraryName\": \"element-ui\", \"styleLibraryName\": \"theme-chalk\" &#125; ] ]&#125; 单页应用的按需加载 现在很多前端项目都是通过单页应用的方式开发的，但是随着业务的不断扩展，会面临一个严峻的问题——首次加载的代码量会越来越多，影响用户的体验。 通过import(*)语句来控制加载时机，webpack 内置了对于import(*)的解析，会将import(*)中引入的模块作为一个新的入口在生成一个 chunk。 当代码执行到import(*)语句时，会去加载 Chunk 对应生成的文件。import()会返回一个 Promise 对象，所以为了让浏览器支持，需要事先注入 Promise polyfill。","categories":[],"tags":[]},{"title":"Vue学习小记","slug":"yuque/Vue学习小记","date":"2020-05-03T10:02:41.000Z","updated":"2020-06-07T13:19:50.893Z","comments":true,"path":"2020/05/03/yuque/Vue学习小记/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Vue学习小记/","excerpt":"","text":"title: Vue 学习小记 date: 2019 年 04 月 08 日 00:27:43categories: Frameworktypora-root-url: ..typora-copy-images-to: ../images Vue 的安装及语法 解析 页面中的数据与内存中的数据双向绑定 v-mdodel v-show：暂时隐藏 v-if：直接从dom中删除 v-for 指令v-bind 指令（v-bind:可简写为:） 绑定数据和元素属性：src、href 12345678&lt;style&gt; .active &#123; background: #a10; &#125;&lt;/style&gt;&lt;a :class=\"&#123;active: isActive&#125;\" :href=\"url\"&gt; 点我&lt;/a&gt; 123456789var app = new Vue(&#123; el: \"#app\", data: &#123; url: \"http://baidu.com\", img: \"https://dummyimage.com/100x100/ffcc00/ffffff\", klass: \"btn btn-default\", isActive: true, &#125;,&#125;); v-on 指令（v-on:可简写为@，v-on=不可简写） v-on=”{事件:函数, 事件:函数}” v-on:事件=”函数()” 一定要都写在 div#app 中 更多事件参考：https://cn.vuejs.org/v2/guide/events.html v-model 指令及其修饰符 适用于：input、textarea、select v-model对变量进行绑定并操作，输出变量 v-model.lazy 失焦更新 v-model.trim 删去空格 v-model.number 字符串转为 number v-model 在其他元素及类型上的用法控制流指令 v-if v-else-if v-else 计算属性 和method的区别：缓存数据，提高了性能 123456789computed: &#123; sum: function () &#123; return parseFloat(this.math) + parseFloat(this.physics) + parseFloat(this.english); &#125;, average: function () &#123; return Math.round(this.sum / 3); &#125; &#125;,&#125;); 12345678&lt;tr&gt; &lt;td&gt;总分&lt;/td&gt; &lt;td&gt;&#123;&#123;sum&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;平均分&lt;/td&gt; &lt;td&gt;&#123;&#123;average&#125;&#125;&lt;/td&gt;&lt;/tr&gt; 组件 - 全局及局部组件 全局组件 123Vue.component(\"like\", &#123; template: \"\",&#125;); 局部组件 123456789101112131415var alert_component = &#123; template: '&lt;button @click=\"on_click\"&gt;弹弹弹&lt;/button&gt;', methods: &#123; on_click: function () &#123; alert(\"Yo.\"); &#125;, &#125;,&#125;;new Vue(&#123; el: \"#seg1\", components: &#123; alert: alert_component, &#125;,&#125;); 组件 - 配置组件 template 必须放在 el 外面 1234567891011121314151617Vue.component(\"like\", &#123; template: \"#like-component-tpl\", data: function () &#123; return &#123; like_count: 10, liked: false, &#125;; &#125;, methods: &#123; toggle_like: function () &#123; if (!this.liked) this.like_count++; else this.like_count--; this.liked = !this.liked; &#125;, &#125;,&#125;); 123456789&lt;div id=\"app\"&gt; &lt;like&gt;&lt;/like&gt;&lt;/div&gt;&lt;template id=\"like-component-tpl\"&gt; &lt;button :class=\"&#123;liked: liked&#125;\" @click=\"toggle_like()\"&gt; 👍👍 &#123;&#123;like_count&#125;&#125; &lt;/button&gt;&lt;/template&gt; 组件 - 父子通信 自定义传参 12345Vue.component(\"user\", &#123; template: \"&lt;a :href=\\\"'/user/' + username\\\"&gt;&#123;&#123;username&#125;&#125;&lt;/a&gt;\", props: [\"username\"], methods: &#123;&#125;,&#125;); 123&lt;div id=\"app\"&gt; &lt;user username=\"biaoyansu\"&gt;&lt;/user&gt;&lt;/div&gt; 组件 - 子父通信123456789101112131415161718192021222324252627282930313233Vue.component(\"balance\", &#123; template: ` &lt;div&gt; &lt;show @show-balance=\"show_balance\"&gt;&lt;/show&gt; //监听事件 &lt;div v-if=\"show\"&gt; 您的余额：￥98逸 &lt;/div&gt; &lt;/div&gt; `, methods: &#123; show_balance: function (data) &#123; this.show = true; console.log(\"data:\", data); &#125;, &#125;, data: function () &#123; return &#123; show: false, &#125;; &#125;,&#125;);Vue.component(\"show\", &#123; template: '&lt;button @click=\"on_click()\"&gt;显示余额&lt;/button&gt;', methods: &#123; on_click() &#123; this.$emit(\"show-balance\", &#123; a: 1, b: 2 &#125;); //$emit向父级元素传递事件，触发一个事件 &#125;, &#125;,&#125;);new Vue(&#123; el: \"#app\",&#125;); 组件 - 任意及平行组件间通信 模板必须有最外层根元素div等 12345678910111213141516171819202122232425262728293031323334353637var Event = new Vue(); //调度器Vue.component(\"huahua\", &#123; template: ` &lt;div&gt; 我说：&lt;input @keyup=\"on_change\" v-model=\"i_said\"/&gt; &lt;/div&gt;`, methods: &#123; on_change: function () &#123; Event.$emit(\"huahua-said-something\", this.i_said); //$emit触发器返回函数名和函数值 &#125;, &#125;, data: function () &#123; return &#123; i_said: \"\", &#125;; &#125;,&#125;);Vue.component(\"shuandan\", &#123; template: `&lt;div&gt;花花说：&#123;&#123;huahua_said&#125;&#125;&lt;/div&gt;`, data: function () &#123; return &#123; huahua_said: \"\", &#125;; &#125;, mounted: function () &#123; //钩子，生命周期完成后，成熟后触发事件 var me = this; Event.$on(\"huahua-said-something\", function (data) &#123; me.huahua_said = data; &#125;); &#125;,&#125;);new Vue(&#123; el: \"#app\",&#125;); 过滤器 filter和计算属性类似，简单的用filter，复杂的用计算属性，计算属性有缓存 12345678910111213141516171819Vue.filter(\"meter\", function (val, unit) &#123; val = val || 0; //无val默认值为0 unit = unit || \"m\"; //无unit默认值为m return (val / 1000).toFixed(2) + unit;&#125;);Vue.filter(\"currency\", function (val, unit) &#123; val = val || 0; unit = unit || \"元\"; return val + unit;&#125;);new Vue(&#123; el: \"#app\", data: &#123; price: 10, length: 10, &#125;,&#125;); 1234567891011&lt;div&gt; &lt;input v-model=\"length\" /&gt; mm &lt;br /&gt; &#123;&#123;length | meter&#125;&#125;&lt;/div&gt;&lt;hr /&gt;&lt;div&gt; &lt;input v-model=\"price\" /&gt; &lt;br /&gt; &#123;&#123; price | currency('USD') &#125;&#125;&lt;/div&gt; 自定义指令 - 基础配置1234567891011121314151617181920212223Vue.directive(\"pin\", function (el, binding) &#123; var pinned = binding.value; //默认为false console.log(pinned); if (pinned) &#123; el.style.position = \"fixed\"; el.style.top = \"10px\"; el.style.left = \"10px\"; &#125; else &#123; el.style.position = \"static\"; &#125;&#125;);new Vue(&#123; el: \"#app\", data: &#123; card1: &#123; pinned: false, &#125;, card2: &#123; pinned: false, &#125;, &#125;,&#125;); 12345678&lt;div v-pin=\"card1.pinned\" class=\"card\"&gt; &lt;button @click=\"card1.pinned = !card1.pinned\"&gt;钉住/取消&lt;/button&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt;&lt;div v-pin=\"card2.pinned\" class=\"card\"&gt; &lt;a @click=\"card2.pinned = !card2.pinned\" href=\"#\"&gt;pin it&lt;/a&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt; 自定义指令 - 配置传参及修饰符123456789101112131415161718192021222324252627282930313233Vue.directive(\"pin\", function (el, binding) &#123; var pinned = binding.value; //modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。 var position = binding.modifiers; var warning = binding.arg; //arg紧跟: if (pinned) &#123; el.style.position = \"fixed\"; for (var key in position) &#123; if (position[key]) &#123; el.style[key] = \"10px\"; &#125; &#125; if (warning === \"true\") &#123; el.style.background = \"yellow\"; &#125; &#125; else &#123; el.style.position = \"static\"; &#125;&#125;);new Vue(&#123; el: \"#app\", data: &#123; card1: &#123; pinned: false, &#125;, card2: &#123; pinned: false, &#125;, &#125;,&#125;); 12345678&lt;div v-pin:true.bottom.left=\"card1.pinned\" class=\"card\"&gt; &lt;button @click=\"card1.pinned = !card1.pinned\"&gt;钉住/取消&lt;/button&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt;&lt;div v-pin=\"card2.pinned\" class=\"card\"&gt; &lt;a @click=\"card2.pinned = !card2.pinned\" href=\"#\"&gt;pin it&lt;/a&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt; ###混合 mixins component中代码复用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354var base = &#123; methods: &#123; show: function () &#123; this.visible = true; &#125;, hide: function () &#123; this.visible = false; &#125;, toggle: function () &#123; this.visible = !this.visible; &#125;, &#125;, data: function () &#123; return &#123; visible: false, &#125;; &#125;,&#125;;Vue.component(\"tooltip\", &#123; template: ` &lt;div&gt; &lt;span @mouseenter=\"show\" @mouseleave=\"hide\"&gt;bys&lt;/span&gt; &lt;div v-if=\"visible\"&gt; 白岩松 &lt;/div&gt; &lt;/div&gt; `, mixins: [base], data: function () &#123; return &#123; visible: true, &#125;; &#125;,&#125;);Vue.component(\"popup\", &#123; template: ` &lt;div&gt; &lt;button @click=\"toggle\"&gt;Popup&lt;/button&gt; &lt;div v-if=\"visible\"&gt; &lt;span @click=\"hide\"&gt;X&lt;/span&gt; &lt;h4&gt;title&lt;/h4&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Amet dolorum, iusto non nostrum porro ratione. Dolor dolorem id impedit. Dolore excepturi exercitationem incidunt iste magnam odio quas temporibus. Assumenda, magni. &lt;/div&gt; &lt;/div&gt; `, mixins: [base],&#125;);new Vue(&#123; el: \"#app\", data: &#123;&#125;,&#125;); 1234&lt;div id=\"app\"&gt; &lt;tooltip&gt;&lt;/tooltip&gt; &lt;popup&gt;&lt;/popup&gt;&lt;/div&gt; 插槽 slots 相当于component中的变量 1234567891011121314151617181920212223242526&lt;div id=\"app\"&gt; &lt;panel&gt; &lt;div slot=\"title\"&gt; Yo. &lt;/div&gt; &lt;div slot=\"content\"&gt; Yo Yo Yo &lt;/div&gt; &lt;/panel&gt;&lt;/div&gt;&lt;template id=\"panel-tpl\"&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"title\"&gt; &lt;slot name=\"title\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;slot name=\"content\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;slot name=\"footer\"&gt; 更多信息 &lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; vue-router 是什么和怎么用 无整页刷新，表单数据点回来仍保留 安装和基本配置12345678910111213141516171819202122232425262728293031var routes = [ &#123; path: \"/\", component: &#123; template: ` &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;, &#123; path: \"/about\", component: &#123; template: ` &lt;div&gt; &lt;h1&gt;关于我们&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;);new Vue(&#123; el: \"#app\", router: router,&#125;); 123456789&lt;div id=\"app\"&gt; &lt;div&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于我们&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 传参及获取传参123456789path: '/user/:name',component: &#123; template: ` &lt;div&gt; &lt;div&gt;我叫：&#123;&#123;$route.params.name&#125;&#125;&lt;/div&gt; &lt;div&gt;我今年：&#123;&#123;$route.query.age&#125;&#125;岁了&lt;/div&gt; &lt;/div&gt; `,&#125;, 1234567891011&lt;div id=\"app\"&gt; &lt;div&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于我们&lt;/router-link&gt; &lt;router-link to=\"/user/王花花\"&gt;王花花&lt;/router-link&gt; &lt;router-link to=\"/user/李拴蛋\"&gt;李拴蛋&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 子路由123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var routes = [ &#123; path: \"/\", component: &#123; template: ` &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;, &#123; path: \"/about\", component: &#123; template: ` &lt;div&gt; &lt;h1&gt;关于我们&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;, &#123; path: \"/user/:name\", component: &#123; template: ` &lt;div&gt; &lt;div&gt;我叫：&#123;&#123;$route.params.name&#125;&#125;&lt;/div&gt; &lt;router-link to=\"more\" append&gt;更多信息&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `, &#125;, children: [ &#123; path: \"more\", component: &#123; template: ` &lt;div&gt; 用户&#123;&#123;$route.params.name&#125;&#125;的详细信息 Lorem ipsum dolor sit amet, consectetur adipisicing elit. Adipisci cum deleniti doloribus expedita inventore natus officiis quod quos similique voluptate! Distinctio nisi sequi tenetur voluptatum? Debitis iste neque pariatur voluptatibus? &lt;/div&gt; `, &#125;, &#125;, ], &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;); 1234567891011&lt;div id=\"app\"&gt; &lt;div&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于我们&lt;/router-link&gt; &lt;router-link to=\"/user/王花花\"&gt;王花花&lt;/router-link&gt; &lt;router-link to=\"/user/李拴蛋\"&gt;李拴蛋&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 手动访问和传参命名视图12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var routes = [ &#123; path: \"/\", component: &#123; template: ` &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;, &#123; path: \"/user\", components: &#123; sidebar: &#123; template: ` &lt;div&gt; &lt;ul&gt; &lt;li&gt;用户列表&lt;/li&gt; &lt;li&gt;权限管理&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, &#125;, content: &#123; template: ` &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Deleniti in, laborum molestias necessitatibus optio perferendis quaerat quas qui quisquam sapiente. Architecto corporis eos eum libero optio, perspiciatis quo rem vel!&lt;/div&gt; `, &#125;, &#125;, &#125;, &#123; path: \"/post\", components: &#123; sidebar: &#123; template: ` &lt;div&gt; &lt;ul&gt; &lt;li&gt;帖子列表&lt;/li&gt; &lt;li&gt;标签管理&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; `, &#125;, content: &#123; template: ` &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Deleniti in, laborum molestias necessitatibus optio perferendis quaerat quas qui quisquam sapiente. Architecto corporis eos eum libero optio, perspiciatis quo rem vel!&lt;/div&gt; `, &#125;, &#125;, &#125;,]; 导航钩子 访问限制，中间件，组件的生命周期 123456789101112131415161718192021222324252627282930313233var routes = [ &#123; path: \"/\", component: &#123; template: `&lt;h1&gt;首页&lt;/h1&gt;`, &#125;, &#125;, &#123; path: \"/login\", component: &#123; template: `&lt;h1&gt;登录&lt;/h1&gt;`, &#125;, &#125;, &#123; path: \"/post\", component: &#123; template: `&lt;h1&gt;帖子管理&lt;/h1&gt;`, &#125;, &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;);router.beforeEach(function (to, from, next) &#123; var logged_in = true; if (!logged_in &amp;&amp; to.path == \"/post\") next(\"/login\"); else next();&#125;);router.afterEach(function (to, from) &#123;&#125;); 元数据及路由匹配 使用 meta 元数据进行访问限制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061var routes = [ &#123; path: \"/\", component: &#123; template: `&lt;h1&gt;首页&lt;/h1&gt;`, &#125;, &#125;, &#123; path: \"/a\", meta: &#123; login_required: true, &#125;, component: &#123; template: `&lt;h1&gt;A&lt;/h1&gt;`, &#125;, &#125;, &#123; path: \"/login\", component: &#123; template: `&lt;h1&gt;登录&lt;/h1&gt;`, &#125;, &#125;, &#123; path: \"/post\", meta: &#123; login_required: true, &#125;, component: &#123; template: `&lt;div&gt; &lt;h1&gt;帖子管理&lt;/h1&gt; &lt;router-link to=\"rain\" append&gt;后座&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;`, &#125;, children: [ &#123; path: \"rain\", component: &#123; template: `&lt;h2&gt;雨天asdf后座&lt;/h2&gt;`, &#125;, &#125;, ], &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;);router.beforeEach(function (to, from, next) &#123; var logged_in = true; if ( !logged_in &amp;&amp; to.matched.some(function (item) &#123; return item.meta.login_required; &#125;) ) next(\"/login\"); else next();&#125;);","categories":[],"tags":[]},{"title":"ThinkPHP学习小记","slug":"yuque/ThinkPHP学习小记","date":"2020-05-03T10:02:36.000Z","updated":"2020-06-07T13:19:50.912Z","comments":true,"path":"2020/05/03/yuque/ThinkPHP学习小记/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/ThinkPHP学习小记/","excerpt":"","text":"ID 不从 1 开始truncate table 你的表名 无法访问可能保存了带bom的utf编码 部署到 iis 服务器将runtime设定到支持写入的目录 数据不为空显示123456789&lt;!-- 不等于 --&gt;&lt;if condition=\"$result[0]['jiyao_id'] neq null\"&gt; &lt;tr&gt; &lt;td style=\"vertical-align: middle;text-align:center;width: 20%\"&gt; &lt;span&gt;&lt;b&gt;机要编号&lt;/b&gt;&lt;/span&gt; &lt;/td&gt; &lt;td class=\"description\"&gt;&#123;$result[0]['jiyao_id']&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/if&gt; 1 0 转换12&lt;!-- 字符串用'' --&gt;&lt;if condition=\"$student.is_searched eq 1\"&gt;已查询&lt;else/&gt;未查询&lt;/if&gt;&lt;/td&gt;","categories":[],"tags":[]},{"title":"Spring学习小记","slug":"yuque/Spring学习小记","date":"2020-05-03T10:02:31.000Z","updated":"2020-06-07T13:19:50.917Z","comments":true,"path":"2020/05/03/yuque/Spring学习小记/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Spring学习小记/","excerpt":"","text":"IOC image.png AOP image.png HibernateSpringMVC image.png","categories":[],"tags":[]},{"title":"Java学习小记","slug":"yuque/Java学习小记","date":"2020-05-03T10:02:26.000Z","updated":"2020-06-07T13:19:50.927Z","comments":true,"path":"2020/05/03/yuque/Java学习小记/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Java学习小记/","excerpt":"","text":"Scanner123456789101112131415161718192021222324252627282930313233343536373839404142Scanner s = new Scanner(System.in);// 使用hasNextXxx()方法进行验证，再使用nextXxx()来读取// next()// next() 不能得到带有空格的字符串import java.util.Scanner;public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 //next方式接收字符串 System.out.println(\"next方式接收：\"); // 判断是否还有输入 if(scan.hasNext())&#123; String str1 = scan.next(); System.out.println(\"输入的数据为：\"+str1); &#125; &#125;&#125;// nextLine()// 以Enter为结束符，可以获得空白import java.util.Scanner;public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 //nextLine方式接收字符串 System.out.println(\"nextLine方式接收：\"); // 判断是否还有输入 if(scan.hasNextLine())&#123; String str2 = scan.nextLine(); System.out.println(\"输入的数据为：\"+str2); &#125; &#125;&#125;scanner.close(); 数组大小用 size()1students.size(); 数组访问用 get()1temp = students.get(i); 数组修改用 set()1students.set(i, stu); for 的遍历1234567891011// 打印所有学生的信息public void displayAllStudent() &#123; if (students.size() &gt; 0) &#123; for (Student stu : students) &#123; System.out.println(\"学号: \" + stu.getSno() + \"\\t姓名: \" + stu.getSname() + \"\\t系部: \" + stu.getSdept()); &#125; &#125;else &#123; System.out.println(\"数据库中无学生记录!\"); &#125;&#125; 读取文件123456789101112131415161718192021// 读取文件获得原始数据private void getData() &#123; try &#123; FileReader in_ = new FileReader(\"StudentDAO.txt\"); BufferedReader in = new BufferedReader(in_); String line; String reg1 = \"\\\\s+\"; String str[] = new String[3]; while ((line = in.readLine()) != null) &#123; Student temp = new Student(); str = line.split(reg1); temp.setSno(str[0]); temp.setSname(str[1]); temp.setSdept(str[2]); students.add(temp); &#125; in.close(); &#125; catch (IOException e) &#123; System.out.println(e); &#125;&#125; 写入文件12345678910111213141516//更新数据库,把数据输入文件private void updateData() &#123; try &#123; FileWriter out_ = new FileWriter(\"StudentDAO.txt\"); BufferedWriter out = new BufferedWriter(out_); Student temp = new Student(); for (int i = 0; i &lt; students.size(); i++) &#123; temp = students.get(i); out.write(temp.getSno() + \" \" + temp.getSname() + \" \" + temp.getSdept() + \"\\r\\n\"); &#125; out.close(); &#125; catch (IOException e) &#123; System.out.println(e); &#125;&#125; BufferedReader12345678910do &#123; // 从输入流读取一个字符并把该字符作为整数值返回， 当流结束的时候返回 -1 c = (char)br.read(); System.out.println(c);&#125; while (c != 'q');do &#123; str = br.readLine(); System.out.println(str);&#125; while(!str.equals(\"end\")); FileInputStream（从文件读取数据）1234InputStream f = new FileInputStream(\"C:/java/hello\");File f = new File(\"C:/java/hello\");InputStream out = new FileInputStream(f); FileOutputStream（向文件中写数据）1234OutputStream f = new FileOutputStream(\"C:/java/hello\")File f = new File(\"C:/java/hello\");OutputStream f = new FileOutputStream(f); 读取写入流最后都要 close();读写一定要用 byte12byte bWrite[] = &#123; 11, 21, 3, 40, 5 &#125;;byte bWrite[] = \"zhouzhiwenishandsome\".getBytes();","categories":[],"tags":[]},{"title":"IEEE LaTeX模板使用BibTeX","slug":"yuque/IEEE LaTeX模板使用BibTeX","date":"2020-05-03T10:02:21.000Z","updated":"2020-06-07T13:19:50.941Z","comments":true,"path":"2020/05/03/yuque/IEEE LaTeX模板使用BibTeX/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/IEEE LaTeX模板使用BibTeX/","excerpt":"","text":"最近在写 IEEE 的论文，就为了参考文献不愿意下载那么大的 LaxTex，发现了一个在线的 LaTeX editor https://www.sharelatex.com/ ， 发现还挺好用的。 在 Google Scholar 获得的文献引用格式一般是 BibTex 的，而 IEEE Transactions 的模板默认用的是 BibItem。目前没有什么自动化的 BibTeX 转 BibItem 的工具或网站。 使用方法 在 Google Scholar 搜索到的文献结果，点击下面的“Cite”，然后点击“BibTeX”即可得到类似如下的文献信息 12345678910@article&#123;b1, // b1为正文引用时的名字 title=&#123;Reading behavior in the digital environment: Changes in reading behavior over the past ten years&#125;, author=&#123;Liu, Ziming&#125;, journal=&#123;Journal of documentation&#125;, volume=&#123;61&#125;, number=&#123;6&#125;, pages=&#123;700--712&#125;, year=&#123;2005&#125;, publisher=&#123;Emerald Group Publishing Limited&#125;&#125; 将以上信息添加到侧边栏中的 references.bib 文件中，文件名随意，与.tex 文件在同一目录 在 IEEE Transactions 模板中，默认的引用文献是这样写的 123456789\\begin&#123;thebibliography&#125;&#123;00&#125;\\bibitem&#123;b1&#125; G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,&apos;&apos; Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.\\bibitem&#123;b2&#125; J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.\\bibitem&#123;b3&#125; I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,&apos;&apos; in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.\\bibitem&#123;b4&#125; K. Elissa, ``Title of paper if known,&apos;&apos; unpublished.\\bibitem&#123;b5&#125; R. Nicole, ``Title of paper with only first word capitalized,&apos;&apos; J. Name Stand. Abbrev., in press.\\bibitem&#123;b6&#125; Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,&apos;&apos; IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].\\bibitem&#123;b7&#125; M. Young, The Technical Writer&apos;s Handbook. Mill Valley, CA: University Science, 1989.\\end&#123;thebibliography&#125; 将上述部分换成如下代码 12\\bibliographystyle&#123;IEEEtran&#125;\\bibliography&#123;references&#125;&#123;&#125; 点击重新编译即可看到效果 注意正文中必须要使用\\cite{b1}引用后，正文中的参考文献才会显示引用的条目，否则编译无数次也没有效果 😢","categories":[],"tags":[]},{"title":"IDEA构建SSH项目（hibernate自动生成+jetty的使用）","slug":"yuque/IDEA构建SSH项目（hibernate自动生成+jetty的使用）","date":"2020-05-03T10:02:16.000Z","updated":"2020-06-07T13:19:50.979Z","comments":true,"path":"2020/05/03/yuque/IDEA构建SSH项目（hibernate自动生成+jetty的使用）/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/IDEA构建SSH项目（hibernate自动生成+jetty的使用）/","excerpt":"","text":"1 创建 Maven 项目 GroupId 和 ArtifactId 被统称为“坐标”，是为了保证项目唯一性而提出的，如果你要把你项目弄到 maven 本地仓库去，你想要找到你的项目就必须根据这两个 id 去查找。 GroupId=域+公司名称。域又分为 org、com、cn 等，其中 org 为非营利组织，com 为商业组织。 apache 公司的 tomcat 项目：这个项目的 GroupId 是 org.apache，它的域是 org（因为 tomcat 是非营利项目），公司名称是 apache，ArtifactId 是 tomcat。 我一般会将 GroupId 设置为 cn.ftx，cn 表示域为中国，ftx 是我个人姓名缩写，ArtifactId 设置为 testProject，表示这个项目的名称是 testProject。 依照这个设置，在创建 Maven 工程后，新建包的时候，包结构最好是 cn.ftx.testProject 打头的，如果有个 StudentDao，它的全路径就是 cn.ftx.testProject.dao.StudentDao 2 修改目录结构默认生成的目录结构 标准的 Maven 项目结构java 目录需 mark didectory as source root，resources 目录需 mark directory as resources root Java 源代码结构 配置文件 3 在 pom.xml 中添加依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.ftx&lt;/groupId&gt; &lt;artifactId&gt;testProject&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;testProject Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;4.3.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;4.3.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-orm --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;4.3.17.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.mchange/c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.3.7.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-jpa --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt; &lt;version&gt;1.11.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-commons --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-commons&lt;/artifactId&gt; &lt;version&gt;1.13.13.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;4.3.18.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--aspectj切面依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.13&lt;/version&gt; &lt;/dependency&gt; &lt;!--用于springMVC验证的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.0.7.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!--处理json用到的依赖，用于对应的HttpMessageConverter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--jetty依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;version&gt;9.3.2.v20150730&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-annotations&lt;/artifactId&gt; &lt;version&gt;9.3.2.v20150730&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;apache-jsp&lt;/artifactId&gt; &lt;version&gt;9.3.2.v20150730&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;apache-jstl&lt;/artifactId&gt; &lt;version&gt;9.3.2.v20150730&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jstl--&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;sy5-web&lt;/finalName&gt; &lt;!--防止maven构建时忽略xml文件--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.20.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;!--jetty插件--&gt; &lt;plugin&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-maven-plugin&lt;/artifactId&gt; &lt;version&gt;9.3.12.v20160915&lt;/version&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt; 4 新建 Resource Bundel config.properties123456789101112################### JDBC Configuration ##########################jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.url=jdbc:mysql://localhost/sy5?useSSL=false&amp;serverTimezone=Asia/Shanghaijdbc.username=rootjdbc.password=123456789################### Hibernate Configuration ##########################hibernate.dialect=org.hibernate.dialect.MySQLDialecthibernate.show_sql=falsehibernate.hbm2ddl.auto=updatehibernate.format_sql=truehibernate.generate_statistics=true 5 在 resources 中添加 web 容器 dispatcher-servlet.xml 最常用的 URL 文件应该就是 jsp 页面了，InternalResourceViewResolver 解析器可以解析该资源 prefix 和 suffix 属性可以指定资源页面的前缀和后缀，可以直接把资源位置定位到项目的/WEB-INF/下面 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;mvc:annotation-driven/&gt; &lt;context:component-scan base-package=\"cn.ftx.testProject\"/&gt; &lt;bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/views/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 6 在 resources 中添加 spring 容器 applicationContext.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;context:annotation-config/&gt; &lt;!-- 自动扫描所有注解该路径 --&gt; &lt;context:component-scan base-package=\"cn.ftx.testProject\"/&gt; &lt;tx:annotation-driven transaction-manager=\"txManage\"/&gt; &lt;!--引入配置文件--&gt; &lt;bean id=\"propertyConfigurer\" class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"locations\"&gt; &lt;list&gt; &lt;value&gt;classpath:config.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--数据库连接--&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driverClass&#125;\"/&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;&#125;\"/&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;/bean&gt; &lt;bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5.LocalSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt; &lt;property name=\"mappingDirectoryLocations\"&gt; &lt;list&gt; &lt;value&gt;classpath:cn/ftx/testProject/model&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"hibernateProperties\"&gt; &lt;props&gt; &lt;prop key=\"hibernate.dialect\"&gt;$&#123;hibernate.dialect&#125;&lt;/prop&gt; &lt;prop key=\"hibernate.show_sql\"&gt;$&#123;hibernate.show_sql&#125;&lt;/prop&gt; &lt;prop key=\"format_sql\"&gt;$&#123;hibernate.format_sql&#125;&lt;/prop&gt; &lt;prop key=\"hibernate.hbm2ddl.auto\"&gt;$&#123;hibernate.hbm2ddl.auto&#125;&lt;/prop&gt; &lt;prop key=\"generate_statistics\"&gt;$&#123;hibernate.generate_statistics&#125;&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;property name=\"packagesToScan\" value=\"cn.ftx.testProject\"&gt;&lt;/property&gt; &lt;!--映射文件地址--&gt; &lt;property name=\"mappingLocations\"&gt; &lt;list&gt; &lt;value&gt;classpath:cn/ftx/testProject/model/Tequipment.hbm.xml&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"txManage\" class=\"org.springframework.orm.hibernate4.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 7 配置 webapp/WEB-INF/web.xml 在 web.xml 中添加监听器，为了加载 spring 容器的配置文件，指定 spring web 容器配置文件的目录 /表示从 webapp 开始，例如：使用/layout/style.css访问 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd\" version=\"2.5\"&gt; &lt;!-- 项目名称 --&gt; &lt;display-name&gt;testProject&lt;/display-name&gt; &lt;!-- 指定spring相关文件的位置 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 开启spring功能 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置spring mvc --&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 配置spring mvc mapping --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置字符集过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- 配置项目的编码mapping --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 防止内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置静态资源不经过spring mvc --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.css&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.js&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.json&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.gif&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.png&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jpg&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.ico&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.doc&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.xls&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.docx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.xlsx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.txt&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;*.swf&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- 配置session超时时间，单位分钟 --&gt; &lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt; &lt;!-- 设置欢迎页面 --&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;/init.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!-- 找不到页错误转向 --&gt; &lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error/404.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;!-- 系统内部错误转向 --&gt; &lt;error-page&gt; &lt;error-code&gt;500&lt;/error-code&gt; &lt;location&gt;/error/500.jsp&lt;/location&gt; &lt;/error-page&gt; &lt;!-- druid数据源Web监控配置 --&gt; &lt;filter&gt; &lt;filter-name&gt;druidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;/css/*,/style/*,/jslib/*,*.js,*.css,/druid*,/attached/*,*.jsp&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;principalSessionName&lt;/param-name&gt; &lt;param-value&gt;sessionInfo&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;profileEnable&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;!-- druid数据源Web监控配置mapping --&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;druidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- druid监控页面，使用$&#123;pageContext.request.contextPath&#125;/druid/index.html访问 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;druidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- druid监控页面mapping --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;druidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 8 hibernate 自动创建 9 使用 jetty *如何打开一个别人的项目 修改成自己的 maven 配置 一直 next，直到 finish 即可","categories":[],"tags":[]},{"title":"Hexo使用心得","slug":"yuque/Hexo使用心得","date":"2020-05-03T10:02:11.000Z","updated":"2020-06-07T13:19:50.987Z","comments":true,"path":"2020/05/03/yuque/Hexo使用心得/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Hexo使用心得/","excerpt":"","text":"新建文章hexo new &quot;Hexo使用心得&quot; 上传图片到 github 并使用 将_config.yml中有的post_asset_folder设置为true 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save 完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹 使用![test](Hexo使用心得/test.jpg)就可以插入图片。其中[]里面不写文字则没有图片标题 Hexo-admin本地的文章编辑器，不支持在线/admin访问，github.io都是静态界面 更新文章hexo d -g","categories":[],"tags":[]},{"title":"Django入门与实践","slug":"yuque/Django入门与实践","date":"2020-05-03T10:02:05.000Z","updated":"2020-06-07T13:19:50.989Z","comments":true,"path":"2020/05/03/yuque/Django入门与实践/","link":"","permalink":"http://fengtx.tk/2020/05/03/yuque/Django入门与实践/","excerpt":"","text":"image.png","categories":[],"tags":[]},{"title":"Axure使用心得","slug":"yuque/Axure使用心得","date":"2020-04-05T00:56:51.000Z","updated":"2020-06-07T13:19:50.992Z","comments":true,"path":"2020/04/05/yuque/Axure使用心得/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/Axure使用心得/","excerpt":"","text":"按住 Ctrl 时，可以旋转 按住 Ctrl 时，拖动曲线 右键转换曲线的类型","categories":[],"tags":[]},{"title":"Android学习小记","slug":"yuque/Android学习小记","date":"2020-04-05T00:56:46.000Z","updated":"2020-06-07T13:19:51.021Z","comments":true,"path":"2020/04/05/yuque/Android学习小记/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/Android学习小记/","excerpt":"","text":"禁止 Android 不跟随屏幕密度加载不同文件夹的资源在 AndroidManifest.xml 文件中添加 android:anyDensity=”false”字段 高分辨率，一般我们把图片丢这里 mipmap-hdpi调试时默认生成的 apk 在：app/build/outputs/apk 目录下Android Studio 打包时 Signature Version V1 V2 同时勾选 V1 和 V2 则所有机型都没问题 生成目录 E:\\wamp64\\www\\EAider\\app\\release 发布 apk 做代码混淆 爱加密match_parent 和 fill_parent fill_parent = match_parent（一般用 match_parent） wrap_content 设置一个视图的尺寸为 wrap_content 将强制性地使视图扩展以显示全部内容。以 TextView 和 ImageView 控件为例，设置为 wrap_content 将完整显示其内部的文本和图像。布局元素将根据内容更改大小。设置一个视图的尺寸为 wrap_content 大体等同于设置 Windows 控件的 Autosize 属性为 True。 layout_gravity 和 gravity android:gravity属性是对该view中内容的限定，比如一个 button 上面的 text，你可以设置该 text 相对于 view 的靠左，靠右等位置 android:layout_gravity是用来设置该 view 相对与父 view 的位置，比如一个 button 在 linearlayout 里，你想把该 button 放在 linearlayout 里靠左、靠右等位置就可以通过该属性设置 android:gravity用于设置 View 中内容相对于 View 组件的对齐方式 android:layout_gravity用于设置 View 组件相对于 Container 的对齐方式 线性布局 权重用途很大 当android:orientation=&quot;vertical&quot;时，只有水平方向的设置才起作用，垂直方向的设置不起作用。即：left,right,center_horizontal是生效的 当android:orientation=&quot;horizontal&quot;时，只有垂直方向的设置才起作用，水平方向的设置不起作用。即：top,bottom,center_vertical是生效的 分隔线1234&lt;View android:layout_width=\"match_parent\" android:layout_height=\"1px\" android:background=\"#000000\"/&gt; 布局使用RelativeLayout+LinearLayout的weight属性搭配使用相对布局广告弹出框 Demo12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/RelativeLayout1\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#00CCCCFF\"&gt; &lt;ImageView android:id=\"@+id/img1\" android:background=\"#000\" android:layout_centerInParent=\"true\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" /&gt; &lt;ImageView android:id=\"@+id/imgCancle\" android:layout_alignRight=\"@id/img1\" android:layout_alignTop=\"@id/img1\" android:background=\"#5555\" android:layout_marginTop=\"-15dp\" android:layout_marginRight=\"-10dp\" android:layout_width=\"28dp\" android:layout_height=\"28dp\" /&gt;&lt;/RelativeLayout&gt; 表格布局帧布局 FrameLayout android:foreground:设置改帧布局容器的前景图像 android:foregroundGravity:设置前景图像显示的位置 网格布局 GridLayout 默认每个组件都是占一行一列 通过android:layout_rowSpan与android:layout_columnSpan设置了组件横跨多行或者多列的话，如果你要让组件填满横越过的行或列的话，需要添加android:layout_gravity = &quot;fill&quot; 低版本 sdk 如何使用 GridLayout&lt;android.support.v7.widget.GridLayout&gt;，v7包一般在sdk下的sdk\\extras\\android\\support\\v7\\gridlayout目录下 几个单位 dp(dip): device independent pixels(设备独立像素)，不同设备有不同的显示效果，这个和设备硬件有关，一般我们为了支持 WVGA、HVGA 和 QVGA 推荐使用这个，不依赖像素 px: pixels(像素)，不同设备显示效果相同，一般我们 HVGA 代表 320x480 像素，这个用的比较多 pt: point，是一个标准的长度单位，1pt ＝ 1/72 英寸，用于印刷业，非常简单易用 sp: scaled pixels(放大像素)，主要用于字体显示 best for textsize 布局层次越少，性能越好设置的 drawable 并不能自行设置大小，在 XML 是无法直接设置的，所以需要在 Java 代码中来进行修改","categories":[],"tags":[]},{"title":"一图看懂React diff","slug":"yuque/一图看懂React diff","date":"2020-04-05T00:56:41.000Z","updated":"2020-06-07T13:19:51.060Z","comments":true,"path":"2020/04/05/yuque/一图看懂React diff/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/一图看懂React diff/","excerpt":"","text":"React 中最值得称道的部分莫过于 Virtual DOM 与 diff 的完美结合，特别是其高效的 diff 算法，让用户可以无需顾忌性能问题而”任性自由”的刷新页面，让开发者也可以无需关心 Virtual DOM 背后的运作原理，因为 React diff 会帮助我们计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行实际 DOM 操作，而非重新渲染整个页面，从而保证了每次操作更新后页面的高效渲染，因此 Virtual DOM 与 diff 是保证 React 性能口碑的幕后推手。 1 diff 策略 Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构 对于同一层级的一组子节点，它们可以通过唯一 id 进行区分 以上三个策略，React 分别对 tree diff、component diff 以及 element diff 进行算法优化，事实也证明这三个前提策略是合理且准确的，它保证了整体界面构建的性能。 2 tree diff基于策略一，React 对树的算法进行了简洁明了的优化，即对树进行分层比较，两棵树只会对同一层次的节点进行比较。 既然 DOM 节点跨层级的移动操作少到可以忽略不计，针对这一现象，React 通过 updateDepth 对 Virtual DOM 树进行层级控制，只会对相同颜色方框内的 DOM 节点进行比较，即同一个父节点下的所有子节点。当发现节点已经不存在，则该节点及其子节点会被完全删除掉，不会用于进一步的比较。这样只需要对树进行一次遍历，便能完成整个 DOM 树的比较。 如果出现 dom 节点跨层级的移动操作，因为该节点已经不在原来的 dom 树层， 所以会直接删除该节点，在移动后的 dom 层重建该节点， 可见这种操作的性能代价非常大，所以不推荐这样做。 可以通过 css 样式控制节点的隐藏和显示来代替节点跨层级移动的操作。 3 component diffReact 是基于组件构建应用的，对于组件间的比较所采取的策略也是简洁高效。 如果是同一类型的组件，按照原策略继续比较 virtual DOM tree。 如果不是，则将该组件判断为 dirty component，从而替换整个组件下的所有子节点。 对于同一类型的组件，有可能其 Virtual DOM 没有任何变化，如果能够确切的知道这点那可以节省大量的 diff 运算时间，因此 React 允许用户通过 shouldComponentUpdate() 来判断该组件是否需要进行 diff。 如下图，当 component D 改变为 component G 时，即使这两个 component 结构相似，一旦 React 判断 D 和 G 是不同类型的组件，就不会比较二者的结构，而是直接删除 component D，重新创建 component G 以及其子节点。虽然当两个 component 是不同类型但结构相似时，React diff 会影响性能，但正如 React 官方博客所言：不同类型的 component 是很少存在相似 DOM tree 的机会，因此这种极端因素很难在实现开发过程中造成重大影响的。 4 element diff当节点处于同一层级时，React diff 提供了三种节点操作，分别为：INSERT_MARKUP（插入）、MOVE_EXISTING（移动）和 REMOVE_NODE（删除）。 INSERT_MARKUP，新的 component 类型不在老集合里， 即是全新的节点，需要对新节点执行插入操作。 MOVE_EXISTING，在老集合有新 component 类型，且 element 是可更新的类型，generateComponentChildren 已调用 receiveComponent，这种情况下 prevChild=nextChild，就需要做移动操作，可以复用以前的 DOM 节点。 REMOVE_NODE，老 component 类型，在新集合里也有，但对应的 element 不同则不能直接复用和更新，需要执行删除操作，或者老 component 不在新集合里的，也需要执行删除操作。 开发者对同一层级的子节点，可以添加唯一索引进行区分，这样在 diff 时，涉及到只是位置变化的，可以只移动元素，避免删除创建等重复的操作。","categories":[],"tags":[]},{"title":"我的博客目录","slug":"yuque/我的博客目录","date":"2020-04-05T00:56:36.000Z","updated":"2020-06-07T13:19:51.128Z","comments":true,"path":"2020/04/05/yuque/我的博客目录/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/我的博客目录/","excerpt":"","text":"title: 我的博客目录date: 2019年04月08日 00:27:43categories: Careertypora-root-url: ..typora-copy-images-to: ../images JavaScript 简介 汇总 变量类型和计算1. 内置类型 2. typeof 3. 类型转换 转 Boolean 对象转基本类型 四则运算符 ==操作符 比较运算符 原型与原型链1. new 2. instanceof 闭包和作用域1. 执行上下文 2. this 3. call, apply, bind 区别 模拟实现 call 和 apply 异步和单线程其它1. 日期 2. Math 3. 常用 API JS-Web-API1. DOM 2. BOM ES6深浅拷贝1. 浅拷贝 2. 深拷贝 模块化1. CommonJS 2. AMD 防抖节流继承Promise 实现Generator 实现Map、FlapMap 和 Reduceasync 和 awaitProxy为什么 0.1 + 0.2 != 0.3正则表达式1. 元字符 2. 修饰语 3. 字符简写 Browser 事件机制 事件触发三阶段 注册事件 事件代理 跨域 JSONP CORS document.domain postMessage Event loop Node 中的 Event loop 浏览器中的 Event loop 存储 cookie, localStorage, sessionStorage, indexDB Service Worker 渲染机制 Load 和 DOMContentLoaded 区别 图层 重绘(Repaint)和回流(Reflow) 减少重绘和回流 Performance 网络相关- DNS 预解析 - 缓存 - 强缓存 - 协商缓存 - Last-Modifhed和If-Modifhed-Since - ETag和If-None-Match - 选择合适的缓存策略 - 使用 HTTP/2.0 - 预加载 - 预渲染 优化渲染过程 懒执行 懒加载 文件优化- 图片优化 计算图片大小 图片加载优化- 其他文件优化 - CDN 其他 使用 Webpack 优化项目 监控 Safety XSS 如何攻击 如何防御 CSP CSRF- 如何攻击 - 如何预防 SameSite 验证 Referer Token 密码安全 加盐 Framework 通识- MVVM 脏数据检测 数据劫持 Proxy 与 Obeject.defineProperty 对比- Virtual Dom 为什么需要 Virtual Dom Virtual Dom 算法简述 Virtual Dom 算法实现 Vue 生命周期分析 NextTick 原理分析 React 生命周期分析 V16 生命周期函数用法建议 setState Redux 源码分析 Network UDP 不可靠性 面向报文 高效 传输方式 TCP- 头部 - 状态机 建立连接三次握手 断开链接四次握手- ARQ 协议 停止等待 ARQ 连续 ARQ 累计确认- 滑动窗口 Zero 窗口- 拥塞处理 慢开始算法 拥塞避免算法 快速重传 TCP New Ren 改进后的快恢复 HTTP Post 和 Get 的区别 常见状态码 HTTP 首部 HTTPS TLS HTTP 2.0 二进制传输 多路复用 Header 压缩 服务端 Push QUIC DNS从输入 URL 到页面加载完成的过程DataStruct 栈队列链表树Trie并查集堆Algorithm 时间复杂度位运算 左移&lt;&lt; 算数右移&gt;&gt; 按位操作 排序 冒泡排序 插入排序 选择排序 归并排序 快排 堆排序 系统自带排序实现 链表 反转单向链表 树 二叉树的先序，中序，后序遍历 中序遍历的前驱后继节点 树的深度 动态规划 斐波那契数列 0-1 背包问题 最长递增子序列 Git RebasestashreflogresetCareer 花时间补基础，读文档学会搜索学点英语画个图，想一想再做利用好下班时间学习列好 ToDo反思和整理","categories":[],"tags":[]},{"title":"软件工程项目管理体系","slug":"yuque/软件工程项目管理体系","date":"2020-04-05T00:56:31.000Z","updated":"2020-06-07T13:19:51.130Z","comments":true,"path":"2020/04/05/yuque/软件工程项目管理体系/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/软件工程项目管理体系/","excerpt":"","text":"image.png","categories":[],"tags":[]},{"title":"如何写好论文","slug":"yuque/如何写好论文","date":"2020-04-05T00:56:26.000Z","updated":"2020-06-07T13:19:51.188Z","comments":true,"path":"2020/04/05/yuque/如何写好论文/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/如何写好论文/","excerpt":"","text":"1 题名要精练准确地表达最核心的内容题名、摘要、论文这 3 项，首先是论文要好，学术质量要高，这一点毫无疑问。然而论文好而不被收录，这也屡见不鲜。 2002 年没被检索的 4 篇学报论文中，有 3 篇是国家自然科学基金项目资助论文，从专家评审意见看，学术质量是高的；2004 年第 1 期的第 1 篇文章《基于整形小波变换的零树编码算法的改进》，也是学术水平很高的，但钟先生第 1 眼看到“??的改进”这一题名，就马上反映：学术水平不高，不会收录。当作为计算机专家的钟先生仔细阅读了全文后，却认为它是前 3 篇最好的，并提议将题名改为《用整形小波变换简化零树编码算法》。经与作者沟通，也认为改后的题名，能够更加精练准确地表达文章最核心的内容，更加吸引人，改得好。此外，钟先生还指出，20 篇论文题名中，有 2 篇为“XX 的研究”，4 篇为“XX 的应用”。 这些论文的题名，往往不会引起 EI 收录人员的兴趣。所以从这个角度说，论文题名是题名、摘要、论文这 3 项的重中之重，被读者看到的机会最多，可称为画龙点睛之笔，决定整篇论文的命运：这一笔写得有神，可吸引读者进一步读下去，收录利用和引用其成果；否则就再没有被光顾利用的机会。 2 摘要中 4 项内容都不能缺摘要的 4 项是指：目的、方法和过程、结果、结论。 摘要应有独立性和自含性，是一个独立的短文，即不阅读文献全文，就能获得必要的信息。其中要突出创新点，把创新点写清楚了，其引用率必然会高。钟先生指出，第 1 期 20 篇论文摘要中，半数以上没有写目的，有的没有写明方法和过程，有的没有写结果和结论，或结果只有形容词的叙述而没有量化。有的中文摘要虽写了出来，但英文没有翻译，还等于没写。 例如，第 1 篇论文，中文摘要虽写明了研究目的，但英文没有翻译出来；其结果“使零树编码在整形小波中得到高效应用”中的“高效”没有量化。这些残缺不全的摘要，不能清楚、准确地把文章的核心内容表达出来。尽管一些文章内容很好，但由于英文摘要没有认真写好，将没有机会被 EI 收录，这是很可惜、很遗憾的。 所以作者在完成一篇优秀的学术论文的同时，下大力气写好中英文摘要，一点也不为过。用钟先生的话说，英文摘要应该是：可读通俗、精练准确、清晰紧凑、客观完整，语言有逻辑性，不要太专业化。能用最少的词，清楚、准确地把最核心的内容表达出来。 3 要有最新的一定数量的参考文献文后是否有与该文相关的、一定数量的、最新的和标注准确的期刊论文作参考文献，往往被看作是衡量作者吸纳这一领域最新科研成果能力的大小，研究学问的态度是否科学严谨和该论文是否有创新性的标志，不容忽视。 在学报的审稿过程中发现，有的看起来不错，但评审意见认为没有创新性的论文，往往都是文后参考文献偏少、不新，或多为教科书。在某一层面反映了作者对新的学术成果没有研究和吸纳，对旧的东西没有比较，其论文的创新性自然也不会凸现出来。 据统计，国际期刊篇均引文数为 28 条。国内期刊则仅为 6.99 ～ 14 条。学报第 1 期篇均引文数为 8.45 条，还是有一定差距的。刊物的影响因子，被引用频次是通过对参考文献的统计得到的，因此参考文献的正确标引，在某种程度上表明了一篇论文，一个刊物的学术水平，进而也在一定程度上反映了一个国家的学术水平。 要想被 EI 核心库收录，学报的作者和编辑一定要重视学报论文参考文献的正确著录，严格遵循“著录直接引用文献，最必要、最主要、最新的文献和正式出版的文献”的著录原则，并把中文和其他非英文的参考文献，准确地翻译成英文(EI 对非英文参考文献超过 50 的论文不予收录)，让中外读者和文献统计调查人员能够通过对学报论文后参考文献的检索，方便地进入国际联机检索系统。否则将有损于学报及作者本人的声誉。 4 用清楚的语言介绍自己的研究成果提纲挈领，摘要写好了，写文章的思路就清晰了。 IMRAD (Introduction，Methods，Results And Discussions)结构包括 Introduction 为什么提出这个问题（背景） 要研究的问题是什么 为什么要做这个研究（意义） Methods 描述研究的方法 试验手段和材料（技术） Results And Discussions 结果是什么 得到了什么结论 这 3 部分就分别对应摘要中的目的、方法和过程、结果和结论。与文学作品及政治论述不同，科学论文要使用准确的语言来论述，文风要简洁、结果要量化，自己的工作和成果要说清楚。即“要有创新性”，不能把已有的成果与自己的混为一谈，否则有侵犯他人著作权之嫌。","categories":[],"tags":[]},{"title":"认识并使用 Promise","slug":"yuque/认识并使用 Promise","date":"2020-04-05T00:56:21.000Z","updated":"2020-06-07T13:19:51.221Z","comments":true,"path":"2020/04/05/yuque/认识并使用 Promise/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/认识并使用 Promise/","excerpt":"","text":"1 什么是 PromisePromise 是一个异步操作返回的对象，用来传递异步操作的消息。 可以解决的问题： 解决了回调地狱问题，不会导致难以维护； 合并多个异步请求，节约时间。 Promise 有三种状态： Pending Promise 对象实例创建时的初始态； Fulfilled 成功时的状态； Rejected 失败时的状态。 2 使用 PromisePromise.then()：用来指定 Promise 对象的状态改变时要执行的操作。 12345678910111213let promise = new Promise(function (resolve, reject) &#123; resolve(\"成功\"); //reject('失败');&#125;);promise.then( function (data) &#123; console.log(\"data: \", data); &#125;, function (err) &#123; console.log(\"err: \", err); &#125;); Promise.all()：接收一个数组，数组内是 Promise 实例，必须都成功呢才表示成功。 Promise.race()：接收一个数组，数组内是 Promise 实例，最早返回的对象成功了，就变为成功态，如果失败了，就改变状态为失败态。 123456789101112131415161718192021222324252627let fs = require(\"fs\");function read(url) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(url, \"utf8\", function (err, data) &#123; if (err) reject(err); resolve(data); &#125;); &#125;);&#125;Promise.all([read(\"1.txt\"), read(\"2.txt\")]).then( function (data) &#123; console.log(data); &#125;, function (err) &#123; console.log(\"err: \", err); &#125;);Promise.race([read(\"1.txt\"), read(\"2.txt\")]).then( function (data) &#123; console.log(data); &#125;, function (err) &#123; console.log(\"err: \", err); &#125;); Promise.resolve()：返回一个 Promise 实例，这个 Promise 实例处于 resolve 状态。 123Promise.resolve([1, 2, 3]).then(function (data) &#123; console.log(data);&#125;); 输出：[ 1, 2, 3 ] Promise.reject()：返回一个 Promise 实例，这个 Promise 实例处于 reject 状态。 123Promise.reject([1, 2, 3]).then(null, function (err) &#123; console.log(\"err\", err);&#125;); 输出：err [ 1, 2, 3 ]","categories":[],"tags":[]},{"title":"前端开发笔记","slug":"yuque/前端开发笔记","date":"2020-04-05T00:56:16.000Z","updated":"2020-06-07T13:19:51.380Z","comments":true,"path":"2020/04/05/yuque/前端开发笔记/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/前端开发笔记/","excerpt":"","text":"title: 前端开发笔记 date: 2019 年 04 月 08 日 00:27:43categories: Careertypora-root-url: ..typora-copy-images-to: ../images aria-expanded=”false” aria-expanded表示展开状态。默认为undefined, 表示当前展开状态未知。其它可选值：true表示元素是展开的；false表示元素不是展开的 aria-hidden 字符串 可选值为true和false，true表示元素隐藏(不可见)，false表示元素可见 快捷键 Ctrl + Enter 光标不在末尾回车 Ctrl + Backspace 删除一个词 Ctrl + -&gt; 以词为单位后移 col-xs-n 中放图片不生效1234img &#123; display: block; max-width: 100%;&#125; display block 默认，此元素将显示为块级元素，此元素前后会带有换行符 inline 此元素会被显示为内联元素，元素前后没有换行符 inline-block 行内块元素 使用 col 就要在母元素上清除浮动，因为 col 栅格也是浮动的使用 flag 覆盖叠加新的属性 css中使用.side-bar-card.flag {}来调用 html中用&lt;div class=&quot;side-bar-card flag clearfix&quot;&gt; a 标签链接不带下划线，并列换行写1234567a,a:hover,a:visited,a:link,a:active &#123; text-decoration: none;&#125; line-heigh 不要写 px表格居中1&lt;table align=\"center\"&gt;&lt;/table&gt; bootstrap 响应式表格1&lt;div class=\"table-responsive\"&gt;&lt;/div&gt; 表格内容水平垂直居中12345678&lt;!-- 水平居中 --&gt;&lt;th style=\"text-align: center;\"&gt;host&lt;/th&gt;&lt;!-- 垂直居中 --&gt;&lt;td rowspan=\"$row_host1\" style=\"vertical-align: middle;\"&gt;host1&lt;/td&gt;&lt;!-- 既水平又垂直居中 --&gt;&lt;td rowspan=\"$rowspan\" style=\"vertical-align: middle;text-align: center;\"&gt; hello&lt;/td&gt; 图片撑满1background-size: cover; input/select/textarea/… + .form-control.form-group 单独的表单控件会被自动赋予一些全局样式。所有设置了.form-control类的&lt;input&gt;、&lt;textarea&gt;和&lt;select&gt;元素都将被默认设置宽度属性为width: 100%;。将label元素和前面提到的控件包裹在.form-group中可以获得最好的排列 响应式表格 将任何.table元素包裹在&lt;div class=&quot;table-responsive&quot;&gt;元素内 垂直方向的内容截断 响应式表格使用了overflow-y: hidden属性，这样就能将超出表格底部和顶部的内容截断。特别是，也可以截断下拉菜单和其他第三方组件 .form-inline 输入框和单选/多选框控件默认被设置为width: 100%;。在内联表单，我们将这些元素的宽度设置为width: auto;，因此，多个控件可以排列在同一行。根据布局需求，手动设置宽度 一定要添加label标签，对于内联表单，可以通过为label设置.sr-only类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如aria-label、aria-labelledby或title属性 .form-horizontal 无需再添加.row了 margin 对 span 无效12display: block;line-height: 1.5; button 后退123&lt;button class=\"btn btn-danger ycx\" onclick=\"javascript :history.back(-1);\"&gt; 返回&lt;/button&gt; 居中 文本内容居中：text-center 图片居中：center-block 其他类型元素居中：col-md-offset-X 在 form 标签上加 novalidate 属性，可以禁用 h5 默认的表单验证效果div置顶的方法12position: relative;z-index: 99999; margin:auto 实现绝对定位元素的居中12345678910.element &#123; width: 600px; height: 400px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;&#125; ajax 中 dataType 为预期服务器返回的数据类型，不写有默认值，开发过程中不要写服务器只返回单个String类型数据，则一定要写dataType: &#39;text&#39; ajax 表单序列化传输1234567891011121314$(\"#submit\").on(\"touchstart\", function () &#123; var form = $(\"#handouts\").serialize(); $.ajax(&#123; url: \"http://192.168.1.111:8686/EAnnotation/addPassage\", type: \"post\", data: form, cache: false, success: function (data) &#123; window.location.href = \"course.html\"; &#125;, error: function (e) &#123;&#125;, &#125;); return false;&#125;); ajax 表单传递键值对12345678910111213141516171819202122$.ajax(&#123; url: ip + \"/scm\", type: \"POST\", cache: false, data: &#123; username: username, password: password, &#125;, success: function (data) &#123; console.log(1); if (data == 0) &#123; alert(\"密码错误\"); &#125; else if (data == -1) &#123; alert(\"账号不存在\"); &#125; else &#123; console.log(data); // window.location.href = \"index.html\" localStorage.name = data; &#125; &#125;, error: function (e) &#123;&#125;,&#125;); ajax 传递 formDataformData 既可以传键值对，也可以传文件 1234567891011121314151617$(\"#submit\").on(\"touchstart\", function () &#123; var form = new FormData($(\"#homework\")[0]); $.ajax(&#123; url: \"https://bitcandy.one/EAnnotation/addPassage\", type: \"POST\", cache: false, data: form, processData: false, contentType: false, success: function (data) &#123; window.location.href = \"classteacher.html\"; console.log(form); &#125;, error: function (e) &#123;&#125;, &#125;); return false;&#125;); ajax 拿到 json 后如何使用123456789101112131415161718192021222324252627282930313233343536373839404142434445$.ajax(&#123; url: \"http://192.168.1.111:8686/EAnnotation/getAllPassages\", type: \"post\", cache: false, success: function (data) &#123; console.log(data); $.each(data, function (i, item) &#123; var time = getDateDiff(item.releaseTime); if (item.photo) &#123; &#125; else &#123; $(\"ul[class=index]\").append( `&lt;div class=\"card\"&gt; &lt;div class=\"card-header\"&gt;` + item.title + `&lt;/div&gt; &lt;div class=\"card-content card-content-padding\"&gt; &lt;p class=\"date index\"&gt;` + item.theme + `·` + time + `&lt;/p&gt; &lt;a href=\"www.baidu.com\" class=\"link\" style=\"color: black\"&gt;&lt;p style=\"margin-top: 0; margin-bottom: 0;\"&gt;` + getcontent(item.content).substring(0, 70) + ` ...&lt;/p&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"card-footer\"&gt; &lt;a href=\"#\" class=\"link\" style=\"color\"&gt; &lt;i class=\"f7-icons size-18\"&gt;heart_fill&lt;/i&gt;` + 1 + `喜欢&lt;/a&gt; &lt;a href=\"#\" class=\"link\"&gt; ` + 22 + `人批注过，共计` + 44 + `条批注 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;` ); &#125; &#125;); &#125;, error: function (e) &#123;&#125;,&#125;); 多行文字限制字数显示…1234567.text_overflow &#123; /* width:27rem; */ display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;&#125; 单行文字限制字数显示…1234567.text_overflow &#123; width: 27em; white-space: nowrap; text-overflow: ellipsis; -o-text-overflow: ellipsis; overflow: hidden;&#125; 从 html 代码中获取纯文本函数1234function getcontent(text) &#123; var html = text; return html.replace(/&lt;[^&gt;]*&gt;|/g, \"\");&#125; 时间戳转化函数1234567891011121314151617181920212223242526272829303132333435363738// 2014-05-08 00:22:11function getDateDiff(dateTimeStamp) &#123; var dateTimeStamp = new Date(Date.parse(dateTimeStamp.replace(/-/g, \"/\"))); dateTimeStamp = dateTimeStamp.getTime(); var result; var minute = 1000 * 60; var hour = minute * 60; var day = hour * 24; var halfamonth = day * 15; var month = day * 30; var now = new Date().getTime(); var diffValue = now - dateTimeStamp; if (diffValue &lt; 0) &#123; return; &#125; var monthC = diffValue / month; var weekC = diffValue / (7 * day); var dayC = diffValue / day; var hourC = diffValue / hour; var minC = diffValue / minute; if (monthC &gt;= 1) &#123; if (monthC &lt;= 12) result = \"\" + parseInt(monthC) + \"个月前\"; else &#123; result = \"\" + parseInt(monthC / 12) + \"年前\"; &#125; &#125; else if (weekC &gt;= 1) &#123; result = \"\" + parseInt(weekC) + \"周前\"; &#125; else if (dayC &gt;= 1) &#123; result = \"\" + parseInt(dayC) + \"天前\"; &#125; else if (hourC &gt;= 1) &#123; result = \"\" + parseInt(hourC) + \"小时前\"; &#125; else if (minC &gt;= 1) &#123; result = \"\" + parseInt(minC) + \"分钟前\"; &#125; else &#123; result = \"刚刚\"; &#125; return result;&#125; js 变量生命周期 全局变量 12345var n = 999;function f1() &#123; alert(n);&#125;f1(); // 输出999,说明全局变量n在函数内部被读取 函数中的全局变量：在函数内部声明变量没有使用var，实际上是声明了一个全局变量，前提是需要先调用函数 12345678910111213var func1 = function()&#123; a1 = 1; console.log(a1); //输出:1 function func2() &#123;//func2()是一个闭包 a2 = 2; console.log(a2); &#125; func2()；//闭包函数中的变量在调用函数之后，变量也是全局变量 console.log(a2);//输出2&#125;;func1();//调用函数，才会使变量生效console.log(a1);//输出1console.log(a2);//输出2，说明闭包中没有用var声明的变量也是全局变量。 局部变量：在函数内部声明的变量。函数内部的变量，外部无法读取。 1234function f1() &#123; var n = 999;&#125;alert(n); // 没有定义，说明函数内部的变量，外部无法读取。 JavaScript解释器在执行脚本时，是按块来执行的。通俗地说，就是浏览器在解析HTML文档流时，如果遇到一个&lt;script&gt;标签，则JavaScript解释器会等到这个代码块都加载完后，先对代码块进行预编译，然后再执行。执行完毕后，浏览器会继续解析下面的HTML文档流，同时JavaScript解释器也准备好处理下一个代码块。由于JavaScript是按块执行的，所以如果在一个JavaScript块中调用后面块中声明的变量或函数就会提示语法错误。虽然说，JavaScript是按块执行的，但是不同块都属于同一个全局作用域，也就是说，块之间的变量和函数是可以共享的。 jquery 获取 radio 被选中的值 三种方法都可以 123$('input:radio:checked').val()；$(\"input[type='radio']:checked\").val();$(\"input[name='rd']:checked\").val(); jquery 获取 select 被选中的值 获取选中项的value值 123$(\"select#sel option:selected\").val();或者;$(\"select#sel\").find(\"option:selected\").val(); 获取选中项的text值 123$(\"select#seloption:selected\").text();或者;$(\"select#sel\").find(\"option:selected\").text(); 获取当前选中项的索引值 1$(\"select#sel\").get(0).selectedIndex; jquery 获取 checkbox 被选中的值 获取单个checkbox选中项 12345$(\"input:checkbox:checked\").val();或者;$(\"input:[type='checkbox']:checked\").val();或者;$(\"input:[name='ck']:checked\").val(); 获取多个checkbox选中项 123$(\"input[name='favour']:checked\").each(function () &#123; alert($(this).val());&#125;); jquery 获取 span 和 input 的值12$(\"span\").html();$(\"input\").val(); jquery 数组对象获取 value 值 需将数组对象再次封装为jquery对象 12345// 错误$(\"input[name='jQueryArray']\")[0].val();// 正确$($(\"input[name='jQueryArray']\")[0]).val();0; this 必须用\\$包装成 JQuery 对象才能使用用 let 和 const 的声明可以产生块级作用域，解决闭包循环事件绑定1234567for (var i = 0; i &lt; 2; i++) &#123; let ii = i; //const也可以，块级作用域 var bt = document.getElementById(\"bt\" + ii); bt.onclick = function () &#123; console.log(ii); &#125;;&#125; JavaScript 中有 5 种简单数据类型（也称为基本数据类型）： Undefined、Null、Boolean、Number 和 String 。还有 1 种复杂数据类型—— Object ，Object 本质上是由一组无序的名值对组成的。backgroundColor 要加.style 属性设置元素的背景颜色；bgcolor 不用加.stylejson 中 key 也是个字符串，要加引号，key 和 value 之间是用:号来表示的CSS 样式表和选择器 CSS 和 HTML 结合的三种方式：行内样式表、内嵌样式表、外部样式表 CSS 四种基本选择器：标签选择器、类选择器、ID 选择器、通用选择器 CSS 几种扩展选择器：后代选择器、交集选择器、并集选择器、伪类选择器","categories":[],"tags":[]},{"title":"跨域问题","slug":"yuque/跨域问题","date":"2020-04-05T00:56:11.000Z","updated":"2020-06-07T13:19:51.561Z","comments":true,"path":"2020/04/05/yuque/跨域问题/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/跨域问题/","excerpt":"","text":"title: 跨域问题 date: 2019 年 04 月 08 日 00:27:43categories: Browsertypora-root-url: ..typora-copy-images-to: ../images 什么是同源策略通常来说，浏览器出于安全方面的考虑，只允许与本域下的接口交互。不同源的客户端脚本在没有明确授权的情况下，不许读写对方的资源，本域指的是 同协议：比如都是 http 或者 https 同域名：比如都是 http://baidu.com/a 和 http://baidu.com/b 同端口：比如都是 80 端口 同源 http://baidu.com/a/b.js 和 http://baidu.com/index.php 不同源 http://baidu.com/main.js 和 https://baidu.com/a.php 协议不同 http://baidu.com/main.js 和 http://bbs.baidu.com/a.php 域名不同，域名必须完全相同才可以 http://baidu.com/main.js 和 http://baidu.com:8080/a.php 端口不同，第一个默认是 80 对于当前页面来说页面存放 JS 文件的域不重要，重要的是加载该 JS 的页面所在什么域 什么是跨域 在 JavaScript 中，有一个很重要的安全性限制，被称为“Same-Origin Policy”（同源策略）。这一策略对于 JavaScript 代码能够访问的页面内容做了很重要的限制，即 JavaScript 只能访问与包含它的文档在同一域下的内容 JavaScript 的同源策略在进行多 iframe 或多窗口编程、以及 Ajax 编程时显得尤为重要 根据这个策略，在 baidu.com 下的页面中包含的 JavaScript 代码，不能访问在 google.com 域名下的页面内容 不同的子域名之间的页面也不能通过 JavaScript 代码互相访问 对于 Ajax 的影响在于，通过 XMLHttpRequest 实现的 Ajax 请求，不能向不同的域提交请求，例如，在 abc.example.com 下的页面，不能向 def.example.com 提交 Ajax 请求 注意要点 如果是协议和端口造成的跨域问题前台是无能为力的 在跨域问题上，域仅仅是通过URL 的首部来识别而不会去尝试判断相同的 IP 地址对应着两个域或两个域是否在同一个 ip 上。比如http://www.a.com/a.js和http://70.32.92.74/b.js，虽然域名和域名的 ip 对应，不过还是被认为是跨域 URL 的首部指 window.location.protocol +window.location.host，其中 window.location.protocol：含有 URL 第一部分的字符串，如：http: window.location.host：包含有 URL 中主机名 + 端口号 + 部分的字符串，如：//www.cenpok.net/server/ 为什么要实现同源限制 比如一个黑客，他利用 iframe 把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名和密码登录时，如果没有同源限制，他的页面就可以通过 JavaScript 读取到你的表单中输入的内容，这样用户名和密码就轻松到手了 又比如你登录了 OSC，同时浏览了恶意网站，如果没有同源限制，该恶意网站就可以构造 Ajax 请求频繁在 OSC 发广告帖 常用的跨域处理方法JSONP(JSON with padding)原理在页面上有三种资源是可以与页面本身不同源的 js 脚本 css 样式文件 图片 像淘宝等大型网站，肯定会将这些静态资源放入 cdn 中，然后在页面上连接，如下所示，所以它们是可以链接访问到不同源的资源的 &lt;script type=&quot;text/javascript&quot; src=&quot;某某cdn地址&quot; &gt;&lt;/script&gt; &lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;某个cdn地址&quot; /&gt; &lt;img src=&quot;某个cdn地址&quot; alt=&quot;&quot;/&gt; 而 jsonp 就是利用了script 标签的src 属性是没有跨域的限制的，从而达到跨域访问的目的。因此它的最基本原理就是：动态添加一个&lt;script&gt;标签来实现 实现方法我们使用 Ajax 来请求的，看起来和 Ajax 没啥区别，其实还是有区别的 ajax 的核心是通过 XmlHttpRequest 获取非本页内容，而 jsonp 的核心则是动态添加&lt;script&gt;标签来调用服务器提供的 js 脚本 123456789$.ajax(&#123; url: \"http://crossdomain.com/services.php\", dataType: \"jsonp\", data: \"\", jsonp: \"callback\", success: function (result) &#123; // some code &#125;,&#125;); 上面的代码中，callback 是必须的，callback 是什么值要跟后台拿。获取到的 jsonp 数据格式如下 12345flightHandler(&#123; code: \"CA1998\", price: 1780, tickets: 5,&#125;); jsonp 的全称为 json with padding，上面的数据中，flightHandler 就是那个 padding 优缺点优点 不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持 在请求完毕后可以通过调用 callback 的方式回传结果 缺点 只能使用 get 方法，不能使用 post 方法 script，link, img 等标签引入外部资源，都是 get 请求的，那么就决定了 jsonp 一定是 get 请求 但有时候我们使用的 post 请求也成功，这是因为当我们指定dataType: &#39;jsonp&#39;，不论你指定type: &quot;post&quot;或者type: &quot;get&quot;，其实质上进行的都是 get 请求 没有关于 JSONP 调用的错误处理 如果动态脚本插入有效，就执行调用 如果无效，就静默失败 失败是没有任何提示的 例如，不能从服务器捕捉到 404 错误，也不能取消或重新开始请求 只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题 CORS 策略原理 CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 Ajax 只能同源使用的限制 CORS 系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，但比起简单地允许所有这些的要求来说更加安全 实现方法 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与 对于开发者来说，CORS 通信与同源的 Ajax 通信没有差别，代码完全一样 浏览器一旦发现 A 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉 前端实现 以前我们使用 Ajax，使用如下代码 1234var xhr = new XMLHttpRequest();xhr.open(\"GET\", \"/hfahe\", true);xhr.send();// 这里的“/hfahe”是本域的相对路径。 如果我们要使用 CORS，使用如下代码 1234var xhr = new XMLHttpRequest();xhr.open(\"GET\", \"http://blog.csdn.net/hfahe\", true);xhr.send();// 请注意，代码与之前的区别就在于相对路径换成了其他域的绝对路径，也就是你要跨域访问的接口地址 服务器方面 服务器端对于 CORS 的支持，主要就是通过设置 Access-Control-Allow-Origin 来进行的。如果浏览器检测到相应的设置，就可以允许 Ajax 进行跨域的访问 优缺点：优点 CORS 支持所有类型的 HTTP 请求 使用 CORS，开发者可以使用普通的 XMLHttpRequest 发起请求和获得数据，比起 JSONP 有更好的错误处理 缺点 兼容性方面相对差一点，IE10+才支持 document.domain+iframe只有在主域相同的时候才能使用该方法 原理 浏览器中不同域的框架之间是不能进行 js 的交互操作的，但是不同的框架之间（父子或同辈），是能够获取到彼此的 window 对象的，但是，我们也只能获取到一个几乎无用的 window 对象 比如，有一个页面，它的地址是 http://www.example.com/a.html ， 在这个页面里面有一个 iframe，它的 src 是 http://example.com/b.html , 很显然这个页面与它里面的 iframe 框架是不同域的，所以我们是无法通过在页面中书写 js 代码来获取 iframe 中的东西的 这个时候，document.domain 就可以派上用场了，我们只要把http://www.example.com/a.html 和 http://example.com/b.html 这两个页面的 document.domain 都设成相同的域名就可以了 但要注意的是，document.domain 的设置是有限制的，我们只能把 document.domain 设置成自身或更高一级的父域，且主域必须相同。例如：a.b.example.com 中某个文档的 document.domain 可以设成 a.b.example.com、b.example.com 、example.com 中的任意一个，但是不可以设成 c.a.b.example.com，因为这是当前域的子域，也不可以设成 baidu.com， 因为主域已经不相同了 实现方法比如在 http://www.example.com/a.html 的页面里要访问 http://example.com/b.html 里面的东西，则在页面 http://www.example.com/a.html 中设置 document.domain 1234567891011121314151617181920212223// http://www.example.com/a.html&lt;html&gt;&lt;head&gt; &lt;title&gt;A页面&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;A页面&lt;/div&gt; &lt;iframe id=\"iframe\" src=\"http://example.com/b.html\" style=\"display:none;\"&gt;&lt;/iframe&gt; // 相当于用一个隐藏的iframe来做代理 &lt;script&gt; $(function()&#123; try&#123; document.domain = \"example.com\"; // 这里将document.domain设置成一样 &#125;catch(e)&#123;&#125; $(\"#iframe\").load(function()&#123; var iframe = $(\"#iframe\").contentDocument.$; iframe.get(\"http://example.com/接口\", function(data)&#123;&#125;); &#125;); &#125;); &lt;/script&gt;&lt;body&gt;&lt;/html&gt; 在页面 http://example.com/b.html 中也设置 document.domain，而且这也是必须的，虽然这个文档的 domain 就是 example.com，但是还是必须显示的设置 document.domain 的值 1234567891011121314151617// http://example.com/b.html&lt;html&gt; &lt;head&gt; &lt;title&gt;B页面&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"jquery.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;B页面&lt;/div&gt; &lt;script&gt; $(function () &#123; try &#123; document.domain = \"example.com\"; // 这里将document.domain设置成一样 &#125; catch (e) &#123;&#125; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ⚠️ 注意 在 A 页面中，要等 iframe 标签完成加载 B 页面之后，再取 iframe 对象的 contentDocument，否则如果 B 页面没有被 iframe 完全加载，在 A 页面中通过 contentDocument 属性就取不到 B 页面中的 jQuery 对象 一旦取到 B 页面中的 jQuery 对象，就可以直接发 Ajax 请求了，这种类似“代理”方式可以解决主子域的跨域问题。 优缺点只有在主域相同的时候才能使用该方法 HTML5 postMessage原理 一个 html5 所提供的一个 API，HTML5 window.postMessage 是一个安全的、基于事件的消息 API 在需要发送消息的源窗口调用 postMessage 方法即可发送消息 源窗口可以是全局的 window 对象，也可以是以下类型的窗口 文档窗口中的 iframe: 12var iframe = document.getElementById(\"my-iframe\");var win = iframe.documentWindow; JavaScript 打开的弹窗： 1var win = window.open(); 当前文档窗口的父窗口： 1var win = window.parent; window.opener() 1var win = window.opener(); 发送消息 找到源 window 对象后，即可调用 postMessage API 向目标窗口发送消息 1win.postMessage(msg, targetOrigin); 说明 postMessage 函数接收 2 个参数 msg：将要发送的消息，可以是一切 JavaScript 参数，如字符串，数字，对象，数组等 targetOrigin：这个参数称作“目标域”，⚠️ 注意，是目标域不是本域！比如，你想在 2.com 的网页上往 1.com 网页上传消息，那么这个参数就是 http://1.com/ ，而不是 2.com 协议 一个完整的域名包括：主机名，端口号，如：http://g.cn:80/ 接收消息 只要监听 window 的 message 事件就可以接收了 1234567891011var onmessage = function (event) &#123; var data = event.data; var origin = event.origin; //do someing&#125;;if (typeof window.addEventListener != \"undefined\") &#123; window.addEventListener(\"message\", onmessage, false);&#125; else if (typeof window.attachEvent != \"undefined\") &#123; //for ie window.attachEvent(\"onmessage\", onmessage);&#125; message 事件监听函数接收一个参数，Event 对象实例，该对象有 3 个属性 data：消息 origin：消息的来源地址 source：发送消息窗口的 window 对象引用 实现方法http://test.com/index.html 发送消息的页面 123456789&lt;div&gt; &lt;!-- 要给下面的页面传一个妹子过去 --&gt; &lt;iframe id=\"child\" src=\"http://lsLib.com/lsLib.html\"&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function () &#123; window.frames[0].postMessage(\"苍老师\", \"http://lslib.com\"); &#125;;&lt;/script&gt; http://lslib.com/lslib.html 接收消息的页面 123456&lt;script type=\"text/javascript\"&gt; window.addEventListener(\"message\", function (e) &#123; console.log(e.origin, e.data); alert(\"收到妹子一枚：\" + e.data); &#125;);&lt;/script&gt; 优缺点优点 方便，安全，有效的解决了跨域问题 是 html5 新引进的特性，可以使用它来向其它的 window 对象发送消息，无论这个 window 对象是属于同源或不同源 目前 IE8+、FireFox、Chrome、Opera 等浏览器都已经支持 window.postMessage 方法。如果是现代浏览器，首选 缺点 IE8+才支持，而且 IE8+&lt;IE10 只支持 iframe 的方式 window.name 属性相对比较完美的方法 原理 当 iframe 的页面跳到其他地址时，其 window.name 值保持不变，并且可以支持非常长的 name 值（2MB） 浏览器跨域 iframe 禁止互相调用/传值，但是调用 iframe 时 window.name 却不变，正是利用这个特性来互相传值，当然跨域下是不容许读取 ifram 的 window.name 值 实现方法 准备三个页面 http://www.a.com/main.html 应用页面 http://www.a.com/other.html 代理页面，要求和应用页面在同一个域，一般是一个空的 html http://www.b.com/data.html 应用页面获取数据的页面，简称：数据页面 数据页面将数据传到 window.name 中去 http://www.b.com/data.html 中的 data.html 12// 可以是其他类型的数据，比如数组，对象等等window.name = \"苍老师\"; http://www.a.com/main.html 应用页面 获取数据以后销毁这个 iframe，释放内存；这也保证了安全（不被其他域 frame js 访问）。 123iframe.contentWindow.document.write(\"\");iframe.contentWindow.close();document.body.removeChild(iframe); 优缺点优点 主要是应用当 iframe 的页面跳到其他地址时，其 window.name 值保持不变的原理 兼容性好，需要照顾落后的浏览器时，首选 参考资料 [1]http://www.cnblogs.com/xianyulaodi/p/5755108.html","categories":[],"tags":[]},{"title":"关于事件委托的尝试","slug":"yuque/关于事件委托的尝试","date":"2020-04-05T00:56:06.000Z","updated":"2020-06-07T13:19:51.574Z","comments":true,"path":"2020/04/05/yuque/关于事件委托的尝试/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/关于事件委托的尝试/","excerpt":"","text":"1 常写代码12345ul.addEventListener(\"click\", function (e) &#123; if (e.target.tagName.toLowerCase() === \"li\") &#123; fn(); // 执行某个函数 &#125;&#125;); 之前一直用的很好，但是在某次 li 中有 span 的时候发现了 bug，如果用户点击的是 li 里面的 span，就没法触发 fn，这显然不对。 2 代码改良思路是点击 span 后，递归遍历 span 的祖先元素看其中有没有 ul 里面的 li。 1234567891011121314function delegate(element, eventType, selector, fn) &#123; element.addEventListener(eventType, (e) =&gt; &#123; let el = e.target; while (!el.matches(selector)) &#123; if (element === el) &#123; el = null; break; &#125; el = el.parentNode; &#125; el &amp;&amp; fn.call(el, e, el); &#125;); return element;&#125;","categories":[],"tags":[]},{"title":"尝试实现一个简单的Promise","slug":"yuque/尝试实现一个简单的Promise","date":"2020-04-05T00:56:01.000Z","updated":"2020-06-07T13:19:51.611Z","comments":true,"path":"2020/04/05/yuque/尝试实现一个简单的Promise/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/尝试实现一个简单的Promise/","excerpt":"","text":"1 Promise 是一个异步操作返回的对象，用来传递异步操作的消息2 根据自己对 Promise 的理解，实现一个 PromisePromise 有三种状态：Pending 初始态； Fulfilled 成功态； Rejected 失败态。 123456789101112131415161718192021222324252627282930313233343536373839function Promise(executor) &#123; let self = this; self.status = \"pending\"; //等待态 self.value = undefined; //成功的返回值 self.reason = undefined; //失败的原因 function resolve(value) &#123; if (self.status === \"pending\") &#123; self.status = \"resolved\"; self.value = value; &#125; &#125; function reject(reason) &#123; if (self.status === \"pending\") &#123; self.status = \"rejected\"; self.reason = reason; &#125; &#125; try &#123; executor(resolve, reject); &#125; catch (e) &#123; reject(e); // 捕获时发生异常，就直接失败 &#125;&#125;//onFufiled 成功的回调//onRejected 失败的回调Promise.prototype.then = function (onFufiled, onRejected) &#123; let self = this; if (self.status === \"resolved\") &#123; onFufiled(self.value); &#125; if (self.status === \"rejected\") &#123; onRejected(self.reason); &#125;&#125;;module.exports = Promise; 3 代码测试1234567891011121314let Promise = require(\"./Promise\");let promise = new Promise(function (resolve, reject) &#123; resolve(100);&#125;);promise.then( function (data) &#123; console.log(\"data:\", data); &#125;, function (err) &#123; console.log(\"err:\", err); &#125;); 输出：data: 100 Promise 实例可以多次 then，当成功后会将 then 中的成功方法按顺序执行，我们可以先将 then 中成功的回调和失败的回调存到数组内。当成功的时候调用成功的数组即可。 1234567891011121314151617181920self.onResolvedCallbacks = []; /* 存放then成功的回调*/self.onRejectedCallbacks = []; /* 存放then失败的回调*/function resolve(value) &#123; if (self.status === \"pending\") &#123; self.status = \"resolved\"; self.value = value; self.onResolvedCallbacks.forEach(function (fn) &#123; fn(); &#125;); &#125;&#125;function reject(reason) &#123; if (self.status === \"pending\") &#123; self.status = \"rejected\"; self.reason = reason; self.onRejectedCallbacks.forEach(function (fn) &#123; fn(); &#125;); &#125;&#125; 12345678if (self.status === \"pending\") &#123; self.onResolvedCallbacks.push(function () &#123; onFufiled(self.value); &#125;); self.onRejectedCallbacks.push(function () &#123; onRejected(self.reason); &#125;);&#125; 4 实现链式调用众所周知 Promise 的一大特点，就是链式调用。而 Promise 实现链式调用就是通过 then 方法返回一个新的 Promise。 如果第一个 then 中返回了一个结果，会将 Promise 的结果继续传给下一个 then 中；如果有错误则走下一个 then 的失败。 12345678910111213141516171819202122232425262728// 添加 resolvePromise 方法 处理链式调用问题function resolvePromise(p2, x, resolve, reject) &#123; if (p2 === x) &#123; return reject(new TypeError(\"循环引用\")); &#125; if (x !== null || typeof x === \"object\" || typeof x === \"function\") &#123; try &#123; let then = x.then; if (typeof then === \"function\") &#123; then.call( x, function (y) &#123; resolvePromise(promise2, y, resolve, reject); &#125;, function (err) &#123; reject(err); &#125; ); &#125; else &#123; resolve(x); &#125; &#125; catch (e) &#123; reject(e); &#125; &#125; else &#123; resolve(x); &#125;&#125;","categories":[],"tags":[]},{"title":"【Safety】简介","slug":"yuque/【Safety】简介","date":"2020-04-05T00:55:56.000Z","updated":"2020-06-07T13:19:51.743Z","comments":true,"path":"2020/04/05/yuque/【Safety】简介/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【Safety】简介/","excerpt":"","text":"title: 【Safety】简介date: 2019年04月08日 00:27:43categories: Safetytypora-root-url: ..typora-copy-images-to: ../images XSS 涉及面试题：什么是 XSS 攻击？如何防范 XSS 攻击？什么是 CSP？ XSS 是什么 XSS 简单点来说，就是攻击者想尽一切办法将可执行的代码注入到网页中 XSS 分类边界 XSS 可以分为多种类型，但是总体上认为分为两类 持久型 非持久型 持久型 XSS 是什么 持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。 EX1 对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容 这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。 EX2 在新浪博客写一篇文章，同时偷偷插入一段&lt;script&gt; 攻击代码中，获取 cookie，发送到自己的服务器 发布博客，有人查看博客内容 会把查看者的 cookie 发送到攻击者的服务器 非持久型 XSS 是什么 非持久型相比于前者危害就小的多了，一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。 举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行 12&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 非持久型 XSS 条件 但是对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。 XSS 组合 对于 XSS 攻击来说，通常有两种方式可以用来防御。 转义字符转义字符是什么 首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;') str = str.replace(/&lt;/g, '&lt;') str = str.replace(/&gt;/g, '&gt;') str = str.replace(/\"/g, '&amp;quto;') str = str.replace(/'/g, ''') str = str.replace(/`/g, '`') str = str.replace(/\\//g, '/') return str&#125; 通过转义可以将攻击代码 &lt;script&gt;alert(1)&lt;/script&gt; 变成 12// -&gt; &lt;script&gt;alert(1)&lt;/script&gt;escape(\"&lt;script&gt;alert(1)&lt;/script&gt;\"); 转义字符条件 但是对于显示富文本来说，显然不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。对于这种情况，通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。 1234const xss = require(\"xss\");let html = xss('&lt;h1 id=\"title\"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(\"xss\");&lt;/script&gt;');// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert(\"xss\");&lt;/script&gt;console.log(html); 以上示例使用了 js-xss 来实现，可以看到在输出中保留了 h1 标签且过滤了 script 标签。 CSPCSP 是什么 CSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。 CSP 组合 通常可以通过两种方式来开启 CSP： 开启 CSP 分类边界 设置 HTTP Header 中的 Content-Security-Policy 设置 meta 标签的方式 &lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt; HTTP Header 分类边界 这里以设置 HTTP Header 来举例 只允许加载本站资源 1Content-Security-Policy: default-src ‘self’ 只允许加载 HTTPS 协议图片 1Content-Security-Policy: img-src https://* 允许加载任何来源框架 1Content-Security-Policy: child-src &apos;none&apos; 当然可以设置的属性远不止这些，你可以通过查阅 文档 的方式来学习，这里就不过多赘述其他的属性了。 Tips 对于这种方式来说，只要开发者配置了正确的规则，那么即使网站存在漏洞，攻击者也不能执行它的攻击代码，并且 CSP 的兼容性也不错。 CSRF 涉及面试题：什么是 CSRF 攻击？如何防范 CSRF 攻击？ CSRF 是什么 CSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。 EX1 假设网站中有一个通过 GET 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 1&lt;img src=\"http://www.domain.com/xxx?comment='attack'\" /&gt; 那么你是否会想到使用 POST 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 POST 请求。 EX2 你已登录一个购物网站，正在浏览器商品 该网站付费接口是 xxx.com/pay?id=100 ，但是没有任何验证 然后你收到一封邮件，隐藏着&lt;img src=xxx&gt; 你查看邮件的时候，就已经悄悄的付费购买了 CSRF 组合 如何防御防范 CSRF 攻击可以遵循以下几种规则： Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 Token SameSite可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。 验证 Referer对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。 Token服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。 点击劫持 涉及面试题：什么是点击劫持？如何防范点击劫持？ 是什么 点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 对于这种攻击方式，推荐防御的方法有两种。 X-FRAME-OPTIONSX-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头就是为了防御用 iframe 嵌套的点击劫持攻击。 该响应头有三个值可选，分别是 DENY，表示页面不允许通过 iframe 的方式展示 SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示 ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示 JS 防御对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。 1234567891011121314151617&lt;head&gt; &lt;style id=\"click-jack\"&gt; html &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; if (self == top) &#123; var style = document.getElementById(\"click-jack\"); document.body.removeChild(style); &#125; else &#123; top.location = self.location; &#125; &lt;/script&gt;&lt;/body&gt; 以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。 中间人攻击 涉及面试题：什么是中间人攻击？如何防范中间人攻击？ 中间人攻击是什么 中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。 通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。 中间人攻击条件 当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。 小结 在这一章中，我们学习到了一些常见的前端安全方面的知识及如何防御这些攻击。但是安全的领域相当大，这些内容只是沧海一粟，如果大家对于安全有兴趣的话，可以阅读 这个仓库的内容 来学习和实践这方面的知识。","categories":[],"tags":[]},{"title":"【Performance】性能优化琐碎事","slug":"yuque/【Performance】性能优化琐碎事","date":"2020-04-05T00:55:51.000Z","updated":"2020-06-07T13:19:51.830Z","comments":true,"path":"2020/04/05/yuque/【Performance】性能优化琐碎事/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【Performance】性能优化琐碎事/","excerpt":"","text":"title: 【Performance】性能优化琐碎事date: 2019年04月08日 00:27:43categories: Performancetypora-root-url: ..typora-copy-images-to: ../images 图片优化 计算图片大小对于一张 100 _ 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1 个字节），所以该图片大小大概为 39KB（10000 _ 1 * 4 / 1024）。 但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。 了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了： 减少像素点 减少每个像素点能够显示的颜色 图片加载优化 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。 小图使用 base64 格式 将多个图标文件整合到一张图片中（雪碧图） 选择正确的图片格式： 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替 照片使用 JPEG DNS 预解析 DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。 1&lt;link rel=\"dns-prefetch\" href=\"//yuchengkai.cn\"&gt; 节流 考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是隔一段时间发起一次，对于这种情况我们就可以使用节流。 理解了节流的用途，我们就来实现下这个函数 1234567891011121314151617181920212223// func是用户传入需要防抖的函数// wait是等待时间const throttle = (func, wait = 50) =&gt; &#123; // 上一次执行该函数的时间 let lastTime = 0; return function (...args) &#123; // 当前时间 let now = +new Date(); // 将当前时间和上一次执行函数时间对比 // 如果差值大于设置的等待时间就执行函数 if (now - lastTime &gt; wait) &#123; lastTime = now; func.apply(this, args); &#125; &#125;;&#125;;setInterval( throttle(() =&gt; &#123; console.log(1); &#125;, 500), 1); 防抖 考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮一段时间后没有再次点击的情况才去发起网络请求，对于这种情况我们就可以使用防抖。 理解了防抖的用途，我们就来实现下这个函数 123456789101112131415// func是用户传入需要防抖的函数// wait是等待时间const debounce = (func, wait = 50) =&gt; &#123; // 缓存一个定时器id let timer = 0; // 这里返回的函数是每次用户实际调用的防抖函数 // 如果已经设定过定时器了就清空上一次的定时器 // 开始一个新的定时器，延迟执行用户传入的方法 return function (...args) &#123; if (timer) clearTimeout(timer); timer = setTimeout(() =&gt; &#123; func.apply(this, args); &#125;, wait); &#125;;&#125;; 预加载 在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载 1&lt;link rel=\"preload\" href=\"http://example.com\"&gt; 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。 预渲染 可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染 1&lt;link rel=\"prerender\" href=\"http://example.com\"&gt; 预渲染虽然可以提高页面的加载速度，但是要确保该页面大概率会被用户在之后打开，否则就是白白浪费资源去渲染。 懒执行 懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。 懒加载 懒加载就是将不关键的资源延后加载。 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。 - 传统的实现方法是，监听到scroll事件后，调用目标元素（绿色方块）的getBoundingClientRect()方法，得到它对应于视口左上角的坐标，再判断是否在视口之内。这种方法的缺点是，由于 scroll 事件密集发生，计算量很大，容易造成性能问题。 - 目前有一个新的 IntersectionObserver API，可以自动”观察”元素是否可见，Chrome 51+ 已经支持。由于可见visible的本质是，目标元素与视口产生一个交叉区，所以这个 API 叫做”交叉观察器”。 CDN CDN 的原理是尽可能的在各个地方分布机房缓存数据，这样即使我们的根服务器远在国外，在国内的用户也可以通过国内的机房迅速加载资源。 因此，我们可以将静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。并且对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量。","categories":[],"tags":[]},{"title":"【Network】HTTP 及 TLS","slug":"yuque/【Network】HTTP 及 TLS","date":"2020-04-05T00:55:46.000Z","updated":"2020-06-07T13:19:51.926Z","comments":true,"path":"2020/04/05/yuque/【Network】HTTP 及 TLS/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【Network】HTTP 及 TLS/","excerpt":"","text":"title: 【Network】HTTP 及 TLSdate: 2019年04月08日 00:27:43categories: Networktypora-root-url: ..typora-copy-images-to: ../images HTTP 请求中的内容 HTTP 请求由三部分构成，分别为： 请求行 首部 实体 请求行大概长这样 GET /images/logo.gif HTTP/1.1，基本由请求方法、URL、协议版本组成，这其中值得一说的就是请求方法了。 请求方法分为很多种，最常用的也就是 Get 和 Post 了。虽然请求方法有很多，但是更多的是传达一个语义，而不是说 Post 能做的事情 Get 就不能做了。如果你愿意，都使用 Get 请求或者 Post 请求都是可以的。更多请求方法的语义描述可以阅读 文档。 常考面试题：Post 和 Get 的区别？ 首先先引入副作用和幂等的概念。 副作用指对服务器上的资源做改变，搜索是无副作用的，注册是副作用的。 幂等指发送 M 和 N 次请求（两者不相同且都大于 1），服务器上资源的状态一致，比如注册 10 个和 11 个帐号是不幂等的，对文章进行更改 10 次和 11 次是幂等的。因为前者是多了一个账号（资源），后者只是更新同一个资源。 在规范的应用场景上说，Get 多用于无副作用，幂等的场景，例如搜索关键字。Post 多用于副作用，不幂等的场景，例如注册。 在技术上说： Get 请求能缓存，Post 不能 Post 相对 Get 安全一点点，因为 Get 请求都包含在 URL 里（当然你想写到 body 里也是可以的），且会被浏览器保存历史纪录。Post 不会，但是在抓包的情况下都是一样的。 URL 有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的 Post 支持更多的编码类型且不对数据类型限制 首部首部分为请求首部和响应首部，并且部分首部两种通用，接下来我们就来学习一部分的常用首部。 通用首部 通用字段 作用 Cache-Control 控制缓存的行为 Connection 浏览器想要优先使用的连接类型，比如 keep-alive Date 创建报文时间 Pragma 报文指令 Via 代理服务器相关信息 Transfer-Encoding 传输编码方式 Upgrade 要求客户端升级协议 Warning 在内容中可能存在错误 请求首部 请求首部 作用 Accept 能正确接收的媒体类型 Accept-Charset 能正确接收的字符集 Accept-Encoding 能正确接收的编码格式列表 Accept-Language 能正确接收的语言列表 Expect 期待服务端的指定行为 From 请求方邮箱地址 Host 服务器的域名 If-Match 两端资源标记比较 If-Modified-Since 本地资源未修改返回 304（比较时间） If-None-Match 本地资源未修改返回 304（比较标记） User-Agent 客户端信息 Max-Forwards 限制可被代理及网关转发的次数 Proxy-Authorization 向代理服务器发送验证信息 Range 请求某个内容的一部分 Referer 表示浏览器所访问的前一个页面 TE 传输编码方式 响应首部 响应首部 作用 Accept-Ranges 是否支持某些种类的范围 Age 资源在代理缓存中存在的时间 ETag 资源标识 Location 客户端重定向到某个 URL Proxy-Authenticate 向代理服务器发送验证信息 Server 服务器名字 WWW-Authenticate 获取资源需要的验证信息 实体首部 实体首部 作用 Allow 资源的正确请求方式 Content-Encoding 内容的编码格式 Content-Language 内容使用的语言 Content-Length request body 长度 Content-Location 返回数据的备用地址 Content-MD5 Base64 加密格式的内容 MD5 检验值 Content-Range 内容的位置范围 Content-Type 内容的媒体类型 Expires 内容的过期时间 Last_modified 内容的最后修改时间 常见状态码状态码表示了响应的一个状态，可以让我们清晰的了解到这一次请求是成功还是失败，如果失败的话，是什么原因导致的，当然状态码也是用于传达语义的。如果胡乱使用状态码，那么它存在的意义就没有了。 状态码通常也是一道常考题。 2XX 成功 200 OK，表示从客户端发来的请求在服务器端被正确处理 204 No content，表示请求成功，但响应报文不含实体的主体部分 205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容 206 Partial Content，进行范围请求 3XX 重定向 301 moved permanently，永久性重定向，表示资源已被分配了新的 URL 302 found，临时性重定向，表示资源临时被分配了新的 URL 303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源 304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况 307 temporary redirect，临时重定向，和 302 含义类似，但是期望客户端保持请求方法不变向新的地址发出请求 4XX 客户端错误 400 bad request，请求报文存在语法错误 401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息 403 forbidden，表示对请求资源的访问被服务器拒绝 404 not found，表示在服务器上没有找到请求的资源 5XX 服务器错误 500 internal sever error，表示服务器端在执行请求时发生了错误 501 Not Implemented，表示服务器不支持当前请求所需要的某个功能 503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求 TLS HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。 TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。 在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。 对称加密： 对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。 这种加密方式固然很好，但是问题就在于如何让双方知道秘钥。因为传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，一旦秘钥被截获就没有加密的意义的。 非对称加密： 有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。 这种加密方式就可以完美解决对称加密存在的问题。假设现在两端需要使用对称加密，那么在这之前，可以先使用非对称加密交换秘钥。 简单流程如下：首先服务端将公钥公布出去，那么客户端也就知道公钥了。接下来客户端创建一个秘钥，然后通过公钥加密并发送给服务端，服务端接收到密文以后通过私钥解密出正确的秘钥，这时候两端就都知道秘钥是什么了。 TLS 握手过程如下图： 客户端发送一个随机值以及需要的协议和加密方式。 服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明） 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书 服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密 通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。 PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。 小结 总结一下内容： HTTP 经常考到的内容包括：请求方法、首部的作用以及状态码的含义 TLS 中经常考到的内容包括：两种加密方式以及握手的流程","categories":[],"tags":[]},{"title":"【JavaScript】JS 异步编程及常考面试题","slug":"yuque/【JavaScript】JS 异步编程及常考面试题","date":"2020-04-05T00:55:41.000Z","updated":"2020-06-07T13:19:51.999Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/","excerpt":"","text":"title: 【JavaScript】JS 异步编程及常考面试题 date: 2019 年 04 月 08 日 00:27:43categories:typora-root-url: ..typora-copy-images-to: ../images JS 异步编程及常考面试题在上一章节中我们了解了常见 ES6 语法的一些知识点。这一章节我们将会学习异步编程这一块的内容，鉴于异步编程是 JS 中至关重要的内容，所以我们将会用三个章节来学习异步编程涉及到的重点和难点，同时这一块内容也是面试常考范围，希望大家认真学习。 并发（concurrency）和并行（parallelism）区别 涉及面试题：并发与并行的区别？ 异步和这小节的知识点其实并不是一个概念，但是这两个名词确实是很多人都常会混淆的知识点。其实混淆的原因可能只是两个名词在中文上的相似，在英文上来说完全是不同的单词。 并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。 并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。 回调函数（Callback） 涉及面试题：什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？ 回调函数应该是大家经常使用到的，以下代码就是一个回调函数的例子： 123ajax(url, () =&gt; &#123; // 处理逻辑&#125;) 但是回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你可能就会写出如下代码： 123456789ajax(url, () =&gt; &#123; // 处理逻辑 ajax(url1, () =&gt; &#123; // 处理逻辑 ajax(url2, () =&gt; &#123; // 处理逻辑 &#125;) &#125;)&#125;) 以上代码看起来不利于阅读和维护，当然，你可能会想说解决这个问题还不简单，把函数分开来写不就得了 123456789101112131415function firstAjax() &#123; ajax(url1, () =&gt; &#123; // 处理逻辑 secondAjax() &#125;)&#125;function secondAjax() &#123; ajax(url2, () =&gt; &#123; // 处理逻辑 &#125;)&#125;ajax(url, () =&gt; &#123; // 处理逻辑 firstAjax()&#125;) 以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。 回调地狱的根本问题就是： 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身 嵌套函数一多，就很难处理错误 当然，回调函数还存在着别的几个缺点，比如不能使用 try catch 捕获错误，不能直接 return。在接下来的几小节中，我们将来学习通过别的技术解决这些问题。 Generator 涉及面试题：你理解的 Generator 是什么？ Generator 算是 ES6 中难理解的概念之一了，Generator 最大的特点就是可以控制函数的执行。在这一小节中我们不会去讲什么是 Generator，而是把重点放在 Generator 的一些容易困惑的地方。 123456789function *foo(x) &#123; let y = 2 * (yield (x + 1)) let z = yield (y / 3) return (x + y + z)&#125;let it = foo(5)console.log(it.next()) // =&gt; &#123;value: 6, done: false&#125;console.log(it.next(12)) // =&gt; &#123;value: 8, done: false&#125;console.log(it.next(13)) // =&gt; &#123;value: 42, done: true&#125; 你也许会疑惑为什么会产生与你预想不同的值，接下来就让我为你逐行代码分析原因 首先 Generator 函数调用和普通函数不同，它会返回一个迭代器 当执行第一次 next 时，传参会被忽略，并且函数暂停在 yield (x + 1) 处，所以返回 5 + 1 = 6 当执行第二次 next 时，传入的参数等于上一个 yield 的返回值，如果你不传参，yield 永远返回 undefined。此时 let y = 2 * 12，所以第二个 yield 等于 2 * 12 / 3 = 8 当执行第三次 next 时，传入的参数会传递给 z，所以 z = 13, x = 5, y = 24，相加等于 42 Generator 函数一般见到的不多，其实也于他有点绕有关系，并且一般会配合 co 库去使用。当然，我们可以通过 Generator 函数解决回调地狱的问题，可以把之前的回调地狱例子改写为如下代码： 123456789function *fetch() &#123; yield ajax(url, () =&gt; &#123;&#125;) yield ajax(url1, () =&gt; &#123;&#125;) yield ajax(url2, () =&gt; &#123;&#125;)&#125;let it = fetch()let result1 = it.next()let result2 = it.next()let result3 = it.next() Promise 涉及面试题：Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？ Promise 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是： 等待中（pending） 完成了 （resolved） 拒绝了（rejected） 这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变 12345new Promise((resolve, reject) =&gt; &#123; resolve(&apos;success&apos;) // 无效 reject(&apos;reject&apos;)&#125;) 当我们在构造 Promise 的时候，构造函数内部的代码是立即执行的 123456new Promise((resolve, reject) =&gt; &#123; console.log(&apos;new Promise&apos;) resolve(&apos;success&apos;)&#125;)console.log(&apos;finifsh&apos;)// new Promise -&gt; finifsh Promise 实现了链式调用，也就是说每次调用 then 之后返回的都是一个 Promise，并且是一个全新的 Promise，原因也是因为状态不可变。如果你在 then 中 使用了 return，那么 return 的值会被 Promise.resolve() 包装 12345678Promise.resolve(1) .then(res =&gt; &#123; console.log(res) // =&gt; 1 return 2 // 包装成 Promise.resolve(2) &#125;) .then(res =&gt; &#123; console.log(res) // =&gt; 2 &#125;) 当然了，Promise 也很好地解决了回调地狱的问题，可以把之前的回调地狱例子改写为如下代码： 12345678ajax(url) .then(res =&gt; &#123; console.log(res) return ajax(url1) &#125;).then(res =&gt; &#123; console.log(res) return ajax(url2) &#125;).then(res =&gt; console.log(res)) 前面都是在讲述 Promise 的一些优点和特点，其实它也是存在一些缺点的，比如无法取消 Promise，错误需要通过回调函数捕获。 async 及 await 涉及面试题：async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？ 一个函数如果加上 async ，那么该函数就会返回一个 Promise 1234async function test() &#123; return &quot;1&quot;&#125;console.log(test()) // -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125; async 就是将函数返回值使用 Promise.resolve() 包裹了下，和 then 中处理返回值一样，并且 await 只能配套 async 使用 123async function test() &#123; let value = await sleep()&#125; async 和 await 可以说是异步终极解决方案了，相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 then 也很恶心，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。 1234567async function test() &#123; // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch(url) await fetch(url1) await fetch(url2)&#125; 下面来看一个使用 await 的例子： 12345678let a = 0let b = async () =&gt; &#123; a = a + await 10 console.log(&apos;2&apos;, a) // -&gt; &apos;2&apos; 10&#125;b()a++console.log(&apos;1&apos;, a) // -&gt; &apos;1&apos; 1 对于以上代码你可能会有疑惑，让我来解释下原因 首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来 因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10 上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。 常用定时器函数 涉及面试题：setTimeout、setInterval、requestAnimationFrame 各有什么特点？ 异步编程当然少不了定时器了，常见的定时器函数有 setTimeout、setInterval、requestAnimationFrame。我们先来讲讲最常用的setTimeout，很多人认为 setTimeout 是延时多久，那就应该是多久后执行。 其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 setTimeout 不会按期执行。当然了，我们可以通过代码去修正 setTimeout，从而使定时器相对准确 123456789101112131415161718192021222324252627let period = 60 * 1000 * 60 * 2let startTime = new Date().getTime()let count = 0let end = new Date().getTime() + periodlet interval = 1000let currentInterval = intervalfunction loop() &#123; count++ // 代码执行所消耗的时间 let offset = new Date().getTime() - (startTime + count * interval); let diff = end - new Date().getTime() let h = Math.floor(diff / (60 * 1000 * 60)) let hdiff = diff % (60 * 1000 * 60) let m = Math.floor(hdiff / (60 * 1000)) let mdiff = hdiff % (60 * 1000) let s = mdiff / (1000) let sCeil = Math.ceil(s) let sFloor = Math.floor(s) // 得到下一次循环所消耗的时间 currentInterval = interval - offset console.log(&apos;时：&apos;+h, &apos;分：&apos;+m, &apos;毫秒：&apos;+s, &apos;秒向上取整：&apos;+sCeil, &apos;代码执行时间：&apos;+offset, &apos;下次循环间隔&apos;+currentInterval) setTimeout(loop, currentInterval)&#125;setTimeout(loop, currentInterval) 接下来我们来看 setInterval，其实这个函数作用和 setTimeout 基本一致，只是该函数是每隔一段时间执行一次回调函数。 通常来说不建议使用 setInterval。第一，它和 setTimeout 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码 1234567function demo() &#123; setInterval(function()&#123; console.log(2) &#125;,1000) sleep(2000)&#125;demo() 以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。 如果你有循环定时器的需求，其实完全可以通过 requestAnimationFrame 来实现 1234567891011121314151617181920212223function setInterval(callback, interval) &#123; let timer const now = Date.now let startTime = now() let endTime = startTime const loop = () =&gt; &#123; timer = window.requestAnimationFrame(loop) endTime = now() if (endTime - startTime &gt;= interval) &#123; startTime = endTime = now() callback(timer) &#125; &#125; timer = window.requestAnimationFrame(loop) return timer&#125;let a = 0setInterval(timer =&gt; &#123; console.log(1) a++ if (a === 3) cancelAnimationFrame(timer)&#125;, 1000) 首先 requestAnimationFrame 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 setTimeout。 小结异步编程是 JS 中较难掌握的内容，同时也是很重要的知识点。以上提到的每个知识点其实都可以作为一道面试题，希望大家可以好好掌握以上内容如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。 异步编程相关内容并非一章节就能讲完，需要继续浏览后续章节。","categories":[],"tags":[]},{"title":"【JavaScript】jQuery学习小记","slug":"yuque/【JavaScript】jQuery学习小记","date":"2020-04-05T00:55:36.000Z","updated":"2020-06-07T13:19:52.311Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】jQuery学习小记/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】jQuery学习小记/","excerpt":"","text":"title: 【JavaScript】jQuery 学习小记 date: 2019 年 04 月 08 日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 基本选择器 $(&quot;#id&quot;)：id 选择器，返回单个元素 $(&quot;.class&quot;)：class 选择器，返回集合元素 $(&quot;element&quot;)：选定指定的元素名匹配的元素，返回集合元素 $(&quot;*&quot;)：通配符选择器，选择所有元素，返回集合元素 $(&quot;selector1,selector2&quot;)：选择所有选择器匹配的元素，返回集合元素 层次选择器 $(&quot;div span&quot;)：选择&lt;div&gt;里的所有&lt;span&gt;后代元素，返回集合元素 $(&quot;div&gt;span&quot;)：选择&lt;div&gt;下的&lt;span&gt;子元素，只寻找一级（第一代子元素），&lt;span&gt;中的&lt;span&gt;不会找到，而上述则全部找到 12345678&lt;div&gt; &lt;span id=\"span1\"&gt;&lt;/span&gt; &lt;span id=\"span2\"&gt; &lt;span id=\"span3\"&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;!-- div span 选取的结果是&#123;span1,span2,span3&#125; --&gt;&lt;!-- div &gt; span 选取的结果是&#123;span1,span2&#125; --&gt; $(&quot;#one+div&quot;)：获取紧接在one后面的一个同辈div元素，等同于$(#one).next(&quot;div&quot;) $(#one).prev(&quot;div&quot;)获取紧接在one前面的一个同辈div元素 $(&quot;#one~div&quot;)：获取one后面的所有同辈div元素，等同于$(#one).nextAll(&quot;div&quot;) $(#one).siblings(&quot;div&quot;)：获取one的元素的所有div同辈元素 （不管前后） 所以 获取元素范围大小顺序依次为： $(#one).siblings(&quot;div&quot;)&gt;$(&quot;#one~div&quot;)&gt;$(&quot;#one +div&quot;) $(#one).siblings(&quot;div&quot;)&gt;$(#one).nextAll(&quot;div&quot;)&gt;$(#one).next(&quot;div&quot;) 基本过滤选择器 :first：选取第一个元素，返回单个元素 :last：选取最后一个元素，返回单个元素 :not(selector)：去除所有给定选择器所匹配的元素，返回集合元素 :even：选取索引为偶数的所有元素，索引号从0开始，返回集合元素 :odd：选取索引为奇数的所有元素，索引号从0开始，返回集合元素 :eq(index)：选取索引等于index的元素，index从0开始返回单个元素 :gt(index)：选取索引号大于index的所有元素,返回集合元素 :lt(index)：选取索引小于index的所有元素，返回集合元素 :header：选取所有的标题元素，返回集合元素 :animated：选取正在执行动画的元素，返回集合元素 :focus：选取当前获取焦点的元素，返回集合元素 内容过滤选择器 :contains(text)：选取含有文本内容为text的元素，返回集合元素 :empty：选取没有子节点或者文本的空元素，返回集合元素 :has(selector)：选取含有选择器所匹配的元素的元素，返回集合元素 :parent：选取含有子节点或者文本的元素，返回集合元素 可见性过滤选择器 :hidden：选取所有不可见的元素，返回集合元素 :visible：选取所有可见的元素，返回集合元素 属性过滤选择器 [attribute]：选取含有此属性的元素，返回集合元素 :[attribute=value]：选取属性的值为value的元素，返回集合元素 :[attribute!=value]：选取属性的值不为value的元素，返回集合元素 :[attribute^=value]：选取属性的值以value开始的元素，返回集合元素 :[attribute$=value]：选取属性的值以value结尾的元素，返回集合元素 :[attribute*=value]：选取属性的值含有value的元素，返回集合元素 :[attribute|=value]：选取属性的值等于value或者是以value为前缀（即value-，value后面跟一个连字符）的元素，返回集合元素 :[attribute~=value]：选取属性的值以空格分隔的值中含有value的元素，返回集合元素 :[attribute1][attribute1]...[attributeN1]：用多个属性选择器合并成一个复合属性选择器，返回集合元素 子元素过滤选择器 :nth-child(index/even/odd)：选取父元素下的第index个子元素，index值从1开始，或者选取奇偶子元素,返回集合元素 :first-child：选取父元素下的第一个元素，返回集合元素 :last-child：选取父元素下的最后一个子元素，返回集合元素 :only-child：如果元素是父元素的唯一的元素，则选择，否则，不选择，返回集合元素 :nth-child()还可以通过数学表达式选取一组特定的元素，如::nth-child(3n)：选取父元素下所有3的倍数的子元素（n从1开始，即选取第3，6，9，...个元素） 表单选择器 :input：选取所有的input、textarea、select、button元素，返回集合元素 :text：选取所有单行文本框，返回集合元素 :password：选取所有的密码框，返回集合元素 :radio：选取所有的单选框，返回集合元素 :checkbox：选取所有的多选框，返回集合元素 :submit：选取所有提交按钮，返回集合元素 :image：选取所有的图像按钮，返回集合元素 :reset：选取所有的重置按钮，返回集合元素 :button：选取所有的按钮，返回集合元素 :file：选取所有的上传域，返回集合元素 表单对象属性过滤选择器 :enabled：选取所有可用元素，返回集合元素 :disabled：选取所有不可用元素，返回集合元素 :checked：选取所有被选中的元素（单选框和多选框），返回集合元素 :selected：选取所有被选中的元素（下拉列表），返回集合元素 查找、设置、删除属性 attr()方法：接受一个或两个参数，一个参数是获取属性值，两个参数是设置属性,需要设置多个属性时，attr方法的参数可以是一个由属性和属性值组成的 json 数据格式 123$(\"div\").attr(\"background\"); //获取属性值$(\"div\").attr(\"background\", \"blue\"); //设置属性值$(\"div\").attr(&#123; background: \"blue\", height: \"200px\" &#125;); //设置多个属性值 css()方法：接受一个或两个参数，当一个参数是属性名时，获取属性值，当两个参数时，设置属性第一个参数为属性名，第二个参数为属性值，需要设置多个属性时，css方法的参数可以是一个由属性和属性值组成的 json 数据格式 123$(\"div\").css(\"background\"); //获取属性值$(\"div\").css(\"background\", \"blue\"); //设置属性值$(\"div\").css(&#123; background: \"blue\", height: \"200px\" &#125;); //设置多个属性值 另外width()方法和height()方法可以直接获取宽度和高度 addClass()：为元素添加class值，可批量添加属性与值 1$(\"div\").addClass(\"myclass\"); removeAttr()：删除指定的属性 1$(\"div\").removeAttr(\"background\"); removeClass()：有参数时，删除指定的class值，没有参数时，删除全部的class值 12$(\"div\").removeClass(\"myclass\");$(\"div\").removeClass(); hasClass()：判断匹配的元素是否有某个class值，有则返回true，没有则返回false 1$(\"div\").hasClass(\"myclass\"); 创建元素、文本、属性节点 均可以直接将元素、文本、属性添加到$()方法中，如： 1var p = $(\"&lt;p title='mytitle'&gt;假装是标题&lt;/p&gt;\"); 插入节点 append()：向元素内部添加节点，如： 1&lt;p&gt;我是内容&lt;/p&gt; 1$(\"p\").append(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果： 1&lt;p&gt;我是内容&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;/p&gt; appendTo()：将元素添加到指定元素内部，即将append方法中的链式操作的成员互换位置 1&lt;p&gt;我是内容&lt;/p&gt; 1$(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").appendTo(\"p\"); 结果： 1&lt;p&gt;我是内容&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;/p&gt; prepend()：向元素内部前置内容 1&lt;p&gt;我是内容&lt;/p&gt; 1$(\"p\").prepend(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果： 1&lt;p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt;我是内容&lt;/p&gt; prependTo()：将节点前置到指定元素中，即将prepend方法中的链式操作中的成员互换位置 1&lt;p&gt;我是内容&lt;/p&gt; 1$(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").prependTo(\"p\"); 结果： 1&lt;p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt;我是内容&lt;/p&gt; after()：在每个元素节点后添加节点 1&lt;p&gt;我是内容&lt;/p&gt; 1$(\"p\").after(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果： 12&lt;p&gt;我是内容&lt;/p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt; insertAfter()：讲节点插入到指定节点之后，即将after方法中的链式操作中的成员互换位置 1&lt;p&gt;我是内容&lt;/p&gt; 1$(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").insertAfter(\"p\"); 结果： 12&lt;p&gt;我是内容&lt;/p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt; before()：再节点前面插入节点 1&lt;p&gt;我是内容&lt;/p&gt; 1$(\"p\").before(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果： 12&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;p&gt;我是内容&lt;/p&gt; insertBefore()：将节点插入到指定元素前面 1&lt;p&gt;我是内容&lt;/p&gt; 1$(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").insertBefore(\"p\"); 结果： 12&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;p&gt;我是内容&lt;/p&gt; 删除节点 remove()：从DOM中删除所有匹配的元素，同时该节点所包含的所有后代节点将同时被删除，因为返回值是删除节点的引用，因此可以在以后继续使用这些元素，但是此时这些节点所绑定的事件也会删除，如： 12var $li = $(\"ul li:eq(1)\").remove(); //删除节点$li.appendTo(\"ul\"); //将节点添加回去 - detach()：和remove()几乎一样，不同的是detach方法不会删除节点所绑定的事件和附加的数据 - empty()：清空所匹配的节点 1$(\"ul li:eq(1)\").empty(); //此时第一个li标签内无任何内容及节点了 复制节点 clone()：复制节点，可以有参数true，当有true参数时，将同时复制节点所绑定的事件，如： 1$(\"ul li:eq(1)\").clone(true).apppendTo(\"ul\"); 替换节点 replaceWith()：将匹配的节点替换成指定的节点 1$(\"p\").replaceWith(\"&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;\"); replaceAll()：用指定的节点替换相应节点，即将replaceWith方法中的链式操作中的成员互换位置 1$(\"&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;\").replaceAll(\"p\"); 包裹节点 wrap()：将匹配的节点用指定的节点单独包裹起来 12&lt;p&gt;我是内容&lt;/p&gt;&lt;p&gt;我是另一个内容&lt;/p&gt; 1$(\"p\").wrap(\"&lt;span&gt;&lt;/span&gt;\"); 结果： 1&lt;span&gt;&lt;p&gt;我是内容&lt;/p&gt;&lt;/span&gt; &lt;span&gt;&lt;p&gt;我是另一个内容&lt;/p&gt;&lt;/span&gt; wrapAll()：将匹配的节点用指定的节点全部包裹起来 12&lt;p&gt;我是内容&lt;/p&gt;&lt;p&gt;我是另一个内容&lt;/p&gt; 1$(\"&lt;span&gt;&lt;/span&gt;\").wrapAll(\"p\"); 结果： 1234&lt;span&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;p&gt;我是另一个内容&lt;/p&gt;&lt;/span&gt; wrapInner()：将匹配的节点内部的节点或者文本内容用指定的节点包裹起来 1&lt;p&gt;我是内容&lt;/p&gt; 1$(\"p\").wrapInner(\"&lt;span&gt;&lt;/span&gt;\"); 结果： 1&lt;p&gt;&lt;span&gt;我是内容&lt;/span&gt;&lt;/p&gt; 设置、获取文本、HTML和值 html()：类似于原生JavaScript中的innerHTML属性，不含参数时是获取，包含元素节点和文本节点，当内有字符串参数时，是重新设置节点内容和文本内容 1$(\"p\").html(); text()：类似于原生JavaScript中的innerText属性，不含参数时是获取文本节点，当内有字符串参数时，是重新设置文本内容 1$(\"p\").text(\"我是内容\"); val()：类似于原生JavaScript中的value属性，可以用来获取和设置元素的值，无论是元素或者文本框，下拉列表或者单选框，如果元素是多选，则返回一个包含所有选择的值的数组 遍历节点 children()：获取所有的子元素集合，返回一个数组，只考虑直接子元素，不考虑其他后代元素 1234567&lt;div&gt; &lt;p&gt; 我是内容 &lt;span&gt;我是内嵌的内容&lt;/span&gt; &lt;/p&gt; &lt;p&gt;我是另一个内容&lt;/p&gt;&lt;/div&gt; 12var $div = $(\"div\").children();$div.length; //返回2，不是3，只包含直接子元素，不包含span next()：获取匹配元素后面紧邻的一个同辈元素，效果类似于$(&quot;prev+next&quot;) 1234&lt;div&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;h1&gt;我是另一个内容&lt;/h1&gt;&lt;/div&gt; 1var $h1 = $(\"p\").next(); //返回h1元素节点 prev()：获取匹配元素前面紧邻的一个同辈元素 1234&lt;div&gt; &lt;h1&gt;我是另一个内容&lt;/h1&gt; &lt;p&gt;我是内容&lt;/p&gt;&lt;/div&gt; 1var $h1 = $(\"p\").prev(); //返回h1元素节点 siblings()：获取匹配元素的前后所有的同辈元素 1234567&lt;div&gt; &lt;h1&gt;我是另一个内容&lt;/h1&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;ul&gt; 我是列表 &lt;/ul&gt;&lt;/div&gt; 1var $h1 = $(\"p\").next(); //返回h1和ul元素节点集合 closest()：获取最近的符合匹配的一个父元素 12345&lt;div&gt; &lt;div class=\"div2\"&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1var $div = $(\"p\").closest(); //返回class为div2的div元素 parent()：获取一个父元素 12345&lt;div&gt; &lt;div class=\"div2\"&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1var $div = $(\"p\").parent(); //返回class为div2的div元素 parents()：获取所有匹配的一个祖先元素 12345&lt;div&gt; &lt;div class=\"div2\"&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1var $div = $(\"p\").parents(); //返回两个div元素组成的数组 元素定位 offset()：获取元素在当前视窗的相对偏移，返回一个对象，对象包含top和left两个属性 1&lt;div&gt;我是内容&lt;/div&gt; 123var $offset = $(\"div\").offset();var left = $offset.left;var top = $offset.top; position()：获取元素相对于最近的一个position样式属性设置为relative或者absolute的祖父节点的相对偏移，返回一个对象，对象包含top和left两个属性 123&lt;div style=\"position:relative\"&gt; &lt;div&gt;&lt;p&gt;我是内容&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 123var $position = $(\"p\").position();var left = $position.left;var top = $position.top; - scrollTop()：获取元素的滚动条距离顶端的距离 - scrollLeft()：获取元素的滚动条距离左侧的距离 加载DOM $(document).ready()：和原生的JavaScript的window.onload()方法有类似的功能，window.onload()方法是在网页中所有的元素（包括元素的所有关联文件）完全加载到浏览器后才执行，而$(docuemnt).ready()在DOM完全就绪时就可以被调用，此时并不意味着这些关联文件都已经下载完毕；另外，$(document).ready()可多次使用，而window.onload()只能用一次，多次使用时会出现覆盖的现象，另外其可以简写成$().ready(); 事件绑定 bind()：可以有三个参数，第一个参数是事件类型，第二个参数可选，作为event.data属性值传给事件对象的额外数据对象，第三个参数是处理函数 1bind(type data fn); on()函数来绑定事件 常见的事件类型： blur、focus、load、resize、scroll、unload、click、dbclick、mousedown、mouseup、mouseover、mousemove、mouseout、mouseenter、mouseleave、change、select、submit、keydown、keyup、error 另外，像click、mouseover、mouseout这类常用的事件，可以简写，如下： 123456789$(function () &#123; $(\"h1\") .mouseover(function () &#123; $(this).next().show(); &#125;) .mouseout(function () &#123; $(this).next().hide(); &#125;);&#125;); 合成事件jQuery中有两个合成事件——hover()和toggle()方法 hover()：用于模拟光标悬停事件，当光标移动到元素时，会触发第一个函数，离开时触发第二个函数，语法 1hover(enter, leave); toggle()：用于模拟鼠标连续点击事件，语法 1toggle(fn1,fn2,...,fn); 阻止事件之外的额外问题 停止事件冒泡：用stopPropagation()方法来停止事件冒泡，如： 1234$(\"span\").bind(\"click\", function (event) &#123; //事件处理程序 event.stopPropagation();&#125;); 阻止默认行为：用preventDafault()方法来阻止默认行为，当然也可以用原生JavaScript中的return false，如： 12345$(\"a\").bind(\"click\", function (event) &#123; //事件处理程序 event.preventDafault(); //或者return false;&#125;); 事件捕获：事件捕获与事件冒泡是刚好两个相反的过程，jQuery不支持事件捕获。 事件对象 添加事件对象非常简单，只需要为函数添加一个参数，一般会用event 123$(\"a\").bind(\"click\", function (event) &#123; //事件处理程序&#125;); event.type：获取事件的类型 123$(\"a\").bind(\"click\", function (event) &#123; alert(event.type);&#125;); event.target：获取触发事件的对象元素 123$(\"a\").bind(\"click\", function (event) &#123; alert(event.target.href);&#125;); event.pageX和event.pageY：获取光标相对于页面的x坐标和y坐标 1234$(\"a\").bind(\"click\", function (event) &#123; alert(event.pageX); alert(event.pageY);&#125;); event.which：在鼠标单击时获取到鼠标的左、中、右键；在键盘事件中获取到键盘的按键 123456$(\"a\").mousedown(function (event) &#123; alert(event.which);&#125;);$(\"a\").keyup(function (event) &#123; alert(event.which);&#125;); event.metaKey：在键盘事件中获取ctrl按键 移除事件 unbind()：没有参数时，删除所有的绑定事件，可以有两个参数，第一个参数是事件类型，第二个参数是将要移除的函数，提供了事件类型，则只删除该事件类型，提供了事件处理函数，则只有这个事件处理函数会被删除，语法结构如下 1234unbind(type,data)$(\"a\").click(function()&#123; $(\"#btn\").unbind(\"click\",fn1);&#125; 另外，对于只需要触发一次随后就立即解除绑定的情况，jQuery提供了one()方法，这个方法可以为元素绑定处理函数，当函数触发一次后，立即被删除 事件的其他用法 模拟操作：trigger()：此方法可以模拟操作，例如 1$(\"#btn\").triggle(\"click\")； 这段代码可以触发id为btn的按钮的click事件，trigger()方法会触发浏览器的默认事件，如果不想执行浏览器的默认操作，可以使用jQuery中的另一个方法triggerHandler()方法 绑定多个事件类型：bind可以为元素绑定多个事件类型 12345$(function () &#123; $(\"div\").bind(\"mouseover mouseout\", function () &#123; $(this).toggleClass(\"over\"); &#125;);&#125;); 这段代码效果和下方代码一样 1234567$(function()&#123; $(\"div\").bind(\"mouseover\",function()&#123; $(this).toggleClass(\"over\"); &#125;).bind(\"mouseout\",function()&#123; $(this).toggleClass(\"over\")； &#125;);&#125;) 动画 show()和hide()：这两个是jQuery中的最基本的动画，当这两个方法不含参数时，效果类似于直接将元素的display属性分别改为block和none，这两个方法当有参数时，可以使元素慢慢显示出来，速度关键字有slow、normal、fast，此外，还可以直接指定一个数字作为显示的时间参数，单位为毫秒，其中slow的显示时间为600毫秒，normal的显示时间为400毫秒，fast的显示时间为200毫秒，这两个方法是同时改变元素的高度、宽度和不透明度 12345678$(\"p\").toggle( function () &#123; $(this).next().hide(600); &#125;, function () &#123; $(this).next().show(600); &#125;); fadeIn()和fadeOut()：这两个函数只改变元素的不透明度，同样可以有以上的速度参数 12345678$(\"p\").toggle( function () &#123; $(this).next().fadeOut(); &#125;, function () &#123; $(this).next().fadeIn(600); &#125;); slideUp()和slideDown()：这两个方法只改变元素的高度，slideDown()方法使元素由上到下延伸展示，而slideUp()方法使元素从下到上缩短隐藏，同样有上述的时间参数 12345678$(\"p\").toggle( function () &#123; $(this).next().slideUp(); &#125;, function () &#123; $(this).next().slideDown(600); &#125;); toggle()：切换元素的可见状态，如果元素可见，则切换为隐藏，如果元素隐藏，则切换为可见 12toggle(speed, callback);$(this).next().toggle(); 效果和hide()和show()方法类似 slideToggle()：通过高度来切换元素的可见性 1slideToggle(speed, easing, callback); fadeTo()：把元素的不透明度以渐进的方式调整到指定的值，这个动画只调整元素的不透明度 12fadeTo(speed, opacity, callback);$(this).fadeTo(100, 0.3); fadeToggle()：通过不透明度来切换元素的可见性 1fadeToggle(speed, easing, callback); animate()：自定义动画 1234animate(params,speed,callback);params：一个包含样式属性及值的映射，如：&#123;left:\"400px\",height:\"500px\"&#125;speed：速度参数，可选callback：在动画完成后执行的函数，可选 animate可以添加累加与累减动画，如： 12345$(function () &#123; $(\"p\").click(function () &#123; $(this).animate(&#123; left: \"+=500px\" &#125;, 300); &#125;);&#125;); 利用animate中的第一个参数很容易实现同时执行多个动画的效果，而需要按顺序执行动画，只需要顺序写animate动画即可，另外也可以使用链式操作 12$(this).animate(&#123; left: \"500px\" &#125;, 300);$(this).animate(&#123; height: \"500px\" &#125;, 300); 等效于 1$(this).animate(&#123; left: \"500px\" &#125;, 300).animate(&#123; height: \"500px\" &#125;, 300); 判断元素是否处于动画状态123if (!$(\"p\").is(\":animated\")) &#123; //没有处于动画状态时执行的程序&#125; 延迟动画 延迟动画利用delay()方法 1$(this).animate(&#123; left: \"500px\" &#125;, 200).delay(1000);","categories":[],"tags":[]},{"title":"【JavaScript】ES6","slug":"yuque/【JavaScript】ES6","date":"2020-04-05T00:55:31.000Z","updated":"2020-06-07T13:19:52.481Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】ES6/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】ES6/","excerpt":"","text":"title: 【JavaScript】ES6date: 2019年04月08日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images var、let 及 const 区别 涉及面试题：什么是提升？什么是暂时性死区？var、let 及 const 区别？ 对于这个问题，我们应该先来了解提升（hoisting）这个概念。 12console.log(a); // undefinedvar a = 1; 从上述代码中我们可以发现，虽然变量还没有被声明，但是我们却可以使用这个未被声明的变量，这种情况就叫做提升，并且提升的是声明。 对于这种情况，我们可以把代码这样来看 123var a;console.log(a); // undefineda = 1; 接下来我们再来看一个例子 123var a = 10;var a;console.log(a); 对于这个例子，如果你认为打印的值为 undefined 那么就错了，答案应该是 10，对于这种情况，我们这样来看代码 1234var a;var a;a = 10;console.log(a); 到这里为止，我们已经了解了 var 声明的变量会发生提升的情况，其实不仅变量会提升函数也会被提升。 123console.log(a); // ƒ a() &#123;&#125;function a() &#123;&#125;var a = 1; 对于上述代码，打印结果会是 ƒ a() {}，即使变量声明在函数之后，这也说明了函数会被提升，并且优先于变量提升。 说完了这些，想必大家也知道 var 存在的问题了，使用 var 声明的变量会被提升到作用域的顶部，接下来我们再来看 let 和 const 。 我们先来看一个例子： 123456789101112var a = 1;let b = 1;const c = 1;console.log(window.b); // undefinedconsole.log(window.c); // undefinedconsole.log(window.a); // 1function test() &#123; console.log(a); let a;&#125;test(); 首先在全局作用域下使用 let 和 const 声明变量，变量并不会被挂载到 window 上，这一点就和 var 声明有了区别。 再者当我们在声明 a 之前如果使用了 a，就会出现报错的情况 你可能会认为这里也出现了提升的情况，但是因为某些原因导致不能访问。 首先报错的原因是因为存在暂时性死区，我们不能在声明前就使用变量，这也是 let 和 const 优于 var 的一点。然后这里你认为的提升和 var 的提升是有区别的，虽然变量在编译的环节中被告知在这块作用域中可以访问，但是访问是受限制的。 那么到这里，想必大家也都明白 var、let 及 const 区别了，不知道你是否会有这么一个疑问，为什么要存在提升这个事情呢，其实提升存在的根本原因就是为了解决函数间互相调用的情况 1234567function test1() &#123; test2();&#125;function test2() &#123; test1();&#125;test1(); 假如不存在提升这个情况，那么就实现不了上述的代码，因为不可能存在 test1 在 test2 前面然后 test2 又在 test1 前面。 那么最后我们总结下这小节的内容： 函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部 var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用，其作用域为该语句所在的代码块内 var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会 let 和 const 作用基本一致，但是后者声明的变量不能再次赋值 let 和 const 使得 JS 存在块级作用域 参考资料 [1]https://www.youtube.com/watch?v=xgsjohgy3rk 原型继承和 Class 继承 涉及面试题：原型如何实现继承？Class 如何实现继承？Class 本质是什么？ Class 是什么 首先先来讲下 class，其实在 JS 中并不存在类，class 只是语法糖，本质还是函数。 12class Person &#123;&#125;Person instanceof Function; // true 组合 组合继承组合继承是最常用的继承方式 1234567891011121314151617181920212223// 父类构造函数function Parent(value) &#123; this.val = value;&#125;Parent.prototype.getValue = function () &#123; console.log(this.val);&#125;;// 子类构造函数function Child(value) &#123; Parent.call(this, value); // 继承父类属性 // Parent.call 不是 Child.call // 类比Java中的extendParent&#125;//要new出来Child.prototype = new Parent(); // 继承父类函数const child = new Child(1);child.getValue(); // 1child instanceof Parent; // true 以上继承的方式核心是在子类的构造函数中通过 Parent.call(this) 继承父类的属性，然后改变子类的原型为 new Parent() 来继承父类的函数。 这种继承方式优点在于构造函数可以传参，不会与父类引用属性共享，可以复用父类的函数，但是也存在一个缺点就是在继承父类函数的时候调用了父类构造函数，导致子类的原型上多了不需要的父类属性，存在内存上的浪费。 寄生组合继承这种继承方式对组合继承进行了优化，组合继承缺点在于继承父类函数时调用了构造函数，我们只需要优化掉这点就行了。 12345678910111213141516171819202122232425function Parent(value) &#123; this.val = value;&#125;Parent.prototype.getValue = function () &#123; console.log(this.val);&#125;;function Child(value) &#123; Parent.call(this, value);&#125;Child.prototype = Object.create(Parent.prototype, &#123; constructor: &#123; value: Child, enumerable: false, writable: true, configurable: true, &#125;,&#125;);const child = new Child(1);child.getValue(); // 1child instanceof Parent; // true 以上继承实现的核心就是将父类的原型赋值给了子类，并且将构造函数设置为子类，这样既解决了无用的父类属性问题，还能正确的找到子类的构造函数。 Class 继承以上两种继承方式都是通过原型去解决的，在 ES6 中，我们可以使用 class 去实现继承，并且实现起来很简单 123456789101112131415161718class Parent &#123; constructor(value) &#123; this.val = value; &#125; getValue() &#123; console.log(this.val); &#125;&#125;class Child extends Parent &#123; constructor(value) &#123; super(value); this.val = value; &#125;&#125;let child = new Child(1);child.getValue(); // 1child instanceof Parent; // true class 实现继承的核心在于使用 extends 表明继承自哪个父类，并且在子类构造函数中必须调用 super，因为这段代码可以看成 Parent.call(this, value)。 当然了，之前也说了在 JS 中并不存在类，class 的本质就是函数。 Proxy 涉及面试题：Proxy 可以实现什么功能？ 是什么 Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作 目的 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好 原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变 唯一缺陷可能就是浏览器的兼容性不好了 条件 如果你平时有关注 Vue 的进展的话，可能已经知道了在 Vue3.0 中将会通过 Proxy 来替换原本的 Object.defineProperty 来实现数据响应式。 1let p = new Proxy(target, handler); target 代表需要添加代理的对象，handler 用来自定义对象中的操作，比如可以用来自定义 set 或者 get 函数。 接下来我们通过 Proxy 来实现一个数据响应式 1234567891011121314151617181920212223242526let onWatch = (obj, setBind, getLogger) =&gt; &#123; let handler = &#123; get(target, property, receiver) &#123; getLogger(target, property); return Reflect.get(target, property, receiver); &#125;, set(target, property, value, receiver) &#123; setBind(value, property); return Reflect.set(target, property, value); &#125;, &#125;; return new Proxy(obj, handler);&#125;;let obj = &#123; a: 1 &#125;;let p = onWatch( obj, (v, property) =&gt; &#123; console.log(`监听到属性$&#123;property&#125;改变为$&#123;v&#125;`); &#125;, (target, property) =&gt; &#123; console.log(`'$&#123;property&#125;' = $&#123;target[property]&#125;`); &#125;);p.a = 2; // 监听到属性a改变p.a; // 'a' = 2 在上述代码中，我们通过自定义 set 和 get 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。 当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。 map, filter, reduce 涉及面试题：map, filter, reduce 各自有什么作用？ map 作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。 1[1, 2, 3].map((v) =&gt; v + 1); // -&gt; [2, 3, 4] 另外 map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组 1[\"1\", \"2\", \"3\"].map(parseInt); // 会出错，可以另定义函数 第一轮遍历 parseInt(&#39;1&#39;, 0) -&gt; 1 第二轮遍历 parseInt(&#39;2&#39;, 1) -&gt; NaN 第三轮遍历 parseInt(&#39;3&#39;, 2) -&gt; NaN filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素 123let array = [1, 2, 4, 6];let newArray = array.filter((item) =&gt; item !== 6);console.log(newArray); // [1, 2, 4] 和 map 一样，filter 的回调函数也接受三个参数，用处也相同。 最后我们来讲解 reduce 这块的内容，同时也是最难理解的一块内容。reduce 可以将数组中的元素通过回调函数最终转换为一个值。 如果我们想实现一个功能将函数里的元素全部相加得到一个值，可能会这样写代码 123456const arr = [1, 2, 3];let total = 0;for (let i = 0; i &lt; arr.length; i++) &#123; total += arr[i];&#125;console.log(total); //6 但是如果我们使用 reduce 的话就可以将遍历部分的代码优化为一行代码 123const arr = [1, 2, 3];const sum = arr.reduce((acc, current) =&gt; acc + current, 0);console.log(sum); 对于 reduce 来说，它接受两个参数，分别是回调函数和初始值，接下来我们来分解上述代码中 reduce 的过程 首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入 回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数 在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入 所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6 想必通过以上的解析大家应该明白 reduce 是如何通过回调函数将所有元素最终转换为一个值的，当然 reduce 还可以实现很多功能，接下来我们就通过 reduce 来实现 map 函数 1234567const arr = [1, 2, 3];const mapArray = arr.map((value) =&gt; value * 2);const reduceArray = arr.reduce((acc, current) =&gt; &#123; acc.push(current * 2); return acc;&#125;, []);console.log(mapArray, reduceArray); // [2, 4, 6] 如果你对这个实现还有困惑的话，可以根据上一步的解析步骤来分析过程。 箭头函数 箭头函数是什么 ES6 标准新增了一种新的函数：Arrow Function（箭头函数） 箭头函数分类边界 只包含一个表达式，连{ ... }和return都省略掉了 1(x) =&gt; x * x; 上面的箭头函数相当于 123function (x) &#123; return x * x;&#125; 包含多条语句，不能省略{ ... }和return： 多条语句条件 如果参数为一个 12345678// x为参数(x) =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return -x * x; &#125;&#125;; 如果参数不是一个，就需要用括号()括起来 1234567891011121314// 两个参数(x, y) =&gt; x * x + y * y// 无参数() =&gt; 3.14// 可变参数(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i = 0; i &lt; rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错 1234// SyntaxError:(x) =&gt; &#123; foo: x;&#125;; 因为和函数体的{ ... }有语法冲突，所以要改为 12// ok:(x) =&gt; (&#123; foo: x &#125;); 目的 箭头函数相当于匿名函数，并且简化了函数定义 组合 this箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别 箭头函数内部的this是词法作用域，由上下文确定 匿名函数this指向window中的全局变量，若无则为 undefined 回顾前面的例子，由于 JavaScript 函数对this绑定的错误处理，下面的例子无法得到预期结果 1234567891011var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 var fn = function () &#123; return new Date().getFullYear() - this.birth; // this父级作用域，直到window，若window也没有则为undefined &#125;; return fn(); &#125;,&#125;; 现在，箭头函数完全修复了this的指向，this总是指向词法作用域，也就是外层调用者obj 1234567891011var obj = &#123; birth: 1990, getAge: function () &#123; var b = this.birth; // 1990 // 无参数情况下 var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象 return fn(); &#125;,&#125;;obj.getAge(); // 25 如果使用箭头函数，以前的那种 hack 写法 1var that = this; 就不再需要了 由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略 123456789var obj = &#123; birth: 1990, getAge: function (year) &#123; var b = this.birth; // 1990 var fn = (y) =&gt; y - this.birth; // this.birth仍是1990 return fn.call(&#123; birth: 2000 &#125;, year); &#125;,&#125;;obj.getAge(2015); // 25","categories":[],"tags":[]},{"title":"【JavaScript】整理","slug":"yuque/【JavaScript】整理","date":"2020-04-05T00:55:26.000Z","updated":"2020-06-07T13:19:53.138Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】整理/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】整理/","excerpt":"","text":"title: 【JavaScript】整理date: 2019年04月08日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 一、变量类型和计算 JS 中使用 typeof 能得到的哪些类型 何时使用===何时使用== JS 中有哪些内置函数 JS 变量按照存储方式区分为哪些类型，并描述其特点 如何理解 JSON 变量类型JS 中有 7 种内置类型，7 种内置类型又分为两大类型 基本类型/值类型：null、undefined、boolean、number、string、symbol 对象/引用类型：object 基本类型/值类型是什么 把每一个值存放在对应变量内存的位置，数据分块存放在内存中，数据之间不会相互影响 1234var a = 100;var b = a;a = 200;console.log(b); // 100 条件 原始类型存储的都是值，是没有函数可以调用的，比如undefined.toString() &#39;1&#39;.toString() 是可以使用的。在这种情况下，&#39;1&#39; 已经不是原始类型了，而是被强制转换成了 String 类型（大写）也就是引用类型，所以可以调用 toString 函数 JS 的number 类型是浮点类型的，在使用中会遇到某些 Bug NaN也属于number类型，并且NaN不等于自身 0.1 + 0.2 !== 0.3 string类型是不可变的，无论你在string类型上调用何种方法，都不会对值有改变 对于null来说，很多人会认为他是个引用类型，其实这是错误的。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来 对象/引用类型是什么 当你创建了一个引用类型 a 的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针），引用类型 a 存储的就是这个地址 1const a = []; 对于常量 a 来说，假设内存地址（指针）为 #001，那么在地址 #001 的位置存放了值 []，常量 a 存放了地址（指针） #001 当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 b 存放的地址（指针）也是 #001，当我们进行数据修改的时候，就会修改存放在地址（指针） #001 上的值，也就导致了两个变量的值都发生了改变 123const a = [];const b = a;b.push(1); 产生原因 若 a 赋值成一个对象，特别大，a 再赋值给 b，b 也会占很大的空间，不合理，所以引用类型是为了让内存共用空间，好几个变量共用 1 个内存块，节省内存空间，赋值只是变量指针的赋值，并不是每次赋值都把对象真正的值复制一份，所以值的修改相互干预 分类边界 数组array、函数function、对象object 目的 无限制扩展属性，比如说对象有个 age 属性，可以加第 2 个属性 name 属性 组合 深浅拷贝 条件 函数参数是对象的情况 1234567891011121314151617function test(person) &#123; person.age = 26; person = &#123; name: \"yyy\", age: 30, &#125;; return person;&#125;const p1 = &#123; name: \"yck\", age: 25,&#125;;const p2 = test(p1);console.log(p1); // -&gt; ?console.log(p2); // -&gt; ? 首先，函数传参是传递对象指针的副本 到函数内部修改参数的属性这步，我相信大家都知道，当前 p1 的值也被修改了 但是当我们重新为 person 分配了一个对象时就出现了分歧，请看下图 所以最后 person 拥有了一个新的地址（指针），也就和 p1 没有任何关系了，导致了最终两个变量的值是不相同的 typeof 运算符是什么 只能区分基本类型的详细类型，引用类型无法细分 分类边界 typeof对于基本类型来说，除了null都可以显示正确的类型 123456typeof null; // 'object' BUGtypeof undefined; // 'undefined'typeof true; // 'boolean'typeof 1; // 'number'typeof \"1\"; // 'string'typeof Symbol(); // 'symbol' typeof对于引用类型来说，除了函数都会显示object，所以说typeof并不能准确判断引用变量到底是什么类型。因为函数是一个十分特殊的引用类型，在 JS 中函数的地位非常高，所以需要在任何地方轻松判断出这个是函数，所以 typeof 单独把函数列出来 123typeof []; // 'object'typeof &#123;&#125;; // 'object'typeof console.log; // 'function' 组合 instanceof 类型转换是什么 在 JS 中类型转换只有三种情况 转换为布尔值 转换为数字 转换为字符串 组合 转 Boolean在条件判断时，除了undefined、null、false、NaN、&#39;&#39;、0、-0，其他所有值都转为true，包括所有对象 引用类型转基本类型引用类型在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下 如果已经是基本类型了，那就不需要转换了 调用 x.valueOf()，如果转换为基础类型，就返回转换的值 调用 x.toString()，如果转换为基础类型，就返回转换的值 如果都没有返回基本类型，就会报错 当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高 123456789101112let a = &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return \"1\"; &#125;, [Symbol.toPrimitive]() &#123; return 2; &#125;,&#125;;1 + a; // =&gt; 3 四则运算目的 字符串拼接 运算 组合 加法运算中一方为字符串，那么就会把另一方也转换为字符串 加法运算中一方不是数字或字符串，那么会将它转换为数字或字符串 1231 + \"1\"; // '11'true + true; // 24 + [1, 2, 3]; // \"41,2,3\" 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 &#39;11&#39; 对于第二行代码来说，触发特点二，所以将 true 转为数字 1 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3 条件 对于加法还需要注意这个表达式 &#39;a&#39; + + &#39;b&#39; 1\"a\" + +\"b\"; // -&gt; \"aNaN\" 因为 + &#39;b&#39; 等于 NaN，所以结果为 &quot;aNaN&quot; Tips 用 + &#39;1&#39; 的形式来快速获取 number 类型 用!!判断变量会被当做true还是false 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字 1234 * \"3\"; // 124 * []; // 04 * [1, 2]; // NaN 比较运算符是什么 == &gt; &lt; != 组合 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过 unicode 字符索引来比较 123456789let a = &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return \"1\"; &#125;,&#125;;a &gt; -1; // true 在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值 题目解答 JS 中使用 typeof 能得到的哪些类型 typeof 可以识别 6 种数据类型：number、string、boolean、object、function、undefined 何时使用===何时使用== 使用 jQuery 源码中推荐的写法，当 obj.a 为 null 或 undefined 时，看一个对象的属性是否存在或看一个函数的参数是否存在，但对象和形参必须定义，否则会报错，可简写使用==，除此外一律用=== 123456789// 看一个对象的属性是否存在if(obj.a == null) &#123; // 相当于obj.a === null || obj.a ===undefined，简写形式&#125;// 看一个函数的参数是否存在function(a, b) &#123; if(a == null) &#123;...&#125;&#125; JS 中有哪些内置函数（数据封装类对象） 都是函数 Boolean Number String Object Array Function Date RegExp Error（一定要大写） 内置对象 Math JSON JS 变量按照存储方式区分为哪些类型，并描述其特点 基本类型：数据分块存放在内存中，数据不会相互干涉 1234var a = 100;var b = a;a = 200;console.log(b); //100 引用类型：好几个变量共用 1 个内存块，节省内存空间，赋值只是变量指针的赋值，并不是真正值的拷贝，所以值的修改相互干预 1234var a = &#123; age: 20 &#125;;var b = a;b.age = 21;conlose.log(a.age); //21 如何理解 JSON JSON 只不过是一个 JS 对象而已 JSON 也是一种数据格式 Math 也是 JS 对象 12JSON.stringify(&#123; a: 10, b: 20 &#125;); //将对象转换为字符串JSON.parse('&#123;\"a\": 10,\"b\":20&#125;'); //将字符串变为对象 二、原型与原型链 如何准确判断一个变量是数组类型 写一个原型链继承的例子 描述 new 一个对象的过程 zepto（或其他框架）源码中如何使用原型链 构造函数 构造函数首字母大写 构造函数类似于模板 new 一个构造函数，返回一个对象的过程 new 的时候把参数传入也可不传 new 函数执行时，创建一个空对象 this 指向这个新对象this = {} 执行代码，即对 this.name 等开始顺序赋值 赋值完后，默认 return this 赋值给f，f.name、f.age、f.class生效 12345678function Foo(name, age) &#123; this.name = name; this.age = age; this.class = \"class-1\"; // return this //默认有这一行&#125;var f = new Foo(\"zhangsan\", 20);// var f1 = new Foo('lisi', 23); 可创建多个对象 Tips var obj = {}其实是var obj = new Object()的语法糖 var arr = []其实是var arr = new Array()的语法糖 var fn = funtion () {...}其实是var fn = new Function()的语法糖 所有的引用类型（对象、数组、函数）都有构造函数 推荐使用前者的写法 原型5 条原型规则和示例 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（null除外） 123456var obj = &#123;&#125;;obj.a = 100;var arr = [];arr.a = 100;var fn = function () &#123;&#125;;fn.a = 100; 所有的引用类型，都有一个__proto__属性（隐式原型属性），属性值是一个普通的对象 123console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__); 所有函数，都有一个prototype属性（显式原型属性），属性值是一个普通的对象 Number、String、Boolean、Object、Array、Function、Date、RegExp、Error（一定要大写）都是函数 1console.log(fn.prototype); 所有引用类型，__proto__属性值指向（完全等===）他的构造函数的prototype属性值 1console.log(obj.__proto__ === Object.prototype); 当试图得到一个对象的某个属性时，若果这个对象本身没有这个属性，那么在它的__proto__（即它的构造函数的prototype）中寻找 123456789101112131415// 构造函数function Foo(name, age) &#123; this.name = name;&#125;Foo.prototype.alertName = function () &#123; alert(this.name);&#125;;// 创建实例var f = new Foo(\"zhangsan\");f.printName = function () &#123; console.log(this.name);&#125;;// 测试f.printName();f.alertName(); f 本身没有alertName的属性，所以会去 f 的隐式原型__proto__中去寻找，f 的隐式原型__proto__即为其构造函数 Foo 的显式原型prototype，Foo 的显式原型已被扩展了alertName的属性，所以可顺利执行 this 永远指向对象本身，在执行f.alertName()的时候会执行到第 6 行alert(this.name)，但是这里的 this 还是 f 本身 原型链 f.toString() -&gt; f.__proto__ -&gt; Foo.prototype -&gt; 无toString属性 -&gt; Foo.prototype是一个对象 -&gt; Foo.prototype.__proto__-&gt; Object.prototype -&gt; f.__proto__.__proto__ Object.prototype.__proto__ = null 12345678910111213141516// 构造函数function Foo(name, age) &#123; this.name = name;&#125;Foo.prototype.alertName = function () &#123; alert(this.name);&#125;;// 创建实例var f = new Foo(\"zhangsan\");f.printName = function () &#123; console.log(this.name);&#125;;// 测试f.printName();f.alertName();f.toString(); // 要去f.__proto__.__proto__中查找 instanceof 判断引用类型属于哪个构造函数的方法 f instanceof Foo判断逻辑：f的__proto__一层一层往上，能否对应到Foo.prototype f instanceof Object判断逻辑：f的__proto__一层一层往上，是否对应到Object.prototype 循环对象自身属性 从上述代码中可得 f 拥有三个属性：name、printName、alertName 但我们往往希望拿到对象本身定义的属性，而不要来自其原型的属性 12345678var item;for (item in f) &#123; // 高级浏览器已经在for in中屏蔽了来自原型的属性 // 但这里建议大家加上这个判断，保证程序的健壮性以满足浏览器的兼容性 if (f.hasOwnProperty(item)) &#123; console.log(item); &#125;&#125; 题目解答 如何准确判断一个变量是数组类型 123var arr = [];arr instanceof Array; //truetypeof arr; //object，typeof是无法判断数组的 写一个原型链继承的例子 面试千万不要这么写 面试写更贴近实战的例子 1234567891011121314151617// 动物function Animal() &#123; this.eat = function () &#123; console.log(\"animal eat\"); &#125;;&#125;// 狗function Dog() &#123; this.bark = function () &#123; console.log(\"dog bark\"); &#125;;&#125;Dog.prototype = new Animal();// 哈士奇var hashiqi = new Dog();hashiqi.eat();hashiqi.bark(); 1234567891011121314151617181920212223242526272829// 一个封装DOM查询的例子function Elem(id) &#123; this.elem = document.getElementById(id);&#125;Elem.prototype.html = function (val) &#123; var elem = this.elem; if (val) &#123; elem.innerHTML = val; return this; // 链式操作 &#125; else &#123; return elem.innerHTML; &#125;&#125;;Elem.prototype.on = function (type, fn) &#123; var elem = this.elem; elem.addEventListener(type, fn); return this; // 链式操作&#125;;var div1 = new Elem(\"div1\");console.log(div1.html());div1 .html(\"&lt;p&gt;hello world&lt;/p&gt;\") .on(\"click\", function () &#123; alert(\"clicked\"); &#125;) .html(\"&lt;p&gt;javascript&lt;/p&gt;\"); 描述 new 一个对象的过程 创建一个空对象 this 指向这个新对象 执行代码即对 this 赋值 返回 this zepto（或其他框架）源码中如何使用原型链 阅读源码是最高效提高技能的方式 但不能“埋头苦钻”，有技巧在其中，搜索别人的阅读体会 慕课网搜索“zepto 设计和源码分析” 在面试时说出读过源码并分享心得体会十分加分 jQuery 也可 Vue、React 不建议现在读 三、闭包和作用域 说一下变量提升的理解 说明 this 几种不同的使用场景 创建 10 个&lt;a&gt;标签，点击的时候弹出来对应的序号 如何理解作用域 实际开发中闭包的应用 执行上下文（声明提升）范围：一段&lt;script&gt;或者一个函数 全局（某个&lt;script&gt;）：变量定义提前、函数声明提前 函数（函数即将执行之前）：变量定义提前、函数声明提前、确定 this 的值、确定 arguments 的值 注意：函数声明和函数表达式的区别 函数声明 1234fn(); // 不会报错，因为函数声明会提升function fn() &#123; ... // 函数声明&#125; 函数表示式 123456fn1(); // 会报错，fn1会被当做变量定义，会提升相当于var fn1 = undefined，在执行fn1();// 以下均为函数表达式，函数表达式本质上即为变量定义var a = 100;var fn1 = function () &#123; ...&#125; 假如下列代码在一个&lt;script&gt;中，在一个&lt;script&gt;中要定义一个全局的执行上下文，在执行第 1 行代码之前，会把所有的变量声明和函数声明都执行一遍，执行顺序如下： 第 2 行，变量定义 ，还未执行到此，所以不会赋值，把 a 先拿出来，用 undefined 代替来占位 第 4-8 行，函数声明，把整个函数拿出来，以此函数生效可以执行 第 1 行，undefined 第 2 行，a 被赋值成 100 第 3 行，进入函数体，函数顺利执行 第 7 行，变量定义，并用 undefined 代替来占位 第 5 行，age 被赋值成 20 第 6 行，打印 arguments 参数 12345678console.log(a); // undefinedvar a = 100;fn('zhangsan'); // 'zhangsan', 20function fn(name) &#123; age = 20; console.log(name, age); var age；&#125; 12345678910111213141516171819202122// 全局// var a = undefined;console.log(a);var a = 100;fn(\"zhangsan\");function fn(name) &#123; // 函数 // 函数代码执行之前（不是函数声明之前），就已经确定了this的值 console.log(this); // 函数代码执行之前（不是函数声明之前），就已经确定了arguments的值 // arguments：函数参数的集合体 console.log(arguments); age = 20; console.log(name, age); var age; bar(100); function bar(num) &#123; console.log(num); &#125;&#125; thisthis 要在执行时才能确定值，定义时无法确认 一个函数后面加()，即为要执行 在此之前，函数永远处于定义状态 12345678910var a = &#123; name: \"A\", fn: function () &#123; console.log(this.name); &#125;,&#125;; // 只看到这里不能确认this到底是什么a.fn(); // this === aa.fn.call(&#123; name: \"B\" &#125;); // this === &#123;name: 'B'&#125;var fn1 = a.fn;fn1(); // this === window 作为构造函执行123456function Foo(name) &#123; // this = &#123;&#125;; this.name = name; // return this;&#125;var f = new Foo(\"zhangsan\"); 作为对象属性执行1234567var obj = &#123; name: \"A\", printName: function () &#123; console.log(this.name); // this === obj &#125;,&#125;;obj.printName(); 作为普通函数执行1234function fn() &#123; console.log(this); // this === window&#125;fn(); call apply bind12345678910111213141516171819function fn1(name, age) &#123; alert(name); alert(age); console.log(this); // this === window&#125;// call表示&#123;x:100&#125;为this，'zhangsan'为第1个参数，20为第2个参数，最常用fn1.call(&#123; x: 100 &#125;, \"zhangsan\", 20);// apply将后面当做数组，相当于fn1.apply(&#123; x: 100 &#125;, ['zhangsan', 20]);fn1.apply(&#123; x: 100 &#125;, \"zhangsan\", 20);// 使用bind修改默认this，.bind必须是函数表达式var fn2 = function (name, age) &#123; alert(name); alert(age); console.log(this);&#125;.bind(&#123; y: 200 &#125;);fn2(\"zhangsan\", 20); 作用域 没有块级作用域 但有函数和全局作用域 目的 封装变量 收敛权限 在函数外面不可能修改掉函数中定义的变量的值，以保证数据的安全不被污染 12345678910111213141516171819// 没有块级作用域if (true) &#123; // 在外面定义和定义在if语句块中是一样的 // 尽量不要在块中定义变量，容易使程序不易读 var name = \"zhangsan\";&#125;console.log(name); // 'zhangsan'// 但有函数和全局作用域var a = 100;function fn() &#123; var a = 200; // 函数中也有a，则使用函数中的a = 200 // 函数中的变量值，外面是改不了的 // 所以框架的第三方库就采用将变量定义在函数中的方法来防止变量被污染，与外面隔绝 console.log(\"fn\", a);&#125;console.log(\"global\", a); // 全局 a = 100fn(); // 函数 a = 200 作用域链是什么 去父级作用域取值，根据调用回到变量定义或函数声明的地方的父作用域 目的 查找自由变量 组合 当前作用域没有定义的变量，即“自由变量” 12345678var a = 100;function fn() &#123; var b = 200; // a即为自由变量 console.log(a); // 去父级作用域取值，变量定义或函数声明时的父作用域 console.log(b);&#125;fn(); 123456789101112131415var a = 100;function F1() &#123; var b = 200; function F2() &#123; var c = 300; // a是自由变量 // 父级F1中a未定义，再在F1父级中找a，a = 100 console.log(a); // b是自由变量 console.log(b); console.log(c); &#125; F2();&#125;F1(); 闭包使用场景函数作为返回值 1234567891011121314function F1() &#123; // a是F1局部变量 var a = 100; // 返回一个函数（函数作为返回值） return function () &#123; // a是个自由变量 console.log(a); // 去父级作用域取值，声明时的父作用域 &#125;;&#125;var f1 = F1();// a是全局变量，不会影响到函数中定义的局部变量var a = 200;// 不是看此处执行时的作用域，而是回到其定义处的作用域f1(); // 100 函数作为参数传递 1234567891011121314151617function F1() &#123; // a是F1局部变量 var a = 100; // 返回一个函数（函数作为返回值） return function () &#123; // a是个自由变量 console.log(a); // 去父级作用域取值，声明时的父作用域 &#125;;&#125;var f1 = F1();function F2(fn) &#123; var a = 200; fn(); // 此处为执行作用域&#125;F2(f1); 题目解答 说一下变量提升的理解 变量定义 函数声明（注意和函数表达式的区别） 说明 this 几种不同的使用场景 构造函数 对象属性 普通函数 call apply bind 创建 10 个&lt;a&gt;标签，点击的时候弹出来对应的序号 错误写法 1234567891011var i, a;for (i = 0; i &lt; 10; i++) &#123; a = document.createElement(\"a\"); a.innerHTML = i + \"&lt;br&gt;\"; a.addEventListener(\"click\", function (e) &#123; e.preventDefault(); // i是自由变量，要去父作用域获取值，无块级作用域（for），即要找全局作用域 alert(i); &#125;); document.body.appendChild(a);&#125; 正确写法 123456789101112131415var i;for (i = 0; i &lt; 10; i++) &#123; // 自执行函数，不用调用，只要定义完成，立即执行的函数 (function (i) &#123; // 函数作用域 var a = document.createElement(\"a\"); a.innerHTML = i + \"&lt;br&gt;\"; a.addEventListener(\"click\", function (e) &#123; e.preventDefault(); // i是自由变量，要去父作用域获取值，无块级作用域（for），即要找全局作用域 alert(i); &#125;); document.body.appendChild(a); &#125;)(i);&#125; 如何理解作用域 自由变量 作用域链，即自由变量的查找 闭包的两个场景 实际开发中闭包的应用 闭包实际应用主要用于封装变量，收敛权限 闭包的意义：你在 isFirstLoad()函数外面，根本不可能修改掉_list 的值，以保证数据的安全不被污染 12345678910111213141516171819function isFirstLoad() &#123; // _list表示是私有的 var _list = []; return function (id) &#123; if (_list.indexOf(id) &gt;= 0) &#123; return false; &#125; else &#123; _list.push(id); return true; &#125; &#125;;&#125;var firstLoad = isFirstLoad();firstLoad(10); // truefirstLoad(10); // falsefirstLoad(20); // truefirstLoad(20); // false 四、异步和单线程 同步和异步的区别是什么？分别举例 一个关于 setTimeout 的笔试题 前端使用异步的场景有哪些 什么是异步（对比同步）判断有没有阻塞 异步：无阻塞，我走我的，走完之后回来再说，等着执行，但是不卡在那儿，等着但不闲着 123456console.log(100);setTimeout(function () &#123; console.log(200); // 未阻塞，没有在这儿停顿1s并打印200&#125;, 1000);console.log(300);// 100 300 200 同步：有阻塞，会阻塞下面代码的执行 123console.log(100);alert(200); // 1秒后点击确认console.log(300); 前端使用异步的场景在可能发生等待的情况，等待过程中不能像 alert 一样阻塞程序运行，因此，所有的等待情况都需要异步 定时任务：setTimeout、setInterval 网络请求：Ajax 请求（请求 Google CDN），动态&lt;img&gt;加载 1234567// Ajax请求democonsole.log(\"start\");$.get(\"./data1.json\", function (data1) &#123; console.log(data1);&#125;);console.log(\"end\");// start end 等待Ajax执行 123456789// &lt;img&gt;加载democonsole.log(\"start\");var img = document.createElement(\"img\");img.onload = function () &#123; console.log(\"loaded\");&#125;;img.src = \"/xxx.png\";console.log(\"end\");// start end 等待图片加载 事件绑定 可执行多次，可以点击再点击，而前 2 个场景只能执行 1 次 1234567// 事件绑定democonsole.log(\"start\");document.getElementById(\"btn1\").addEventListener(\"click\", function () &#123; alert(\"clicked\");&#125;);console.log(\"end\");// start end 等待元素点击事件发生 异步和单线程的实现原理执行顺序 demo12345console.log(100);setTimeout(function () &#123; console.log(200);&#125;);console.log(300); 执行第一行，打印 100 执行 setTimeout 后，传入 setTimeout 的函数会被暂存起来，不会立即执行 单线程的特点，不能同时干两件事 执行最后一行，打印 300 待所有程序执行完，处于空闲状态时，会立马看有没有暂存起来的任务要执行 发现暂存起来的 setTimeout 中的函数无需等待时间，就立即来过来执行 执行顺序原理 所有异步中的函数都会被拿出去暂时不执行，让它们等待 所有的异步都是有函数的 只是暂存，并不排成队列 所有同步任务执行完后，要看边上有没有等待的程序在执行 所有异步等待的任务，同时判断是否满足以下条件，不管排队或者代码书写先后 是否有等待时间 发送的请求是否正确返回 绑定事件是否发生 若有，则被封禁，等待事件发生时解禁执行异步任务 若无，则一直处于解禁状态，直接执行等待的异步任务 什么是单线程 单线程一次只能干一件事，只能一个一个任务排队来，不能同时执行两个任务 JavaScript 是单线程的，但是又不能让程序阻塞卡顿，所以必须异步 题目解答 同步和异步的区别是什么？分别举例 同步会阻塞代码执行，而异步不会 alert 是同步，setTimeout 是异步 一个关于 setTimeout 的笔试题 12345678910console.log(1);setTimeout(function () &#123; console.log(2);&#125;, 0);console.log(3);setTimeout(function () &#123; console.log(4);&#125;, 1000);console.log(5);// 1 3 5 2 1s后打印4 前端使用异步的场景有哪些 定时任务：setTimeout、setInverval 网络请求：Ajax 请求、动态&lt;img&gt;加载 事件绑定 五、其它（如日期、Math、各种常用 API） 获取 2017-06-10 格式的日期 获取随机数，要求是长度一致的字符串格式 写一个能遍历对象和数组的通用 forEach 函数 日期12345678910111213141516// Date是个构造函数// now是个属性，但也是个函数// 所以Date.now()也是个函数// 1552272178876// 获取当前时间毫秒数Date.now();// Mon Mar 11 2019 10:42:17 GMT+0800 (CST)// 会自动执行toString()，转化为字符串格式var dt = new Date();dt.getTime(); // 获取毫秒数dt.getFullYear(); // 年dt.getMonth(); // 月（0-11）从0开始的，比较特殊，需要+1dt.getDate(); // 日（0-31）dt.getHours(); // 小时（0-23）dt.getMinutes(); // 分钟（0-59）dt.getSeconds(); // 秒（0-59） Math 获取随机数 Math.random() 返回 0-1 之间的一个小数，位数不确定，一般很长，一般不会重复 常用于清除缓存 数组 APIforEach：遍历数组中所有元素1234567891011var arr = [\"a\", \"b\", \"c\"];arr.forEach(function (item, index) &#123; // 值，索引 // 遍历数组的所有元素 // item对应\"a\", \"b\", \"c\" // index对应0, 1, 2 console.log(index, item); // 0 \"a\" // 1 \"b\" // 2 \"c\"&#125;); every：判断所有元素是否都符合条件返回 true 或 false 12345678var arr = [1, 2, 3];var result = arr.every(function (item, index) &#123; // 用来判断所有的数组元素，都满足一个条件 if (item &lt; 4) &#123; return true; &#125;&#125;);console.log(result); // true some：判断是否有至少一个元素符合条件返回 true 或 false 12345678var arr = [1, 2, 3];var result = arr.some(function (item, index) &#123; // 用来判断所有的数组元素，只要有一个满足条件即可 if (item &lt; 2) &#123; return true; &#125;&#125;);console.log(result); // true sort：排序 改变原数组 可对真实数据大小进行排序而不是 ACSII 码 12345678var arr = [1, 4, 2, 3, 5];var arr2 = arr.sort(function (a, b) &#123; // 从小到大 return a - b; // 从大到小 return b - a;&#125;);console.log(arr2); map：对元素重新组装 不改变原数组 返回符合条件的数组 123456var arr = [1, 2, 3, 4];var arr2 = arr.map(function (item, index) &#123; // 将元素重新组装，并返回 return \"&lt;b&gt;\" + item + \"&lt;/b&gt;\";&#125;);console.log(arr2); fileter：过滤符合条件的元素 不改变原数组 返回符合条件的数组 12345678var arr = [1, 2, 3];var arr2 = arr.filter(function (item, index) &#123; // 通过某一个条件过滤数组 if (item &gt;= 2) &#123; return true; &#125;&#125;);console.log(arr2); 对象 APIfor in：遍历对象中所有属性12345678910111213141516var obj = &#123; x: 100, y: 200, z: 300,&#125;;var key;for (key in obj) &#123; // key就是obj的属性名，即x, y, z // 注意这里的hasOwnProperty,在讲原型链时候讲过 if (obj.hasOwnProperty(key)) &#123; console.log(key, obj[key]); &#125;&#125;// x 100// y 200// z 300 题目解答 获取 2017-06-10 格式的日期 123456789101112131415161718192021function formatDate(dt) &#123; if (!dt) &#123; dt = new Date(); &#125; var year = dt.getFullYear(); var month = dt.getMonth() + 1; // 一定要+1 var date = dt.getDate(); if (month &lt; 10) &#123; // 强制类型转换 month = \"0\" + month; &#125; if (date &lt; 10) &#123; // 强制类型转换 date = \"0\" + date; &#125; // 强制类型转换 return year + \"-\" + month + \"-\" + date;&#125;var dt = new Date();var date = formatDate(dt);console.log(date); 获取随机数，要求是长度一致的字符串格式 12345// 所有需要统一数字位数的情况都可以使用如下方法var random = Math.random();var random = random + \"0000000000\"; // 后面加10个零var random = random.slice(0, 10); // 取前10位console.log(random); 写一个能遍历对象和数组的通用 forEach 函数 123456789101112131415161718192021222324252627function forEach(obj, fn) &#123; var key; if (obj instanceof Array) &#123; // 准确判断是不是数组 obj.forEach(function(item, index)) &#123; fn(index, item); &#125; &#125; else &#123; // 不是数组就是对象 for (key in obj) &#123; fn(key, obj[key]); &#125; &#125;&#125;var arr = [1, 2, 3];// 注意，这里参数的顺序换了，为了和对象的遍历格式一致forEach(arr, function(index, item) &#123; console.log(index, item);&#125;)var obj = &#123; x: 100, y: 200&#125;forEach(arr, function(key, value) &#123; console.log(key, value);&#125;) 六、JS-Web-API DOM&amp;BOM DOM 是哪种基本的数据结构？ DOM 操作常用 API 有哪些？ DOM 节点的 attr 和 property 有何区别？ 如何检测浏览器的类型？ 拆解 URL 的各个部分 回顾 JS 基础知识特点：表面看来并不能用于工作中开发代码 内置函数：Object、Array、Boolean、String 等 内置对象：Math、JSON 等 我们连在网页弹出一句 hello world 都不能实现 常说的 JS（浏览器执行的 JS）包含两部分：JS 基础知识（ECMA262 标准）和 JS-Web-API（W3C 标准） JS 基础知识 ：ECMA262 标准，只是一个规则 JS-Web-API：W3C 标准，没有规定任何 JS 基础相关的东西，不管什么变量类型、原型、作用域和异步，只管定义用于浏览器中 JS 操作页面的 API 和全局变量 W3C 标准中关于 JS 的规定有：DOM 操作、BOM 操作、事件绑定、Ajax 请求（包括 http 协议）等 NodeJS 因为是基于 JS 所以符合 ECMA262 标准，但是其服务于服务器端，没有 window、document 等，而是有 network、service 等，不符合 W3C 标准 全面考虑，JS 内置的全局函数和对象有哪些？ 之前讲过的 Object、Array、Boolean、String、Math、JSON 刚刚提到的 window、document 所有未定义的全局变量，如 navigator.userAgent DOM 本质XML 是一种可扩展的描述语言，可以描述任何结构化的数据 数据结构：树 HTML 是 XML 的一种特殊类型 DOM：浏览器把拿到的 HTML 代码，结构化一个浏览器能识别并且JS 可操作的一个模型 Document 文档 Object 对象 Modal 模型 DOM 节点操作获取 DOM 节点QuerySelector/QuerySelectorAll 和 getElementById/getElementsByClassName 的区别 12345678// div1、divList、containerList、pList都是JS对象var div1 = document.getElementById(\"div1\"); // 元素var divList = document.getElementByTagName(\"div\"); // 集合console.log(divList.length);console.log(divList[0]);var containerList = document.getElementByClassName(\".container\"); // 集合var pList = document.querySelectorAll(\"p\"); // 集合 property 文档直接修改，查看源码即可看到修改 修改的是 JS 对象的标准属性，有关 JS 的属性 12345678910var pList = document.querySelectorAll(\"p\"); // 集合var p = pList[0];console.log(p.style.width); // 获取样式p.style.width = \"100px\"; // 修改样式console.log(p.className); // 获取classp.className = \"p1\"; // 修改class// 获取nodeName和nodeTypeconsole.log(p.nodeClass);console.log(p.nodeType); Attribute 文档直接修改，查看源码即可看到修改 修改的是 HTML 代码文档内的标签，有关文档内标签的属性 setAttribute 原本没有的标签属性会自动添加 123456var pList = document.querySelectorAll(\"p\"); // 集合var p = pList[0];p.getAttribute(\"data-name\");p.setAttribute(\"data-name\", \"imooc\");p.getAttribute(\"style\");p.setAttribute(\"style\", \"font-size:30px;\"); DOM 结构操作针对树的操作 获取父元素12var div1 = document.getElementById(\"div1\");var parent = div1.parentElement; 获取子元素在使用 childNodes 获取子元素时，换行也会算作 1 个 text，计为 1 个 Node 123456var div1 = document.getElementById(\"div1\");var child = div1.childNodes;console.log(child[0].nodeType); // text 3console.log(child[1].nodeType); // p 1 标签都是1console.log(child[0].nodeName); // text #textconsole.log(child[1].nodeName); // p P 新增节点123456789var div1 = document.getElementById(\"div1\");// 添加新节点var p1 = document.createElement(\"p\");p1.innerHTML = \"this is p1\";div1.appendChild(p1); // 添加新创建的元素// 移动已有节点var p2 = document.getElementById(\"p2\");div1.appendChild(p2); 删除节点123var div1 = document.getElementById(\"div1\");var child = div1.childNodes;div1.removeChild(child[0]); // 可能看不到效果，因为删除的child[0]可能是1个因换行引起的text Node BOM Browser 浏览器 Object 对象 Model 模型 navigator123var ua = navigator.userAgent;var isChrome = ua.indexof(\"Chrome\");console.log(isChrome); screen12console.log(screen.width);console.log(screen.height); location123456console.log(location.href); // 整个urllocation.protocol; //协议：http or httpslocation.host; // 域名location.pathname; // 路径location.search; // ?后的参数location.hash; // #后面是哈希 history12history.back(); // 返回history.forward(); // 前进 题目解答 DOM 是哪种基本的数据结构？ 树 DOM 操作常用 API 有哪些？ 获取 DOM 节点以及节点的 property 和 Attribute 获取父节点、子节点 新增节点和删除节点 DOM 节点的 attr 和 property 有何区别？ property 只是一个 JS 对象的属性的修改和获取 Attribute 是对 HTML 标签属性的修改和获取 如何检测浏览器的类型？ 123var ua = navigator.userAgent;var isChrome = ua.indexof(\"Chrome\");console.log(isChrome); 拆解 URL 的各个部分 123456console.log(location.href); // 整个urllocation.protocol; //协议：http or httpslocation.host; // 域名location.pathname; // 路径location.search; // ?后的参数location.hash; // #后面是哈希 七、事件 编写一个通用的事件监听函数 描述事件冒泡过程 对于一个无限下拉加载图片的页面，如何给每个图片绑定事件 通用事件绑定关于低版本 IE 兼容性问题 IE 低版本使用 attachEvent，和 W3C 标准不一样 IE 低版本使用量非常少，很多网站早已不支持 12345678910111213var btn = document.getElementById(\"btn1\");btn.addEventListener(\"click\", function (event) &#123; console.log(\"clicked\");&#125;);// 封装function bindEvent(elem, type, fn) &#123; elem.addEventListener(type, fn);&#125;var a = document.getElementById(\"link1\");bindEvent(a, \"click\", function (e) &#123; e.preventDefault(); // 阻止默认行为，比如：阻止a标签的跳转 alert(\"clicked\");&#125;); 事件冒泡 顺着 DOM 的顺序结构，底层叶节点的点击事件会一层一层根据顺序结构往其父元素上触发 点击 p1 后往上冒泡：触发 p1 的 click 事件 -&gt; 触发 div1 的 click 事件 -&gt; 触发 body 的 click 事件 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=\"div1\"&gt; &lt;p id=\"p1\"&gt;激活&lt;/p&gt; &lt;p id=\"p2\"&gt;取消&lt;/p&gt; &lt;p id=\"p3\"&gt;取消&lt;/p&gt; &lt;p id=\"p4\"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id=\"div2\"&gt; &lt;p id=\"p5\"&gt;取消&lt;/p&gt; &lt;p id=\"p6\"&gt;取消&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var p1 = document.getElementById(\"p1\"); var body = document.body; bindEvent(p1, \"click\", function (e) &#123; e.stopPropagation(); // 阻止冒泡 alert(\"激活\"); &#125;); bindEvent(body, \"click\", function (e) &#123; alert(\"取消\"); &#125;);&lt;/script&gt; 代理是什么 事件冒泡的应用：通过事件冒泡机制，在元素的上层增加事件绑定机制，代理到每个元素上 目的 代码简洁，减少浏览器内存占用 12345678910111213141516171819&lt;body&gt; &lt;div id=\"div1\"&gt; &lt;a href=\"#\"&gt;a1&lt;/a&gt; &lt;a href=\"#\"&gt;a2&lt;/a&gt; &lt;a href=\"#\"&gt;a3&lt;/a&gt; &lt;a href=\"#\"&gt;a4&lt;/a&gt; &lt;!-- 会随时新增更多a标签 --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div1 = document.getElementById(\"div1\"); div1.addEventListener(\"click\", function (e) &#123; var target = e.target; if (target.nodeName === \"A\") &#123; alert(target.innerHTML); &#125; &#125;);&lt;/script&gt; 完善版本 1234567891011121314151617function bindEvent(elem, type, selector, fn) &#123; if (fn == null) &#123; fn = selector; selector = null; &#125; elem.addEventListener(type, function (e) &#123; var target; if (selector) &#123; target = e.target; if (target.matches(selector)) &#123; fn.call(target, e); // this = target &#125; else &#123; fn(e); &#125; &#125; &#125;);&#125; 123456789// 使用代理bindEvent(a, \"click\", \"a\", function (e) &#123; console.log(this.innerHTML);&#125;);// 不使用代理bindEvent(a, \"click\", function (e) &#123; console.log(this.innerHTML);&#125;); 题目解答 编写一个通用的事件监听函数 描述事件冒泡过程 DOM 树形结构 -&gt; 事件冒泡 -&gt; 阻止冒泡 -&gt; 冒泡的应用（代理） 对于一个无限下拉加载图片的页面，如何给每个图片绑定事件 使用代理 八、Ajax &amp; 跨域 手动编写一个 Ajax，不依赖第三方库 跨域的几种实现方式 XMLHttpRequest IE 低版本使用 ActiveXObject，和 W3C 标准不同 1234567891011var xhr = new XMLHttpRequest();xhr.open(\"GET\", \"/app\", false); // false 异步xhr.onreadystatechange = function () &#123; // 这里的函数异步执行，可参考之前JS基础中的异步模块 if (xhr.readyState == 4) &#123; if (xhr.state == 200) &#123; alert(xhr.responseText); &#125; &#125;&#125;;xhr.send(null); 状态码说明xhr.readyState == 4 状态码 状态 说明 0 未初始化 还没有调用 send()方法 1 载入 已调用 send()方法，正在发生请求 2 载入完成 send()方法执行完成，已接收到全部相应内容 3 交互 正在解析相应内容 4* 完成 响应内容解析完成，可以在客户端调用了 xhr.status == 200 状态码 说明 2xx 表示成功处理请求，如 200 3xx 需要重定向，浏览器直接跳转 4xx 客户端请求错误，如 404 5xx 服务端错误 跨域什么是跨域浏览器有同源策略，不允许 Ajax 访问其他域接口 跨域条件 协议 域名 端口（HTTP 默认 80；HTTPS 默认 443） 有一个不同就算跨域 http://www.yourname.com/page1.html http://m.imooc.com/course/ajaxcourserecom?cid45 但是有三个标签允许跨域加载资源 &lt;img src = xxx&gt;用于打点统计，统计网站可能是其他域，防盗链 &lt;link href = xxx&gt;、&lt;script src = xxx&gt;可以使用 CDN，CDN 的也是其他域 &lt;script src = xxx&gt;script 可以用于 JSONP 注意事项： 所有跨域请求都必须经过信息提供方允许 如果未经允许即可获取，那是浏览器同源策略出现漏洞 JSONP实现原理加载 http://codeing.m.imooc.com/classindex.html 不一定服务器端真正有一个 classindex.html 服务器可以根据请求，动态生成一个文件，返回 同理于&lt;script src = &#39;http://coding.m.imooc.com/api.js&#39;&gt; 例如你的网站要跨域访问慕课网的一个接口 慕课给你一个地址 http://coding.m.mooc.com/api.js 返回内容格式如callback({x:100, y:200})（可动态生成） 1234567&lt;script&gt; window.callback = function (data) &#123; // 这里是我们跨域得到的信息 console.log(data) &#125;&lt;/script&gt;&lt;script src=\"http://coding.m.imooc.com/api.js\"&gt;&lt;/script&gt; 服务器端设置 http header跨域趋势，简洁方法，服务端设置 1234567response.setHeader(\"Access-Control-Allow-Origin\", \"http://a.com\");response.setHeader(\"Access-Control-Allow-Headers\", \"X-Requestd-Width\");response.setHeader( \"Access-Control-Allow-Method\", \"PUT,POST,GET,DELETE,OPTIONS\");response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); // 接受宽裕的cookie 题目解答 手动编写一个 Ajax，不依赖第三方库 跨域的几种实现方式 JSONP 服务器端设置 http header 九、存储 请描述下 cookie、sessionStorage 和 localStorage 的区别 cookie 本身用于客户端和服务端通讯 但它有本地存储的功能，于是就被借用了 使用document.cookie = xxx获取修改即可 缺点 存储量太小，4kb 所有 http/Ajax 请求都带着，影响获取资源效率 API 简单，需要封装才能用 document.cookie localStorage HTML5 专门为存储而设计，最大容量 5M API 简单易用 iOS safari 隐藏模式下，localstorage.getItem会报错，建议统一使用 try-catch 封装 12localStorage.setItem(key, value);localStorage.getItem(key); sessionStorage HTML5 专门为存储而设计，最大容量 5M API 简单易用 浏览器关了会清零 12sessionStorage.setItem(key, value);sessionStorage.getItem(key); 题目解答 请描述下 cookie、sessionStorage 和 localStorage 的区别 容量 是否会携带到 Ajax 中 cookie 会携带，sessionStorage 和 localStorage 不会携带 API 易用性 十、开发环境 关于开发环境 面试官放通过开发环境了解面试者的经验 开发环境最能体现工作产出效率 会以聊天的形式为主，而不是出具体的问题 IDE（开发工具，写代码的效率） Git（代码版本管理，多人协作开发） JS 模块化 打包工具 上线回滚的流程 IDE webstorm sublime vscode atom 插件 Git 正式项目都需要代码版本管理 大型项目需要多人协作开发 Git 和 linux 是一个作者 网络 Git 服务器，如 coding.net 和 github.com 一般公司代码非开源，都有自己的 Git 服务器 搭建 Git 服务器无需了解太多 Git 的基本操作必须很熟练 命令 说明 git status 查看状态 git diff 查看两个文件的不同 git checkout xxx (file name) 发现自己改错了，需要还原 git add . 将所有修改的东西全部囊括进来 git commit -m “xxx” 修改的内容提交到本地仓库，-m 代表添加的备注 git push origin master 提交到远程仓库 git pull origin master 别人修改代码，从远程下载已修改的代码 git clone 克隆新的项目 git branch 查看当前分支 git checkout -b xxx 新建一个分支 git checkout xxx (branch name) 切换到一个已有的分支 git merge xxx 合并分支 123456echo \"# test\" &gt;&gt; README.mdgit initgit add README.mdgit commit -m \"first commit\"git remote add origin git@github.com:kxbk100/test.gitgit push -u origin master 模块化不使用模块化 依赖层级引用关系 代码中的函数必须是全局变量，才能暴露给使用方面，所以全局变量污染，不清楚各个文件间的依赖关系 a.js 知道要引用 a-util.js，但是不知道其还需要依赖 util.js util.js 12345function getFormatDate(date, type) &#123; // type === 1 返回 2017-06-15 // type === 2 返回 2017年6月15日 // ...&#125; a-util.js 1234function aGetFormatDate(date) &#123; // 要求返回 2017年6月15日 格式 return getFormatDate(date, 2);&#125; a.js 12var dt = new Date();console.log(aGetFormatDate(dt)); date.html 顺序不能颠倒 3 个文件之间是强依赖关系 123&lt;script src=\"util.js\"&gt;&lt;/script&gt;&lt;script src=\"a-util.js\"&gt;&lt;/script&gt;&lt;script src=\"a.js\"&gt;&lt;/script&gt; 使用模块化 只往外 s 输出 1 个函数 在另一个文件中再接收 直接&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt; ，其他的根据依赖关系自动引用 前 2 个函数，没必要做成全局变量，不会带来污染和覆盖 util.js 1234567export &#123; getFormatDate: function(date, type) &#123; // type === 1 返回 2017-06-15 // type === 2 返回 2017年6月15日 // ... &#125;&#125; a-util.js 1234567var getFormatDate = require('util.js');export &#123; aGetFormatDate: function (date) &#123; // 要求返回 2017年6月15日 格式 return getFormatDate(date, 2) &#125;&#125; a.js 123var aGetFormatDate = require(\"a-util.js\");var dt = new Date();console.log(aGetFormatDate(dt)); AMD 异步模块定义 require.js 全局定义 define 函数 全局定义 require 函数 依赖 js 会自动、异步加载，不使用就不加载，提升性能 return 一个对象 只有先 define 才能被 require util.js 123456789101112define(function () &#123; return &#123; getFormateDate: function (date, type) &#123; if (type == 1) &#123; return \"2017-06-15\"; &#125; if (type == 2) &#123; return \"2017年6月15日\"; &#125; &#125;, &#125;;&#125;); a-util.js 1234567define([\"./util.js\"], function (util) &#123; return &#123; aGetFormatDate: function (date) &#123; return util.getFormatDate(date, 2); &#125;, &#125;;&#125;); a.js 1234567define([\"./a-util.js\"], function (aUtil) &#123; return &#123; printDate: function (date) &#123; console.log(aUtil.aGetFormatDate); &#125;, &#125;;&#125;); main.js 1234require([\"./a.js\"], function (a) &#123; var date = new Date(); a.printDate(date);&#125;); main.html 12&lt;script src=\"/require.min.js\" data-main=\"./main.js\"&gt;&lt;/script&gt;// 定义程序入口 a.js 1234567define([\"./util.js\"], function (util) &#123; return &#123; aGetFormateDate: function (date) &#123; return util.getFormateDate(); &#125;, &#125;;&#125;); main.js 1234567define([\"./a.js\"], function (a) &#123; return &#123; printDate: function (date) &#123; console.log(autil.aGetFormateDate(date)); &#125;, &#125;;&#125;); CommonJS nodejs 模块化规范，现在被大量用于前端 前端开发依赖的插件和库，都可以从 npm 中获取 构建工具的高度自动化，使得使用 npm 的成本非常低 CommonJS 不会异步加载 JS，而是同步一次性加载进来 exports 输出出一个东西，var require 接收一个东西 util.js 12345678910module.exports = &#123; getFormateDate: function (date, type) &#123; if (type == 1) &#123; return \"2017-06-15\"; &#125; if (type == 2) &#123; return \"2017年6月15日\"; &#125; &#125;,&#125;; a-uril.js 123456var util = require(\"util.js\");module.export = &#123; aGetFormateDate: function (date) &#123; return util.getFormateDate(date, 2); &#125;,&#125;; AMD 和 CommonJS 的使用场景 需要异步加载，用 AMD 不需要异步加载 JS，用 CommonJS 使用 npm 之后使用 CommonJS 构建工具(对模块化的代码打包和压缩)构建工具 grunt（没人用） gulp fis3 webpack 构建的意义 模块化打包 支持 CommonJS CommonJS 受 nodeJS 支持 后端放到前端来用需要兼容 webpack 封装了很多方法，支持通过 CommonJS 的方式来运行在前端 安装 -&gt; 配置 -&gt; 处理一个简单事例 -&gt; 得到结果 安装 nodeJS 安装 Node.js 进入文件目录 初次使用安装 http-server sudo npm install http-server -g 使用http-server -p 8881生成服务 这个服务只能针对静态页面的编辑，nodejs 或者 php 的修改无法使用 安装 webpack 进入文件目录 初始化环境npm init 自动生成 package.json 文件 安装包npm install webpack --save-dev，-dev表示仅用于开发环境 安装包npm install jquery --save，任何环境都需要 卸载包npm uninstall moment --save 配置 webpack 新建 webpack.config.js，与 index.html 和 package.json 同级 12345678910111213var path = require(\"path\");var webpack = require(\"webpack\");module.exports = &#123; context: path.resolve(__dirname, \"./src\"), // __dirname：前端目录 entry: &#123; app: \"./app.js\", &#125;, output: &#123; path: path.resolve(__dirname, \"./dist\"), filename: \"bundle.js\", &#125;,&#125;; 新建 src 文件夹，在其中创建 app.js 入口文件 在 package.json 的 script 中新增 1\"start\": \"webpack\" // 将start指定为webpack 在 index.html 中，引入 bundle.js 访问页面 使用 jQuery 在 app.js 中添加 1var $ = require(\"jquery\"); // 它会从package.json中的dependencies中查找安装的jQuery 自己写模块可以根据相对路径获取 1var aUtil = require(\"./a-util.js\"); npm start打包 压缩 jQuery 安装 UglifyJS Webpack Plugin 1$ npm install uglifyjs-webpack-plugin --save-dev 修改 webpack.config.json 如下 123456789101112131415161718192021222324var path = require(\"path\");var webpack = require(\"webpack\");var uglifyJsPlugin = require(\"uglifyjs-webpack-plugin\");module.exports = &#123; context: path.resolve(__dirname, \"./src\"), // __dirname：前端目录 entry: &#123; app: \"./app.js\", &#125;, output: &#123; path: path.resolve(__dirname, \"./dist\"), filename: \"bundle.js\", &#125;, //压缩js optimization: &#123; minimizer: [ new uglifyJsPlugin(&#123; uglifyOptions: &#123; compress: false, &#125;, &#125;), ], &#125;,&#125;; npm start打包 上限回滚流程介绍 是非常重要的开发环节 各个公司的具体流程不同 由专门的工具负责系统完成，我们无需关心细节 如果没有参与过，面试时也要说出要点 只讲要点，具体实现无法讲解 上线和回滚的基本流程上线 将测试完成的代码提交到 git 版本库的 master 分支 将当前服务器的代码全部打包并记录版本号（1.0），备份 将 master 分支的代码提交到服务器覆盖到线上服务器，生成新版本号（1.1） 回滚 将当前服务器的代码打包并记录版本号（1.1），备份 将备份的上一个版本号解压（1.0），覆盖到线上服务器，并生成新的版本号（1.2） linux 基本命令 服务器使用 Linux 居多，server 版，只有命令行 测试环境要匹配线上环境，因此也是 Linux 经常需要登录测试机来自己配置，获取数据 常用命令 mkdir a ls ll cd a pwd 查看路径 rm -rf a vi a.js 输入：i 保存：esc :w 退出：esc :q 保存并退出：esc :wq cat a.js 查看文件 cp a.js a1.js 拷贝 mv a1.js src/a1.js rm a.js 十一、运行环境 从输入 url 到得到 html 的详细过程 window.load 和 DOMContentLoaded 的区别 页面加载过程 浏览器就可以通过访问链接来得到页面的内容 通过绘制和渲染，显示出页面的最终的样子 加载资源的形式 输入 url 或跳转页面加载 html http://coding.m.imooc.com 加载 html 的静态资源&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt; 加载一个资源的过程 浏览器根据 DNS 服务器得到域名的 IP 地址 向这个 IP 的机器发送http 请求 服务器收到处理并返回http 请求 浏览器得到返回内容 浏览器渲染页面的过程 根据 HTML 结构生成 DOM Tree 根据 CSS 生成 CSSOM 将 DOM 和 CSSOM 整合形成 Render Tree（渲染树） 根据 Render Tree 开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染 因为 JS 会改变 DOM 结构及内容，所以两者不能同时进行 将 CSS 放于 head 中，加载完 CSS 后浏览器直接知道规则，在渲染 body 中的元素时，已将 CSS 考虑进去渲染 将 CSS 放于 body 尾部，元素先按照默认加载，然后再根据 CSS 进行改变，性能较差 将 script 放于 body 尾部，可以拿到所有 DOM 标签和结构，不会阻塞 body 上面的元素的渲染，性能较优 &lt;p&gt;&lt;img src=&quot;XXX&quot; /&gt;&lt;/p&gt;img DOM 元素会顺序生成，但图片 src 异步加载 性能优化原则 多使用内存、缓存或者其他方法 减少 CPU 计算、减少网络请求、减少 IO 操作（前端不考虑） 从哪里入手加载页面和静态资源静态资源的压缩合并（打包合并+代码压缩） 手动合并效率低、会出错，一般用构建工具合并 3 个文件需要发 3 个请求，每个请求都会耗费很多时间 1 个文件只需发送 1 个请求 12345&lt;script src=\"a.js\"&gt;&lt;/script&gt;&lt;script src=\"b.js\"&gt;&lt;/script&gt;&lt;script src=\"c.js\"&gt;&lt;/script&gt;// 打包合并后&lt;script src=\"abc.js\"&gt;&lt;/script&gt; 静态资源缓存 通过链接名称控制缓存，&lt;script src=“abc_1.js”&gt;&lt;/script&gt; 只有内容改变的时候，链接名称才会改变，&lt;script src=&quot;abc_2.js&quot;&gt;&lt;/script&gt; 使用 CDN 不同地域的资源优化 让资源加载更快 使用 SSR 后端渲染 现在 Vue React 提出了这样的概念 其实 jsp php asp 都属于后端渲染 数据直接输出到 HTML 中 页面渲染CSS 放前面，js 放后面 懒加载 图片懒加载、下拉加载更多 给 src 赋值一个很小的图 真正的图片放在一个 data 后面 用的时候再把 data 属性赋值到 src 中 加快页面渲染速度 12345&lt;img id=\"img1\" src=\"preview.png\" data-realsrc=\"abc.png\" /&gt;&lt;script&gt; var img1 = document.getElementById(\"img1\"); img1.src = img1.getAttribute(\"data-realsrc\");&lt;/script&gt; 减少 DOM 操作 缓存 DOM 查询，减少 DOM 查询，对 DOM 查询做缓存 123456789101112// 未缓存DOM查询var i;for (i = 0; i &lt; document.getElementsByTagName(\"p\").length; i++) &#123; // TODO&#125;// 缓存了DOM查询var pList = document.getElementsByTagName(\"p\");var i;for (i = 0; i &lt; pList.length; i++) &#123; // TODO&#125; 合并 DOM 插入，减少 DOM 操作，多个操作尽量合并在一起执行 123456789101112var listNode = document.getElementById(\"list\");// 创建1个片段var frag = document.createDocumentFragment();var x, li;for (x = 0; x &lt; 10; x++) &#123; li = document.createElement(\"li\"); li.innerHTML = \"List item\" + x; // 插入片段 frag.appendChild(li);&#125;// 最后将片段直接插入正文listNode.appendChild(frag); 事件节流 合并频繁操作 很快的连着的操作，快速打字先不触发 1234567891011var textaarea = document.getElementById(\"text\");var timeoutId;textaarea.addEventListener(\"keyup\", function () &#123; if (timeoutId) &#123; clearTimeout(timeoutId); &#125; timeoutId = setTimeout(function () &#123; // 触发change事件 console.log(\"用户停止打字，开始触发事件\"); &#125;, 100);&#125;); 尽早执行操作 12345678window.addEventListener(\"load\", function () &#123; // 页面全部加载完之后才会执行，包括图片、视频等&#125;);document.addEventListener(\"DOMContentLoaded\", function () &#123; // DOM渲染完即可执行，此时图片、视频还可能没有加载完 // jQuery、zepto均使用此方法&#125;); 安全性XSS 跨站请求攻击 在新浪博客写一篇文章，同时偷偷插入一段&lt;script&gt; 攻击代码中，获取 cookie，发送到自己的服务器 发布博客，有人查看博客内容 会把查看者的 cookie 发送到攻击者的服务器 预防 前端替换关键字，例如替换&lt;为&lt;、&gt;为&gt;（配合） 后端替换（建议） CSRF 跨站请求伪造 你已登录一个购物网站，正在浏览器商品 该网站付费接口是 xxx.com/pay?id=100 ，但是没有任何验证 然后你收到一封邮件，隐藏着&lt;img src=xxx&gt; 你查看邮件的时候，就已经悄悄的付费购买了 预防 增加验证流程，如输入指纹、密码、短信验证码等 面试技巧简历 简洁明了，重点突出项目经历和解决方案 把个人博客放在简历中，并且定期维护更新博客 把个人的开源项目放在简历中，并维护开源项目 简历千万不要造假，要保持能力和经历上的真实性 过程中 如何看待加班？加班就像借钱，救急不救穷 千万不可挑战面试官，不要反铐面试官 学会给面试官惊喜，但不要太多 遇到不会回答的问题，说出你知道的就可以 谈谈你的缺点：说说你最近正在学什么就可以了 可能对 React 不是很了解，最近正在学 React，大约 1 个月后就能做出 1 个 React 的网站 题目解答 从输入 url 到得到 html 的详细过程 浏览器根据 DNS 服务器得到域名的 IP 地址 向这个 IP 的机器发送 http 请求 服务器收到处理并返回 http 请求 浏览器得到返回内容 window.load 和 DOMContentLoaded 的区别 12345678window.addEventListener(\"load\", function () &#123; // 页面全部加载完之后才会执行，包括图片、视频等&#125;);document.addEventListener(\"DOMContentLoaded\", function () &#123; // DOM渲染完即可执行，此时图片、视频还可能没有加载完 // jQuery、zepto均使用此方法&#125;);","categories":[],"tags":[]},{"title":"【JavaScript】原型与原型链","slug":"yuque/【JavaScript】原型与原型链","date":"2020-04-05T00:55:21.000Z","updated":"2020-06-07T13:19:53.225Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】原型与原型链/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】原型与原型链/","excerpt":"","text":"title: 【JavaScript】原型与原型链date: 2019年04月08日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 构造函数 是什么 构造函数首字母大写 构造函数类似于模板 组合 new 一个构造函数，返回一个对象的过程new 一个对象是什么 根据构造函数模板创建一个对象 new 一个对象顺序 new 的时候把参数传入也可不传 new 函数执行时，创建一个空对象 this 指向这个新对象this = {} 执行代码，即对 this.name 等开始顺序赋值 赋值完后，默认 return this 赋值给f，f.name、f.age、f.class生效 123456789function Foo(name, age) &#123; this.name = name; this.age = age; this.class = \"class-1\"; // return this //默认有这一行&#125;var f = new Foo(\"zhangsan\", 20);// var f1 = new Foo('lisi', 23); 可创建多个对象 Tips var a = {}其实是var a = new Object()的语法糖 var a = []其实是var a = new Array()的语法糖 var Foo = funtion () {...}其实是var Foo = new Function(){...}的语法糖 所有的引用类型（对象、数组、函数）都有构造函数 推荐使用前者的写法 使用instanceof判断一个函数是否是一个变量的构造函数 原型 涉及面试题：如何理解原型？如何理解原型链？ 是什么 当我们创建一个对象时 let obj = { age: 25 }，我们可以发现能使用很多种函数，但是我们明明没有定义过它们 当我们在浏览器中打印 obj 时你会发现，在 obj 上居然还有一个 __proto__ 属性，那么看来之前的疑问就和这个属性有关系了。 其实每个 JS 对象都有 __proto__ 属性，这个属性指向了原型。这个属性在现在来说已经不推荐直接去使用它了，这只是浏览器在早期为了让我们访问到内部属性 [[prototype]] 来实现的一个东西。 讲到这里好像还是没有弄明白什么是原型，接下来让我们再看看 __proto__ 里面有什么吧。 看到这里你应该明白了，原型也是一个对象，并且这个对象中包含了很多函数，所以我们可以得出一个结论：对于 obj 来说，可以通过 __proto__ 找到一个原型对象，在该对象中定义了很多函数让我们来使用。 在上面的图中我们还可以发现一个 constructor 属性，也就是构造函数 打开 constructor 属性我们又可以发现其中还有一个 prototype 属性，并且这个属性对应的值和先前我们在 __proto__ 中看到的一模一样。所以我们又可以得出一个结论：原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型，但是并不是所有函数都具有这个属性，Function.prototype.bind() 就没有这个属性。 其实原型就是那么简单，接下来我们再来看一张图，相信这张图能让你彻底明白原型和原型链 看完这张图，我再来解释下什么是原型链吧。其实原型链就是多个对象通过 __proto__ 的方式连接了起来。为什么 obj 可以访问到 valueOf 函数，就是因为 obj 通过原型链找到了 valueOf 函数。 对于这一小节的知识点，总结起来就是以下几点： Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它 Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它 Function.prototype.__proto__ === Object.prototype Object.prototype.__proto__ === null 函数的 prototype 是一个对象 对象的__proto__是一个对象 对象的 __proto__ 属性指向原型， __proto__ 将对象和原型连接起来组成了原型链 原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型 组合 原型链 f.toString() -&gt; f.__proto__ -&gt; Foo.prototype -&gt; 无toString属性 -&gt; Foo.prototype是一个对象 -&gt; Foo.prototype.__proto -&gt; Object.prototype -&gt; `f.proto.proto__` Object.prototype.__proto__ = null 12345678910111213141516// 构造函数function Foo(name, age) &#123; this.name = name;&#125;Foo.prototype.alertName = function () &#123; alert(this.name);&#125;;// 创建实例var f = new Foo(\"zhangsan\");f.printName = function () &#123; console.log(this.name);&#125;;// 测试f.printName();f.alertName();f.toString(); // 要去f.__proto__.__proto__中查找 5 条原型规则和示例 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（null除外） 123456var obj = &#123;&#125;;obj.a = 100;var arr = [];arr.a = 100;function fn() &#123;&#125;fn.a = 100; 所有的引用类型，都有一个__proto__属性（隐式原型属性），属性值是一个普通的对象 123console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__); 所有函数，都有一个prototype属性（显式原型属性），属性值是一个普通的对象 Number、String、Boolean、Object、Array、Function、Date、RegExp、Error（一定要大写）都是函数 1console.log(fn.prototype); 所有引用类型，__proto__属性值指向（完全等===）他的构造函数的prototype属性值 1console.log(obj.__proto__ === Object.prototype); 当试图得到一个对象的某个属性时，若果这个对象本身没有这个属性，那么它的__proto__（即它的构造函数的prototype）中寻找 123456789101112131415// 构造函数function Foo(name, age) &#123; this.name = name;&#125;Foo.prototype.alertName = function () &#123; alert(this.name);&#125;;// 创建实例var f = new Foo(\"zhangsan\");f.printName = function () &#123; console.log(this.name);&#125;;// 测试f.printName();f.alertName(); f 本身没有alertName的属性，所以会去 f 的隐式原型__proto__中去寻找，f 的隐式原型__proto__即为其构造函数 Foo 的显式原型prototype，Foo 的显式原型已被扩展了alertName的属性，所以可顺利执行 this 永远指向对象本身，在执行f.alertName()的时候会执行到第 6 行alert(this.name)，但是这里的 this 还是 f 本身 循环对象自身属性 从上述代码中可得 f 拥有三个属性：name、printName、alertName 但我们往往希望拿到对象本身定义的属性，而不要来自其原型的属性 12345678var item;for (item in f) &#123; // 高级浏览器已经在for in中屏蔽了来自原型的属性 // 但这里建议大家加上这个判断，保证程序的健壮性以满足浏览器的兼容性 if (f.hasOwnProperty(item)) &#123; console.log(item); &#125;&#125; instanceof 是什么 用于判断引用类型属于哪个构造函数的方法 目的 如果我们想判断一个对象的正确类型，这时候可以考虑使用 instanceof，因为内部机制是通过原型链来判断的，在后面我们也会自己去实现一个 instanceof 123456789const Person = function () &#123;&#125;;const p1 = new Person();p1 instanceof Person; // truevar str = \"hello world\";str instanceof String; // falsevar str1 = new String(\"hello world\");str1 instanceof String; // true 如何达成 f instanceof Foo判断逻辑：f的__proto__一层一层往上，能否对应到Foo.prototype f instanceof Object判断逻辑：f的__proto__一层一层往上，是否对应到Object.prototype 组合 通过对象内部属性[[class]]来实现 条件 对于基本类型来说，你想直接通过 instanceof 来判断类型是不行的，当然我们还是有办法让 instanceof 判断原始类型的 123456class PrimitiveString &#123; static [Symbol.hasInstance](x) &#123; return typeof x === \"string\"; &#125;&#125;console.log(\"hello world\" instanceof PrimitiveString); // true 你可能不知道 Symbol.hasInstance 是什么东西，其实就是一个能让我们自定义 instanceof 行为的东西，以上代码等同于 typeof &#39;hello world&#39; === &#39;string&#39;，所以结果自然是 true 了。这其实也侧面反映了一个问题， instanceof 也不是百分之百可信的","categories":[],"tags":[]},{"title":"【JavaScript】其它-数组API","slug":"yuque/【JavaScript】其它-数组API","date":"2020-04-05T00:55:16.000Z","updated":"2020-06-07T13:19:53.425Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】其它-数组API/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】其它-数组API/","excerpt":"","text":"title: 【JavaScript】其它-数组APIdate: 2019年04月08日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 数组的9大操作 数组的创建1234var arrayObj = new Array(); //创建一个数组var arrayObj = new Array([size]); //创建一个数组并指定长度，注意不是上限，是长度var arrayObj = new Array(item1, item2, item3, ...); //创建一个数组并赋值var arrayObj = []; 虽然第二种方法创建数组指定了长度，但实际上所有情况下数组都是变长的，也就是说即使指定了长度为 5，仍然可以将元素存储在规定长度以外的 数组元素的添加123arrayObj.push(item1, item2, item3, ...); // 将一个或多个新元素添加到数组结尾，并返回数组新长度arrayObj.unshift(item1, item2, item3, ...); // 将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度arrayObj.splice(index, 0, item1, item2, item3, ...); // 将一个或多个新元素插入到数组的指定位置，插入位置的元素自动后移，返回包含被删除项目的新数组 splice(index, howmany, item1, item3, …) 参数 描述 index 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置，index 位会被删除 howmany 必需。要删除的项目数量。如果设置为 0，则不会删除项目 item1, …, itemX 可选。向数组添加的新项目 数组元素的删除123arrayObj.pop(); // 移除最后一个元素并返回该元素值arrayObj.shift(); // 移除最前一个元素并返回该元素值，数组中元素自动前移arrayObj.splice(deletePos, deleteCount); // 删除从指定位置deletePos开始的指定数量deleteCount的元素，数组形式返回所移除的元素 数组的截取和合并12arrayObj.slice(start, end); // 以数组的形式返回数组的一部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素arrayObj.concat([], string); // 将多个数组（也可以是字符串，或者是数组和字符串的混合）连接为一个数组，返回连接好的新的数组 数组的元素的访问12var testGetArrValue = arrayObj[1]; // 获取数组的元素值arrayObj[1] = \"这是新值\"; // 给数组元素赋予新的值 数组的拷贝目的 普通的var newarr = arr；只是一个引用，并不是真正的拷贝，真正的拷贝要用如下方法 12arrayObj.slice(0); // 返回数组的拷贝数组，注意是一个新的数组，不是指向arrayObj.concat(); // 返回数组的拷贝数组，注意是一个新的数组，不是指向 数组元素的排序12arrayObj.reverse(); // 反转元素（最前的排到最后、最后的排到最前），返回数组地址arrayObj.sort(); // 对数组元素排序，原数组改变，返回数组地址，指向原数组 sort 改变原数组 可对真实数据大小进行排序而不是 ACSII 码 12345678var arr = [1, 4, 2, 3, 5];var arr2 = arr.sort(function (a, b) &#123; // 从小到大 return a - b; // 从大到小 return b - a;&#125;);console.log(arr2); 数组元素的字符串化join()方法是一个非常实用的方法，它把当前 Array 的每个元素都用指定的字符串连接起来，然后返回连接后的字符串： 1234arrayObj.join(separator); // 返回字符串，这个字符串将数组的每一个元素值连接在一起，中间用 separator 隔开var arr = [\"A\", \"B\", \"C\", 1, 2, 3];arr.join(\"-\"); // 'A-B-C-1-2-3' 如果 Array 中的元素不是字符串，将自动转换为字符串后再连接 toLocaleString 、toString 可以看作是 join 的特殊用法，不常用; toLocaleString(): 方法可根据本地时间把 Date 对象转换为字符串，并返回结果 toString:把数组转换为字符串，并返回结果 lastIndexOf：返回在数组中搜索到的与给定参数相等的元素的最后（最大）索引 toSource(): 返回一个字符串,代表该数组的源代码，该特性是非标准的，请尽量不要在生产环境中使用它！ 数组元素定位indexOf: 与 String 类似，Array 也可以通过indexOf()来搜索一个指定的元素的位置 1234var arr = [10, 20, \"30\", \"xyz\"];arr.indexOf(10); // 元素10的索引为0arr.indexOf(30); // 元素30没有找到，返回-1arr.indexOf(\"30\"); // 元素'30'的索引为2 数组对象的 3 个属性 length 属性 length 属性表示数组的长度，即其中元素的个数 因为数组的索引总是由 0 开始，所以一个数组的上下限分别是：0 和 length-1 JavaScript 数组的 length 属性是可变的 当 length 属性被设置得更大时，整个数组的状态事实上不会发生变化，仅仅是 length 属性变大 当 length 属性被设置得比原来小时，则原先数组中索引大于或等于 length 的元素的值全部被丢失 123456789101112var arr = [12, 23, 5, 3, 25, 98, 76, 54, 56, 76]; // 定义了一个包含10个数字的数组alert(arr.length); // 显示数组的长度10arr.length = 12; // 增大数组的长度alert(arr.length); // 显示数组的长度已经变为12alert(arr[8]); // 显示第9个元素的值，为56arr.length = 5; // 将数组的长度减少到5，索引等于或超过5的元素被丢弃alert(arr[8]); // 显示第9个元素已经变为\"undefined\"arr.length = 10; // 将数组长度恢复为10alert(arr[8]); // 虽然长度被恢复为10，但第9个元素却无法收回，显示\"undefined\" JavaScript 中可以使用一个未声明过的变量，同样，也可以使用一个未定义的数组元素（指索引超过或等于 length 的元素） length 对象不仅可以显式的设置，它也有可能被隐式修改 length 属性的值将被设置为所使用元素索引的值加 1 123456789var arr = [12, 23, 5, 3, 25, 98, 76, 54, 56, 76];console.log(arr.length); // 10arr[15] = 34;console.log(arr.length); //16console.log(arr[10]); // undefineconsole.log(arr.toString());// 12,23,5,3,25,98,76,54,56,76,,,,,,34 代码中同样是先定义了一个包含 10 个数字的数组，通过 alert 语句可以看出其长度为 10 随后使用了索引为 15 的元素，将其赋值为 15，即 arr[15]=34 这时再用 alert 语句输出数组的长度，得到的是 16 多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错 JavaScript 的 Array 却不会有任何错误 但在编写代码时，不建议直接修改 Array 的大小，访问索引时要确保索引不会越界 prototype 属性 返回对象类型原型的引用 prototype 属性是 object 共有的 objectName.prototype objectName 参数是 object 对象的名称。 用 prototype 属性提供对象的类的一组基本功能 对象的新实例“继承”赋予该对象原型的操作 给数组对象添加返回数组中最大元素值的方法。要完成这一点，声明一个函数，将它加入 Array.prototype， 并使用它 1234567891011function array_max() &#123; var i, max = this[0]; for (i = 1; i &lt; this.length; i++) &#123; if (max &lt; this[i]) max = this[i]; &#125; return max;&#125;Array.prototype.max = array_max;var x = new Array(1, 2, 3, 4, 5, 6);var y = x.max(); 该代码执行后，y 保存数组 x 中的最大值，即：6 constructor 属性 表示创建对象的函数 object.constructor是对象或函数的名称 说明：constructor 属性是所有具有 prototype 的对象的成员。它们包括除 Global 和 Math 对象以外的所有 JS 固有对象。constructor 属性保存了对构造特定对象实例的函数的引用 123456789101112x = new String(\"Hi\");if (x.constructor == String) // 进行处理（条件为真） function MyFunc() &#123; // 函数体 &#125;y = new MyFunc();if (y.constructor == MyFunc) // 进行处理（条件为真） y = new Array(); 判断是否为数组 JS 因为设计上的某些缺陷，导致在对于 Array 的判断，也是颇费周折的 typeof：对于 Function， String， Number ，Undefined 等几种类型的对象来说，他完全可以胜任，但是为 Array 时，难免会让人失望 12var arr = new Array(\"1\", \"2\", \"3\", \"4\", \"5\");alert(typeof arr); // Object instanceof：运算符会返回一个Boolean值，指出对象是否是特定类的一个实例 12var arrayStr = new Array(\"1\", \"2\", \"3\", \"4\", \"5\");alert(arrayStr instanceof Array); // true 虽然此时能够完好的工作，但事实上在多个 frame 中穿梭就会产生大问题了 1234567variframe = document.createElement(\"iframe\");document.body.appendChild(iframe);xArray = window.frames[window.frames.length - 1].Array;var arr = new xArray(\"1\", \"2\", \"3\", \"4\", \"5\"); // 这个写法IE大哥下是不支持的，FF下才有alert(arr instanceof Array); // falsealert(arr.constructor === Array); // false ECMA-262 中规范定义了 Object.prototype.toString 的行为 首先，取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于[object Array]的字符串作为结果 [[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性” 利用这个方法，再配合 call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。于是利用这点，就有了下面这种方法： 123function isArray(obj) &#123; return Object.prototype.toString.call(obj) === \"[object Array]\";&#125; call 改变 toString 的 this 引用为待检测的对象，返回此对象的字符串表示 然后对此字符串是否是[object Array]，以判断其是否是 Array 的实例 为什么不直接 o.toString()？ 虽然 Array 继承自 Object，toString 方法极有可能被重写而达不到我们的要求 Object.prototype 则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性” 如此很好的解决了跨 frame 对象构建的问题，经过测试，各大浏览器兼容性也很好，可以放心使用。很多框架，比如 jQuery 等，都借鉴此方法以实现某些特殊的，比如数组、正则表达式等对象的类型判定 Array.isArray()方法用来判断某个值是否为数组。如果是，则返回 true，否则返回 false 123456789101112131415161718// 下面的函数调用都返回 trueArray.isArray([]);Array.isArray([1]);Array.isArray(new Array());// 鲜为人知的事实：其实 Array.prototype 也是一个数组Array.isArray(Array.prototype);// 下面的函数调用都返回 falseArray.isArray();Array.isArray(&#123;&#125;);Array.isArray(null);Array.isArray(undefined);Array.isArray(17);Array.isArray(\"Array\");Array.isArray(true);Array.isArray(false);Array.isArray(&#123; __proto__: Array.prototype &#125;); 数组迭代过程 filter()：过滤符合条件的元素 不改变原数组 返回符合条件的数组 filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中 12345678var arr = [1, 2, 3];var arr2 = arr.filter(function (item, index) &#123; // 通过某一个条件过滤数组 if (item &gt;= 2) &#123; return true; &#125;&#125;);console.log(arr2); 12345function isBigEnough(item) &#123; return item &gt;= 10;&#125;var filtered = [12, 5, 8, 130, 44].filter(isBigEnough);// filtered is [12, 130, 44] forEach() ：遍历数组中所有元素 forEach 方法按升序为数组中含有效值的每一项执行一次 callback 函数，那些已删除（使用 delete 方法等情况）或者从未赋值的项将被跳过（但不包括哪些值为 undefined 的项） forEach 遍历的范围在第一次调用 callback 前就会确定。调用 forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值 没有办法中止 forEach 循环 打印出数组的内容 1234567891011var arr = [\"a\", \"b\", \"c\"];arr.forEach(function (item, index) &#123; // 值，索引 // 遍历数组的所有元素 // item对应\"a\", \"b\", \"c\" // index对应0, 1, 2 console.log(index, item); // 0 \"a\" // 1 \"b\" // 2 \"c\"&#125;); 一个可以克隆对象的函数 ？ 使用下面的代码可以复制一个给定的对象，虽然有很多不同的复制对象的方法，不过下面这种方法使用了Array.prototype.forEach和其他一些 ECMAScript 5 中的 Object.*函数 1234567891011121314function copy(o) &#123; var copy = Object.create(Object.getPrototypeOf(o)); var propNames = Object.getOwnPropertyNames(o); propNames.forEach(function (name) &#123; var desc = Object.getOwnPropertyDescriptor(o, name); Object.defineProperty(copy, name, desc); &#125;); return copy;&#125;var o1 = &#123; a: 1, b: 2 &#125;;var o2 = copy(o1); // o2 looks like o1 now every()：判断所有元素是否都符合条件语法：arr.every(callback[, thisArg]) 返回 true 或 false 12345678var arr = [1, 2, 3];var result = arr.every(function (item, index) &#123; // 用来判断所有的数组元素，都满足一个条件 if (item &lt; 4) &#123; return true; &#125;&#125;);console.log(result); // true every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 false（表示可转换为布尔值 false 的值）的元素 如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用 callback 被调用时传入三个参数：元素值，元素的索引，原数组。 every 不会改变原数组 检测所有数组元素的大小 12345678//检测数组中的所有元素是否都大于 10function isBigEnough(element, index, array) &#123; return element &gt;= 10;&#125;var passed = [12, 5, 8, 130, 44].every(isBigEnough);// passed is falsepassed = [12, 54, 18, 130, 44].every(isBigEnough);// passed is true map() ：对元素重新组装语法：array.map(callback[, thisArg]) 不改变原数组 生成新数组 123456var arr = [1, 2, 3, 4];var arr2 = arr.map(function (item, index) &#123; // 将元素重新组装，并返回 return \"&lt;b&gt;\" + item + \"&lt;/b&gt;\";&#125;);console.log(arr2); map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数 callback 每次执行后的返回值组合起来形成一个新数组 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用 map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组） 在一个 String 上使用 map 方法获取字符串中每个字符所对应的 ASCII 码组成的数组 123var map = Array.prototype.map;var a = map.call(\"Hello World\", (x) =&gt; x.charCodeAt(0));// a的值为[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100] 通常情况下，map 方法中的 callback 函数只需要接受一个参数，就是正在被遍历的数组元素本身 但这并不意味着 map 只给 callback 传了一个参数。这个思维惯性可能会让我们犯一个很容易犯的错误。比如下面的语句返回什么呢 123[\"1\", \"2\", \"3\"].map(parseInt);// 你可能觉的会是[1, 2, 3]// 但实际的结果是 [1, NaN, NaN] 通常使用 parseInt 时，只需要传递一个参数，但实际上 parseInt 可以有两个参数，第二个参数是进制数。可以通过语句alert(parseInt.length === 2)来验证 map 方法在调用 callback 函数时，会给它传递 3 个参数：当前正在遍历的元素，元素索引，原数组本身 第 3 个参数 parseInt 会忽视，但第二个参数不会，也就是说 parseInt 把传过来的索引值当成进制数来使用，从而返回了 NaN。 因此此时应该使用如下的用户函数returnInt 123456function returnInt(element) &#123; return parseInt(element, 10);&#125;[\"1\", \"2\", \"3\"].map(returnInt);// 返回[1,2,3] some()：判断是否有至少一个元素符合条件语法：arr.some(callback[, thisArg]) 返回 true 或 false 12345678var arr = [1, 2, 3];var result = arr.some(function (item, index) &#123; // 用来判断所有的数组元素，只要有一个满足条件即可 if (item &lt; 2) &#123; return true; &#125;&#125;);console.log(result); // true some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值） 如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用 测试数组元素的值 12345678//检测在数组中是否有元素大于 10function isBigEnough(element, index, array) &#123; return element &gt;= 10;&#125;var passed = [2, 5, 8, 1, 4].some(isBigEnough);// passed is falsepassed = [12, 5, 8, 1, 4].some(isBigEnough);// passed is true reduce() ：接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终为一个值语法：arr.reduce(callback,[initialValue]) callback 执行数组中每个值的函数，包含四个参数 previousValue 上一次调用回调返回的值，或者是提供的初始值（initialValue） currentValue 数组中当前被处理的元素 index 当前元素在数组中的索引 array 调用 reduce 的数组 initialValue 作为第一次调用 callback 的第一个参数。 描述：reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组 回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且 currentValue 等于数组中的第一个值；如果 initialValue 未被提供，那么 previousValue 等于数组中的第一个值，currentValue 等于数组中的第二个值。 如果数组为空并且没有提供 initialValue， 会抛出 TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供 initialValue， 或者有提供 initialValue 但是数组为空，那么此唯一值将被返回并且 callback 不会被执行。 将数组所有项相加 1234var total = [0, 1, 2, 3].reduce(function (a, b) &#123; return a + b;&#125;);// total == 6 数组扁平化 12345678var flattened = [ [0, 1], [2, 3], [4, 5],].reduce(function (a, b) &#123; return a.concat(b);&#125;);// flattened is [0, 1, 2, 3, 4, 5] 统计一个数组中有多少个不重复的单词 不使用 reduce 时的写法 123456789101112var arr = [\"apple\", \"orange\", \"apple\", \"orange\", \"pear\", \"orange\"];function getWordCnt() &#123; var obj = &#123;&#125;; for (var i = 0, l = arr.length; i &lt; l; i++) &#123; var item = arr[i]; obj[item] = obj[item] + 1 || 1; &#125; return obj;&#125;console.log(getWordCnt()); 使用 reduce()后的写法 12345678var arr = [\"apple\", \"orange\", \"apple\", \"orange\", \"pear\", \"orange\"];function getWordCnt() &#123; return arr.reduce(function (prev, next) &#123; prev[next] = prev[next] + 1 || 1; return prev; &#125;, &#123;&#125;);&#125;console.log(getWordCnt()); 这其中一个需要注意的点在于，initialValue 提供与否对 prev 和 next 的影响 12345678910111213141516171819202122232425/* 二者的区别，在console中运行一下即可知晓*/var arr = [\"apple\", \"orange\", \"pear\", \"jade\"];function noPassValue() &#123; return arr.reduce(function (prev, next) &#123; console.log(\"prev:\", prev); console.log(\"next:\", next); //console.info('prev type:'+ typeof(prev)); //prev type:string return prev + \" \" + next; &#125;);&#125;function passValue() &#123; return arr.reduce(function (prev, next) &#123; console.log(\"prev:\", prev); console.log(\"next:\", next); prev[next] = 1; //console.info('prev type:'+ typeof(prev)); // object return prev; &#125;, &#123;&#125;);&#125;console.log(\"No Additional parameter:\", noPassValue());console.log(\"----------------\");console.log(\"With &#123;&#125; as an additional parameter:\", passValue()); 总结 函数名 是否改变原数组 返回值 说明 push 会改变 返回新数组长度 向数组的末尾添加一个或更多元素，并返回新的长度 pop 会改变 返回被删除元素 删除并返回数组的最后一个元素 unshift 会改变 返回新的长度 向数组的开头添加一个或更多元素，并返回新的长度 shift 会改变 返回被删除元素 删除并返回数组的第一个元素 splice 会改变 返回被删除元素组成的数组，或者为空数组 删除元素，并向数组添加新元素 reverse 会改变 返回原数组 颠倒数组中元素的顺序 sort 会改变 返回原数组 对数组的元素进行排序 join 不会改变 返回字符串 把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔 concat 不会改变 返回新数组 连接两个或更多的数组，并返回结果 indexOf 不会改变 返回数组中某个指定的元素位置，如果不存在返回 -1 查找数组中某个指定的元素位置。 lastIndexOf 不会改变 返回指定元素在数组中的最后一个的索引，如果不存在返回 -1 查找指定元素在数组中的最后一个的索引 slice 不会改变 返回一个新的数组，包含从 start 到 end （不包括该元素）中的元素 从已有的数组中返回选定的元素。-1 指字符串的最后一个字符，-2 指倒数第二个字符，以此类推 toString 不会改变 返回字符串 把数组转换为字符串，并返回结果 map 不会改变 返回处理后的数组 通过指定函数处理数组的每个元素，并返回处理后的数组 filter 不会改变 返回新数组 检测数值元素，并返回符合条件所有元素的数组 some 不会改变 返回 true 或 false 检测数组元素中是否有元素符合指定条件，有 true 的时候停止 every 不会改变 返回 true 或 false 检测数组元素中是否有元素符合指定条件，在有 false 的时候停止 reduce 不会改变 返回计算结果 将数组元素计算为一个值（从左到右） forEach 不会改变 undefined 调用数组的每个元素，并将元素传递给回调函数 上述的迭代方法可以在最后追加一个参数 thisArg,它是执行 callback 时的 this 值 参考资料 [1]https://www.jeffjade.com/2015/09/25/2015-09-25-js-array/","categories":[],"tags":[]},{"title":"【JavaScript】其它-对象API","slug":"yuque/【JavaScript】其它-对象API","date":"2020-04-05T00:55:11.000Z","updated":"2020-06-07T13:19:53.431Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】其它-对象API/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】其它-对象API/","excerpt":"","text":"title: 【JavaScript】其它-对象 APIdate: 2019 年 04 月 08 日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images for in：遍历对象中所有属性12345678910111213141516var obj = &#123; x: 100, y: 200, z: 300,&#125;;var key;for (key in obj) &#123; // key就是obj的属性名，即x, y, z // 注意这里的hasOwnProperty,在讲原型链时候讲过 if (obj.hasOwnProperty(key)) &#123; console.log(key, obj[key]); &#125;&#125;// x 100// y 200// z 300","categories":[],"tags":[]},{"title":"【JavaScript】模块化","slug":"yuque/【JavaScript】模块化","date":"2020-04-05T00:55:06.000Z","updated":"2020-06-07T13:19:53.464Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】模块化/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】模块化/","excerpt":"","text":"title: 【JavaScript】模块化date: 2019年04月08日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 模块化 涉及面试题：为什么要使用模块化？都有哪几种方式可以实现模块化，各有什么特点？ 目的 使用一个技术肯定是有原因的，那么使用模块化可以给我们带来以下好处 解决命名冲突 提高复用性 提高代码可维护性 组合 立即执行函数在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题 1234(function (globalVariable) &#123; globalVariable.test = function () &#123;&#125;; // ... 声明各种变量、函数都不会污染全局作用域&#125;)(globalVariable); AMD 和 CMD鉴于目前这两种实现方式已经很少见到，所以不再对具体特性细聊，只需要了解这两者是如何使用的。 AMD 异步加载，CommonJS 同步加载 1234567891011121314// AMDdefine([\"./a\", \"./b\"], function (a, b) &#123; // 加载模块完毕可以使用 a.do(); b.do();&#125;);// CMDdefine(function (require, exports, module) &#123; // 加载模块 // 可以把 require 写在函数体的任意地方实现延迟加载 var a = require(\"./a\"); a.doSomething();&#125;); CommonJSCommonJS 最早是 Node 在使用，目前也仍然广泛使用，比如在 Webpack 中你就能见到它，当然目前在 Node 中的模块管理已经和 CommonJS 有一些区别了。 12345678910// a.jsmodule.exports = &#123; a: 1,&#125;;// orexports.a = 1;// b.jsvar module = require(\"./a.js\");module.a; // -&gt; log 1 因为 CommonJS 还是会使用到的，所以这里会对一些疑难点进行解析 先说 require 123456789101112131415161718192021var module = require(\"./a.js\");module.a;// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，// 重要的是 module 这里，module 是 Node 独有的一个变量module.exports = &#123; a: 1,&#125;;// module 基本实现var module = &#123; id: \"xxxx\", // 我总得知道怎么去找到他吧 exports: &#123;&#125;, // exports 就是个空对象&#125;;// 这个是为什么 exports 和 module.exports 用法相似的原因var exports = module.exports;var load = function (module) &#123; // 导出的东西 var a = 1; module.exports = a; return module.exports;&#125;;// 然后当我 require 的时候去找到独特的id，然后将要使用的东西用立即执行函数包装下，over 另外虽然 exports 和 module.exports 用法相似，但是不能对 exports 直接赋值 因为 var exports = module.exports 这句代码表明了 exports 和 module.exports 享有相同地址 通过改变对象的属性值会对两者都起效 但是如果直接对 exports 赋值就会导致两者不再指向同一个内存地址，修改并不会对 module.exports 起效 ES ModuleES Module 是原生实现的模块化方案，与 CommonJS 有以下几个区别 CommonJS 支持动态导入，也就是 require(${path}/xx.js)， ES Module 目前不支持，但是已有提案 CommonJS 是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住主线程影响也不大。 ES Module 是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响 CommonJS 在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想更新值，必须重新导入一次 ES Module 采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化 ES Module 会编译成 require/exports 来执行的 123456// 引入模块 APIimport XXX from \"./a.js\";import &#123; XXX &#125; from \"./a.js\";// 导出模块 APIexport function a() &#123;&#125;export default function () &#123;&#125;","categories":[],"tags":[]},{"title":"【JavaScript】第一章 简介","slug":"yuque/【JavaScript】第一章 简介","date":"2020-04-05T00:55:01.000Z","updated":"2020-06-07T13:19:53.477Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第一章 简介/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第一章 简介/","excerpt":"","text":"1 课程简介基础知识 原型 原型链 作用域 闭包 异步 单线程 JS API DOM 操作 Ajax 事件绑定 开发环境 版本管理 模块化 打包工具 运行环境 页面渲染 性能优化 面试技巧 2 如何搞定所有面试题上一节思考问题的结论 拿到一个面试题，你第一时间看到的是什么？ 考点 如何看待网上搜出来的永远也看不完的题海？ 以不变应万变 如何对待接下来遇到的面试题？ 题目 -&gt; 考点 -&gt; 知识 -&gt; 题目 题目考察的知识点 JS 中使用 typeof 能得到哪些类型? 考点：JS 变量类型 何时使用===何时使用== ? 考点：强制类型转换 window.onload 和 DOMContentLoaded 的区别? 考点：浏览器渲染过程 用 JS 创建 10 个&lt;a&gt;标签,点击的时候弹出来对应的序号 考点：作用域 简述如何实现一个模块加载器，实现类似 require.js 的基本功能 考点：JS 模块化 实现数组的随机排序 考点：JS 基础算法 基础考点导图 扩展考点导图","categories":[],"tags":[]},{"title":"【JavaScript】第五章 异步和单线程","slug":"yuque/【JavaScript】第五章 异步和单线程","date":"2020-04-05T00:54:56.000Z","updated":"2020-06-07T13:19:53.518Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第五章 异步和单线程/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第五章 异步和单线程/","excerpt":"","text":"title: 【JavaScript】第五章 异步和单线程 date: 2019 年 04 月 08 日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 同步和异步的区别是什么？分别举例 一个关于 setTimeout 的笔试题 前端使用异步的场景有哪些 什么是异步（对比同步）判断有没有阻塞 异步：无阻塞，我走我的，走完之后回来再说，等着执行，但是不卡在那儿，等着但不闲着 123456console.log(100);setTimeout(function () &#123; console.log(200); // 未阻塞，没有在这儿停顿1s并打印200&#125;, 1000);console.log(300);// 100 300 200 同步：有阻塞，会阻塞下面代码的执行 123console.log(100);alert(200); // 1秒后点击确认console.log(300); 前端使用异步的场景在可能发生等待的情况，等待过程中不能像 alert 一样阻塞程序运行，因此，所有的等待情况都需要异步 定时任务：setTimeout、setInverval 网络请求：Ajax 请求（请求 Google CDN），动态&lt;img&gt;加载 1234567// Ajax请求democonsole.log(\"start\");$.get(\"./data1.json\", function (data1) &#123; console.log(data1);&#125;);console.log(\"end\");// start end 等待Ajax执行 123456789// &lt;img&gt;加载democonsole.log(\"start\");var img = document.createElement(\"img\");img.onload = function () &#123; console.log(\"loaded\");&#125;;img.src = \"/xxx.png\";console.log(\"end\");// start end 等待图片加载 事件绑定 可执行多次，可以点击再点击，而前 2 个场景只能执行 1 次 1234567// 事件绑定democonsole.log(\"start\");document.getElementById(\"btn1\").addEventListener(\"click\", function () &#123; alert(\"clicked\");&#125;);console.log(\"end\");// start end 等待元素点击事件发生 异步和单线程的实现原理执行顺序 demo12345console.log(100);setTimeout(function () &#123; console.log(200);&#125;);console.log(300); 执行第一行，打印 100 执行 setTimeout 后，传入 setTimeout 的函数会被暂存起来，不会立即执行 单线程的特点，不能同时干两件事 执行最后一行，打印 300 待所有程序执行完，处于空闲状态时，会立马看有没有暂存起来的任务要执行 发现暂存起来的 setTimeout 中的函数无需等待时间，就立即来过来执行 执行顺序原理 所有异步中的函数都会被拿出去暂时不执行，让它们等待 所有的异步都是有函数的 只是暂存，并不排成队列 所有同步任务执行完后，要看边上有没有等待的程序在执行 所有异步等待的任务，同时判断是否满足以下条件，不管排队或者代码书写先后 是否有等待时间 发送的请求是否正确返回 绑定事件是否发生 若有，则被封禁，等待时间发生时解禁执行异步任务 若无，则一直处于解禁状态，直接执行等待的异步任务 什么是单线程 单线程一次只能干一件事，只能一个一个任务排队来，不能同时执行两个任务 JavaScript 是单线程的，但是又不能让程序阻塞卡顿，所以必须异步 题目解答 同步和异步的区别是什么？分别举例 同步会阻塞代码执行，而异步不会 alert 是同步，setTimeout 是异步 一个关于 setTimeout 的笔试题 12345678910console.log(1);setTimeout(function () &#123; console.log(2);&#125;, 0);console.log(3);setTimeout(function () &#123; console.log(4);&#125;, 1000);console.log(5);// 1 3 5 2 1s后打印4 前端使用异步的场景有哪些 定时任务：setTimeout、setInverval 网络请求：Ajax 请求、动态&lt;img&gt;加载 事件绑定","categories":[],"tags":[]},{"title":"【JavaScript】第四章 闭包和作用域","slug":"yuque/【JavaScript】第四章 闭包和作用域","date":"2020-04-05T00:54:51.000Z","updated":"2020-06-07T13:19:53.587Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第四章 闭包和作用域/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第四章 闭包和作用域/","excerpt":"","text":"title: 【JavaScript】第四章 闭包和作用域 date: 2019 年 04 月 08 日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 说一下变量提升的理解 说明 this 几种不同的使用场景 创建 10 个&lt;a&gt;标签，点击的时候弹出来对应的序号 如何理解作用域 实际开发中闭包的应用 执行上下文（声明提升）范围：一段&lt;script&gt;或者一个函数 全局（某个&lt;script&gt;）：变量定义提前、函数声明提前 函数（函数即将执行之前）：变量定义提前、函数声明提前、确定 this 的值、确定 arguments 的值 注意：函数声明和函数表达式的区别 函数声明 1234fn(); // 不会报错，因为函数声明会提升function fn() &#123; ... // 函数声明&#125; 函数表示式 123456fn1(); // 会报错，fn1会被当做变量定义，会提升相当于var fn1 = undefined，在执行fn1();// 以下均为函数表达式，函数表达式本质上即为变量定义var a = 100;var fn1 = function () &#123; ...&#125; 假如下列代码在一个&lt;script&gt;中，在一个&lt;script&gt;中要定义一个全局的执行上下文，在执行第 1 行代码之前，会把所有的变量声明和函数声明都执行一遍，执行顺序如下： 第 2 行，变量定义 ，还未执行到此，所以不会赋值，把 a 先拿出来，用 undefined 代替来占位 第 4-8 行，函数声明，把整个函数拿出来，以此函数生效可以执行 第 1 行，undefined 第 2 行，a 被赋值成 100 第 3 行，进入函数体，函数顺利执行 第 7 行，变量定义，并用 undefined 代替来占位 第 5 行，age 被赋值成 20 第 6 行，打印 arguments 参数 12345678console.log(a); // undefinedvar a = 100;fn('zhangsan'); // 'zhangsan', 20function fn(name) &#123; age = 20; console.log(name, age); var age；&#125; 12345678910111213141516171819202122// 全局// var a = undefined;console.log(a);var a = 100;fn(\"zhangsan\");function fn(name) &#123; // 函数 // 函数代码执行之前（不是函数声明之前），就已经确定了this的值 console.log(this); // 函数代码执行之前（不是函数声明之前），就已经确定了arguments的值 // arguments：函数参数的集合体 console.log(arguments); age = 20; console.log(name, age); var age; bar(100); function bar(num) &#123; console.log(num); &#125;&#125; thisthis 要在执行时才能确定值，定义时无法确认 一个函数后面加()，即为要执行 在此之前，函数永远处于定义状态 12345678910var a = &#123; name: \"A\", fn: function () &#123; console.log(this.name); &#125;,&#125;; // 只看到这里不能确认this到底是什么a.fn(); // this === aa.fn.call(&#123; name: \"B\" &#125;); // this === &#123;name: 'B'&#125;var fn1 = a.fn;fn1(); // this === window 作为构造函执行123456function Foo(name) &#123; // this = &#123;&#125;; this.name = name; // return this;&#125;var f = new Foo(\"zhangsan\"); 作为对象属性执行1234567var obj = &#123; name: \"A\", printName: function () &#123; console.log(this.name); // this === obj &#125;,&#125;;obj.printName(); 作为普通函数执行1234function fn() &#123; console.log(this); // this === window&#125;fn(); call apply bind12345678910111213141516171819function fn1(name, age) &#123; alert(name); alert(age); console.log(this); // this === window&#125;// call表示&#123;x:100&#125;为this，'zhangsan'为第1个参数，20为第2个参数，最常用fn1.call(&#123; x: 100 &#125;, \"zhangsan\", 20);// apply将后面当做数组，相当于fn1.apply(&#123; x: 100 &#125;, ['zhangsan', 20]);fn1.apply(&#123; x: 100 &#125;, \"zhangsan\", 20);// 使用bind修改默认this，.bind必须是函数表达式var fn2 = function (name, age) &#123; alert(name); alert(age); console.log(this);&#125;.bind(&#123; y: 200 &#125;);fn2(\"zhangsan\", 20); 作用域 没有块级作用域 但有函数和全局作用域 目的 封装变量 收敛权限 在函数外面不可能修改掉函数中定义的变量的值，以保证数据的安全不被污染 12345678910111213141516171819// 没有块级作用域if (true) &#123; // 在外面定义和定义在if语句块中是一样的 // 尽量不要在块中定义变量，容易使程序不易读 var name = \"zhangsan\";&#125;console.log(name); // 'zhangsan'// 但有函数和全局作用域var a = 100;function fn() &#123; var a = 200; // 函数中也有a，则使用函数中的a = 200 // 函数中的变量值，外面是改不了的 // 所以框架的第三方库就采用将变量定义在函数中的方法来防止变量被污染，与外面隔绝 console.log(\"fn\", a);&#125;console.log(\"global\", a); // 全局 a = 100fn(); // 函数 a = 200 作用域链是什么 去父级作用域取值，根据调用回到变量定义或函数声明的地方的父作用域 目的 查找自由变量 组合 当前作用域没有定义的变量，即“自由变量” 12345678var a = 100;function fn() &#123; var b = 200; // a即为自由变量 console.log(a); // 去父级作用域取值，变量定义或函数声明时的父作用域 console.log(b);&#125;fn(); 123456789101112131415var a = 100;function F1() &#123; var b = 200; function F2() &#123; var c = 300; // a是自由变量 // 父级F1中a未定义，再在F1父级中找a，a = 100 console.log(a); // b是自由变量 console.log(b); console.log(c); &#125; F2();&#125;F1(); 闭包使用场景函数作为返回值 1234567891011121314function F1() &#123; // a是F1局部变量 var a = 100; // 返回一个函数（函数作为返回值） return function () &#123; // a是个自由变量 console.log(a); // 去父级作用域取值，声明时的父作用域 &#125;;&#125;var f1 = F1();// a是全局变量，不会影响到函数中定义的局部变量var a = 200;// 不是看此处执行时的作用域，而是回到其定义处的作用域f1(); // 100 函数作为参数传递 1234567891011121314151617function F1() &#123; // a是F1局部变量 var a = 100; // 返回一个函数（函数作为返回值） return function () &#123; // a是个自由变量 console.log(a); // 去父级作用域取值，声明时的父作用域 &#125;;&#125;var f1 = F1();function F2(fn) &#123; var a = 200; fn(); // 此处为执行作用域&#125;F2(f1); 题目解答 说一下变量提升的理解 变量定义 函数声明（注意和函数表达式的区别） 说明 this 几种不同的使用场景 构造函数 对象属性 普通函数 call apply bind 创建 10 个&lt;a&gt;标签，点击的时候弹出来对应的序号 错误写法 1234567891011var i, a;for (i = 0; i &lt; 10; i++) &#123; a = document.createElement(\"a\"); a.innerHTML = i + \"&lt;br&gt;\"; a.addEventListener(\"click\", function (e) &#123; e.preventDefault(); // i是自由变量，要去父作用域获取值，无块级作用域（for），即要找全局作用域 alert(i); &#125;); document.body.appendChild(a);&#125; 正确写法 123456789101112131415var i;for (i = 0; i &lt; 10; i++) &#123; // 自执行函数，不用调用，只要定义完成，立即执行的函数 (function (i) &#123; // 函数作用域 var a = document.createElement(\"a\"); a.innerHTML = i + \"&lt;br&gt;\"; a.addEventListener(\"click\", function (e) &#123; e.preventDefault(); // i是自由变量，要去父作用域获取值，无块级作用域（for），即要找全局作用域 alert(i); &#125;); document.body.appendChild(a); &#125;)(i);&#125; 如何理解作用域 自由变量 作用域链，即自由变量的查找 闭包的两个场景 实际开发中闭包的应用 闭包实际应用主要用于封装变量，收敛权限 闭包的意义：你在 isFirstLoad()函数外面，根本不可能修改掉_list 的值，以保证数据的安全不被污染 12345678910111213141516171819function isFirstLoad() &#123; // _list表示是私有的 var _list = []; return function (id) &#123; if (_list.indexOf(id) &gt;= 0) &#123; return false; &#125; else &#123; _list.push(id); return true; &#125; &#125;;&#125;var firstLoad = isFirstLoad();firstLoad(10); // truefirstLoad(10); // falsefirstLoad(20); // truefirstLoad(20); // false","categories":[],"tags":[]},{"title":"【JavaScript】第十章 存储","slug":"yuque/【JavaScript】第十章 存储","date":"2020-04-05T00:54:46.000Z","updated":"2020-06-07T13:19:53.602Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第十章 存储/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第十章 存储/","excerpt":"","text":"title: 【JavaScript】第十章 存储 date: 2019 年 04 月 08 日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 请描述下 cookie、sessionStorage 和 localStorage 的区别 cookie 本身用于客户端和服务端通讯 但它有本地存储的功能，于是就被借用了 使用document.cookie = xxx获取修改即可 缺点 存储量太小，4kb 所有 http/Ajax 请求都带着，影响获取资源效率 API 简单，需要封装才能用 document.cookie localStorage HTML5 专门为存储而设计，最大容量 5M API 简单易用 iOS safari 隐藏模式下，localstorage.getItem会报错，建议统一使用 try-catch 封装 12localStorage.setItem(key, value);localStorage.getItem(key); sessionStorage HTML5 专门为存储而设计，最大容量 5M API 简单易用 浏览器关了会清 0 12sessionStorage.setItem(key, value);sessionStorage.getItem(key); 题目解答 请描述下 cookie、sessionStorage 和 localStorage 的区别 容量 是否会携带到 Ajax 中 cookie 会携带，sessionStorage 和 localStorage 不会携带 API 易用性","categories":[],"tags":[]},{"title":"【JavaScript】第十一章 运行环境","slug":"yuque/【JavaScript】第十一章 运行环境","date":"2020-04-05T00:54:41.000Z","updated":"2020-06-07T13:19:53.668Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第十一章 运行环境/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第十一章 运行环境/","excerpt":"","text":"title: 【JavaScript】第十一章 运行环境date: 2019年04月08日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 从输入url到得到html的详细过程 window.load和DOMContentLoaded的区别 页面加载过程 浏览器就可以通过访问链接来得到页面的内容 通过绘制和渲染，显示出页面的最终的样子 加载资源的形式 输入 url 或跳转页面加载 html http://coding.m.imooc.com 加载 html 的静态资源&lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt; 加载一个资源的过程 浏览器根据 DNS 服务器得到域名的 IP 地址 向这个 IP 的机器发送 http 请求 服务器收到处理并返回 http 请求 浏览器得到返回内容 浏览器渲染页面的过程 根据 HTML 结构生成 DOM Tree 根据 CSS 生成 CSSOM 将 DOM 和 CSSOM 整合形成 Render Tree（渲染树） 根据 Render Tree 开始渲染和展示 遇到&lt;script&gt;时，会执行并阻塞渲染 因为 JS 会改变 DOM 结构及内容，所以两者不能同时进行 将 CSS 放于 head 中，加载完 CSS 后浏览器直接知道规则，在渲染 body 中的元素时，已将 CSS 考虑进去渲染 将 CSS 放于 body 尾部，元素先按照默认加载，然后再根据 CSS 进行改变，性能较差 将 script 放于 body 尾部，可以拿到所有 DOM 标签和结构，不会阻塞 body 上面的元素的渲染，性能较优 &lt;p&gt;&lt;img src=&quot;XXX&quot; /&gt;&lt;/p&gt;img DOM 元素会顺序生成，但图片 src 异步加载 性能优化 原则 多使用内存、缓存或者其他方法 减少 CPU 计算、减少网络请求、减少 IO 操作（前端不考虑） 从哪里入手加载页面和静态资源静态资源的压缩合并（打包合并+代码压缩） 手动合并效率低、会出错，一般用构建工具合并 3 个文件需要发 3 个请求，每个请求都会耗费很多时间 1 个文件只需发送 1 个请求 12345&lt;script src=\"a.js\"&gt;&lt;/script&gt;&lt;script src=\"b.js\"&gt;&lt;/script&gt;&lt;script src=\"c.js\"&gt;&lt;/script&gt;// 打包合并后&lt;script src=\"abc.js\"&gt;&lt;/script&gt; 静态资源缓存 通过链接名称控制缓存，&lt;script src=“abc_1.js”&gt;&lt;/script&gt; 只有内容改变的时候，链接名称才会改变，&lt;script src=&quot;abc_2.js&quot;&gt;&lt;/script&gt; 使用 CDN 不同地域的资源优化 让资源加载更快 使用 SSR 后端渲染 现在 VUe React 提出了这样的概念 其实 jsp php asp 都属于后端渲染 数据直接输出到 HTML 中 页面渲染CSS 放前面，js 放后面 懒加载 图片懒加载、下拉加载更多 给 src 赋值一个很小的图 真正的图片放在一个 data 后面 用的时候再把 data 属性赋值到 src 中 加快页面渲染速度 12345&lt;img id=\"img1\" src=\"preview.png\" data-realsrc=\"abc.png\" /&gt;&lt;script&gt; var img1 = document.getElementById(\"img1\"); img1.src = img1.getAttribute(\"data-realsrc\");&lt;/script&gt; 减少 DOM 操作 缓存 DOM 查询，减少 DOM 查询，对 DOM 查询做缓存 123456789101112// 未缓存DOM查询var i;for (i = 0; i &lt; document.getElementsByTagName(\"p\").length; i++) &#123; // TODO&#125;// 缓存了DOM查询var pList = document.getElementsByTagName(\"p\");var i;for (i = 0; i &lt; pList.length; i++) &#123; // TODO&#125; 合并 DOM 插入，减少 DOM 操作，多个操作尽量合并在一起执行 123456789101112var listNode = document.getElementById(\"list\");// 创建1个片段var frag = document.createDocumentFragment();var x, li;for (x = 0; x &lt; 10; x++) &#123; li = document.createElement(\"li\"); li.innerHTML = \"List item\" + x; // 插入片段 frag.appendChild(li);&#125;// 最后将片段直接插入正文listNode.appendChild(frag); 事件节流 合并频繁操作 很快的连着的操作，快速打字先不触发 1234567891011var textaarea = document.getElementById(\"text\");var timeoutId;textaarea.addEventListener(\"keyup\", function () &#123; if (timeoutId) &#123; clearTimeout(timeoutId); &#125; timeoutId = setTimeout(function () &#123; // 触发change事件 console.log(\"用户停止打字，开始触发事件\"); &#125;, 100);&#125;); 尽早执行操作 12345678window.addEventListener(\"load\", function () &#123; // 页面全部加载完之后才会执行，包括图片、视频等&#125;);document.addEventListener(\"DOMContentLoaded\", function () &#123; // DOM渲染完即可执行，此时图片、视频还可能没有加载完 // jQuery、zepto均使用此方法&#125;); 安全性 XSS 跨站请求攻击 在新浪博客写一篇文章，同时偷偷插入一段&lt;script&gt; 攻击代码中，获取 cookie，发送到自己的服务器 发布博客，有人查看博客内容 会把查看者的 cookie 发送到攻击者的服务器 预防 前端替换关键字，例如替换&lt;为&lt;、&gt;为&gt;（配合） 后端替换（建议） XSRF 跨站请求伪造 你已登录一个购物网站，正在浏览器商品 该网站付费接口是 xxx.com/pay?id=100 ，但是没有任何验证 然后你收到一封邮件，隐藏着&lt;img src=xxx&gt; 你查看邮件的时候，就已经悄悄的付费购买了 预防 增加验证流程，如输入指纹、密码、短信验证码等 面试技巧 简历 简洁明了，重点突出项目经历和解决方案 把个人博客放在简历中，并且定期维护更新博客 把个人的开源项目放在简历中，并维护开源项目 简历千万不要造假，要保持能力和经历上的真实性 过程中 如何看待加班？加班就像借钱，救急不救穷 千万不可挑战面试官，不要反铐面试官 学会给面试官惊喜，但不要太多 遇到不会回答的问题，说出你知道的就可以 谈谈你的缺点：说说你最近正在学什么就可以了 可能对 React 不是很了解，最近正在学 React，大约 1 个月后就能做出 1 个 React 的网站 题目解答 从输入 url 到得到 html 的详细过程 浏览器根据 DNS 服务器得到域名的 IP 地址 向这个 IP 的机器发送 http 请求 服务器收到处理并返回 http 请求 浏览器得到返回内容 window.load 和 DOMContentLoaded 的区别 12345678window.addEventListener(\"load\", function () &#123; // 页面全部加载完之后才会执行，包括图片、视频等&#125;);document.addEventListener(\"DOMContentLoaded\", function () &#123; // DOM渲染完即可执行，此时图片、视频还可能没有加载完 // jQuery、zepto均使用此方法&#125;);","categories":[],"tags":[]},{"title":"【JavaScript】第十二章 开发环境","slug":"yuque/【JavaScript】第十二章 开发环境","date":"2020-04-05T00:54:37.000Z","updated":"2020-06-07T13:19:53.771Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第十二章 开发环境/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第十二章 开发环境/","excerpt":"","text":"title: 【JavaScript】第十二章 开发环境date: 2019年04月08日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 关于开发环境 面试官放通过开发环境了解面试者的经验 开发环境最能体现工作产出效率 会以聊天的形式为主，而不是出具体的问题 IDE（开发工具，写代码的效率） Git（代码版本管理，多人协作开发） JS 模块化 打包工具 上线回滚的流程 IDE webstorm sublime vscode atom 插件 Git 正式项目都需要代码版本管理 大型项目需要多人协作开发 Git 和 linux 是一个作者 网络 Git 服务器，如 coding.net 和 github.com 一般公司代码非开源，都有自己的 Git 服务器 搭建 Git 服务器无需了解太多 Git 的基本操作必须很熟练 命令 说明 git status 查看状态 git diff 查看两个文件的不同 git checkout xxx (file name) 发现自己改错了，需要还原 git add . 将所有修改的东西全部囊括进来 git commit -m “xxx” 修改的内容提交到本地仓库，-m 代表添加的备注 git push origin master 提交到远程仓库 git pull origin master 别人修改代码，从远程下载已修改的代码 git clone 克隆新的项目 git branch 查看当前分支 git checkout -b xxx 新建一个分支 git checkout xxx (branch name) 切换到一个已有的分支 git merge xxx 合并分支 123456echo &quot;# test&quot; &gt;&gt; README.mdgit initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@github.com:kxbk100/test.gitgit push -u origin master 模块化 不使用模块化 依赖层级引用关系 代码中的函数必须是全局变量，才能暴露给使用方面，所以全局变量污染，不清楚各个文件间的依赖关系 a.js 知道要引用 a-util.js，但是不知道其还需要依赖 util.js util.js 12345function getFormatDate(date, type) &#123; // type === 1 返回 2017-06-15 // type === 2 返回 2017年6月15日 // ...&#125; a-util.js 1234function aGetFormatDate(date) &#123; // 要求返回 2017年6月15日 格式 return getFormatDate(date, 2);&#125; a.js 12var dt = new Date();console.log(aGetFormatDate(dt)); date.html 顺序不能颠倒 3 个文件之间是强依赖关系 123&lt;script src=\"util.js\"&gt;&lt;/script&gt;&lt;script src=\"a-util.js\"&gt;&lt;/script&gt;&lt;script src=\"a.js\"&gt;&lt;/script&gt; 使用模块化 只往外 s 输出 1 个函数 在另一个文件中再接收 直接&lt;script src=&quot;a. js&quot;&gt;&lt;/script&gt; ，其他的根据依赖关系自动引用 前 2 个函数，没必要做成全局变量，不会带来污染和覆盖 util.js 1234567export &#123; getFormatDate: function(date, type) &#123; // type === 1 返回 2017-06-15 // type === 2 返回 2017年6月15日 // ... &#125;&#125; a-util.js 1234567var getFormatDate = require('util.js');export &#123; aGetFormatDate: function (date) &#123; // 要求返回 2017年6月15日 格式 return getFormatDate(date, 2) &#125;&#125; a.js 123var aGetFormatDate = require(\"a-util.js\");var dt = new Date();console.log(aGetFormatDate(dt)); AMD 异步模块定义 require.js 全局定义 define 函数 全局定义 require 函数 依赖 js 会自动、异步加载，不使用就不加载，提升性能 return 一个对象 只有先 define 才能被 require util.js 123456789101112define(function () &#123; return &#123; getFormateDate: function (date, type) &#123; if (type == 1) &#123; return \"2017-06-15\"; &#125; if (type == 2) &#123; return \"2017年6月15日\"; &#125; &#125;, &#125;;&#125;); a-util.js 1234567define([\"./util.js\"], function (util) &#123; return &#123; aGetFormatDate: function (date) &#123; return util.getFormatDate(date, 2); &#125;, &#125;;&#125;); a.js 1234567define([\"./a-util.js\"], function (aUtil) &#123; return &#123; printDate: function (date) &#123; console.log(aUtil.aGetFormatDate); &#125;, &#125;;&#125;); main.js 1234require([\"./a.js\"], function (a) &#123; var date = new Date(); a.printDate(date);&#125;); main.html 12&lt;script src=\"/require.min.js\" data-main=\"./main.js\"&gt;&lt;/script&gt;// 定义程序入口 a.js 1234567define([\"./util.js\"], function (util) &#123; return &#123; aGetFormateDate: function (date) &#123; return util.getFormateDate(); &#125;, &#125;;&#125;); main.js 1234567define([\"./a.js\"], function (a) &#123; return &#123; printDate: function (date) &#123; console.log(autil.aGetFormateDate(date)); &#125;, &#125;;&#125;); CommonJS nodejs 模块化规范，现在被大量用于前端 前端开发依赖的插件和库，都可以从 npm 中获取 构建工具的高度自动化，使得使用 npm 的成本非常低 CommonJS 不会异步加载 JS，而是同步一次性加载进来 exports 输出出一个东西，var require 接收一个东西 util.js 12345678910module.exports = &#123; getFormateDate: function (date, type) &#123; if (type == 1) &#123; return \"2017-06-15\"; &#125; if (type == 2) &#123; return \"2017年6月15日\"; &#125; &#125;,&#125;; a-uril.js 123456var util = require(\"util.js\");module.export = &#123; aGetFormateDate: function (date) &#123; return util.getFormateDate(date, 2); &#125;,&#125;; AMD 和 CommonJS 的使用场景 需要异步加载，用 AMD 不需要异步加载 JS，用 CommonJS 使用 npm 之后使用 CommonJS 构建工具(对模块化的代码打包和压缩) 构建工具 grunt（没人用） gulp fis3 webpack 构建的意义 模块化打包 支持 CommonJS CommonJS 受 nodeJS 支持 后端放到前端来用需要兼容 webpack 封装了很多方法，支持通过 CommonJS 的方式来运行在前端 安装 -&gt; 配置 -&gt; 处理一个简单事例 -&gt; 得到结果 安装 nodeJS 安装 Node.js 进入文件目录 初次使用安装 http-server sudo npm install http-server -g 使用http-server -p 8881生成服务 这个服务只能针对静态页面的编辑，nodejs 或者 php 的修改无法使用 安装 webpack 进入文件目录 初始化环境npm init 自动生成 package.json 文件 安装包npm install webpack --save-dev，-dev表示仅用于开发环境 安装包npm install jquery --save，任何环境都需要 卸载包npm uninstall moment --save 配置 webpack 新建 webpack.config.js，与 index.html 和 package.json 同级 12345678910111213var path = require(\"path\");var webpack = require(\"webpack\");module.exports = &#123; context: path.resolve(__dirname, \"./src\"), // __dirname：前端目录 entry: &#123; app: \"./app.js\", &#125;, output: &#123; path: path.resolve(__dirname, \"./dist\"), filename: \"bundle.js\", &#125;,&#125;; 新建 src 文件夹，在其中创建 app.js 入口文件 在 package.json 的 script 中新增 1\"start\": \"webpack\" // 将start指定为webpack 在 index.html 中，引入 bundle.js 访问页面 使用 jQuery 在 app.js 中添加 1var $ = require(\"jquery\"); // 它会从package.js中的dependencies中查找安装的juqery 自己写模块可以根据相对路径获取 1var aUtil = require(\"./a-util.js\"); npm start打包 压缩 jQuery 安装 UglifyJS Webpack Plugin 1$ npm install uglifyjs-webpack-plugin --save-dev 修改 webpack.config.json 如下 123456789101112131415161718192021222324var path = require(\"path\");var webpack = require(\"webpack\");var uglifyJsPlugin = require(\"uglifyjs-webpack-plugin\");module.exports = &#123; context: path.resolve(__dirname, \"./src\"), // __dirname：前端目录 entry: &#123; app: \"./app.js\", &#125;, output: &#123; path: path.resolve(__dirname, \"./dist\"), filename: \"bundle.js\", &#125;, //压缩js optimization: &#123; minimizer: [ new uglifyJsPlugin(&#123; uglifyOptions: &#123; compress: false, &#125;, &#125;), ], &#125;,&#125;; npm start打包 上限回滚流程介绍 是非常重要的开发环节 各个公司的具体流程不同 由专门的工具负责系统完成，我们无需关心细节 如果没有参与过，面试时也要说出要点 只讲要点，具体实现无法讲解 上线和回滚的基本流程上线 将测试完成的代码提交到 git 版本库的 master 分支 将当前服务器的代码全部打包并记录版本号（1.0），备份 将 master 分支的代码提交到服务器覆盖到线上服务器，生成新版本号（1.1） 回滚 将当前服务器的代码打包并记录版本号（1.1），备份 将备份的上一个版本号解压（1.0），覆盖到线上服务器，并生成新的版本号（1.2） linux 基本命令 服务器使用 Linux 居多，server 版，只有命令行 测试环境要匹配线上环境，因此也是 Linux 经常需要登录测试机来自己配置，获取数据 常用命令 mkdir a ls ll cd a pwd 查看路径 rm -rf a vi a.js 输入：i 保存：esc :w 退出：esc :q 保存并退出：esc :wq cat a.js 查看文件 cp a.js a1.js 拷贝 mv a1.js src/a1.js rm a.js","categories":[],"tags":[]},{"title":"【JavaScript】第三章 原型与原型链","slug":"yuque/【JavaScript】第三章 原型与原型链","date":"2020-04-05T00:54:31.000Z","updated":"2020-06-07T13:19:53.846Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第三章 原型与原型链/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第三章 原型与原型链/","excerpt":"","text":"如何准确判断一个变量是数组类型 写一个原型链继承的例子 描述 new 一个对象的过程 zepto（或其他框架）源码中如何使用原型链 构造函数 构造函数首字母大写 构造函数类似于模板 new 一个构造函数，返回一个对象的过程 new 的时候把参数传入也可不传 new 函数执行时，创建一个空对象 this 指向这个新对象this = {} 执行代码，即对 this.name 等开始顺序赋值 赋值完后，默认 return this 赋值给f，f.name、f.age、f.class生效 12345678function Foo(name, age) &#123; this.name = name; this.age = age; this.class = \"class-1\"; // return this //默认有这一行&#125;var f = new Foo(\"zhangsan\", 20);// var f1 = new Foo('lisi', 23); 可创建多个对象 Tips var obj = {}其实是var obj = new Object()的语法糖 var arr = []其实是var arr = new Array()的语法糖 var fn = funtion () {...}其实是var fn = new Function()的语法糖 所有的引用类型（对象、数组、函数）都有构造函数 推荐使用前者的写法 原型5 条原型规则和示例 所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（null除外） 123456var obj = &#123;&#125;;obj.a = 100;var arr = [];arr.a = 100;var fn = function () &#123;&#125;;fn.a = 100; 所有的引用类型，都有一个__proto__属性（隐式原型属性），属性值是一个普通的对象 123console.log(obj.__proto__);console.log(arr.__proto__);console.log(fn.__proto__); 所有函数，都有一个prototype属性（显式原型属性），属性值是一个普通的对象 Number、String、Boolean、Object、Array、Function、Date、RegExp、Error（一定要大写）都是函数 1console.log(fn.prototype); 所有引用类型，__proto__属性值指向（完全等===）他的构造函数的prototype属性值 1console.log(obj.__proto__ === Object.prototype); 当试图得到一个对象的某个属性时，若果这个对象本身没有这个属性，那么在它的__proto__（即它的构造函数的prototype）中寻找 123456789101112131415// 构造函数function Foo(name, age) &#123; this.name = name;&#125;Foo.prototype.alertName = function () &#123; alert(this.name);&#125;;// 创建实例var f = new Foo(\"zhangsan\");f.printName = function () &#123; console.log(this.name);&#125;;// 测试f.printName();f.alertName(); f 本身没有alertName的属性，所以会去 f 的隐式原型__proto__中去寻找，f 的隐式原型__proto__即为其构造函数 Foo 的显式原型prototype，Foo 的显式原型已被扩展了alertName的属性，所以可顺利执行 this 永远指向对象本身，在执行f.alertName()的时候会执行到第 6 行alert(this.name)，但是这里的 this 还是 f 本身 原型链 f.toString() -&gt; f.__proto__ -&gt; Foo.prototype -&gt; 无toString属性 -&gt; Foo.prototype是一个对象 -&gt; Foo.prototype.__proto__-&gt; Object.prototype -&gt; f.__proto__.__proto__ Object.prototype.__proto__ = null 12345678910111213141516// 构造函数function Foo(name, age) &#123; this.name = name;&#125;Foo.prototype.alertName = function () &#123; alert(this.name);&#125;;// 创建实例var f = new Foo(\"zhangsan\");f.printName = function () &#123; console.log(this.name);&#125;;// 测试f.printName();f.alertName();f.toString(); // 要去f.__proto__.__proto__中查找 instanceof 判断引用类型属于哪个构造函数的方法 f instanceof Foo判断逻辑：f的__proto__一层一层往上，能否对应到Foo.prototype f instanceof Object判断逻辑：f的__proto__一层一层往上，是否对应到Object.prototype 循环对象自身属性 从上述代码中可得 f 拥有三个属性：name、printName、alertName 但我们往往希望拿到对象本身定义的属性，而不要来自其原型的属性 12345678var item;for (item in f) &#123; // 高级浏览器已经在for in中屏蔽了来自原型的属性 // 但这里建议大家加上这个判断，保证程序的健壮性以满足浏览器的兼容性 if (f.hasOwnProperty(item)) &#123; console.log(item); &#125;&#125; 题目解答 如何准确判断一个变量是数组类型 123var arr = [];arr instanceof Array; //truetypeof arr; //object，typeof是无法判断数组的 写一个原型链继承的例子 面试千万不要这么写 面试写更贴近实战的例子 1234567891011121314151617// 动物function Animal() &#123; this.eat = function () &#123; console.log(\"animal eat\"); &#125;;&#125;// 狗function Dog() &#123; this.bark = function () &#123; console.log(\"dog bark\"); &#125;;&#125;Dog.prototype = new Animal();// 哈士奇var hashiqi = new Dog();hashiqi.eat();hashiqi.bark(); 1234567891011121314151617181920212223242526272829// 一个封装DOM查询的例子function Elem(id) &#123; this.elem = document.getElementById(id);&#125;Elem.prototype.html = function (val) &#123; var elem = this.elem; if (val) &#123; elem.innerHTML = val; return this; // 链式操作 &#125; else &#123; return elem.innerHTML; &#125;&#125;;Elem.prototype.on = function (type, fn) &#123; var elem = this.elem; elem.addEventListener(type, fn); return this; // 链式操作&#125;;var div1 = new Elem(\"div1\");console.log(div1.html());div1 .html(\"&lt;p&gt;hello world&lt;/p&gt;\") .on(\"click\", function () &#123; alert(\"clicked\"); &#125;) .html(\"&lt;p&gt;javascript&lt;/p&gt;\"); 描述 new 一个对象的过程 创建一个空对象 this 指向这个新对象 执行代码即对 this 赋值 返回 this zepto（或其他框架）源码中如何使用原型链 阅读源码是最高效提高技能的方式 但不能“埋头苦钻”，有技巧在其中，搜索别人的阅读体会 慕课网搜索“zepto 设计和源码分析” 在面试时说出读过源码并分享心得体会十分加分 jQuery 也可 Vue、React 不建议现在读","categories":[],"tags":[]},{"title":"【JavaScript】第七章 JS-Web-API DOM&amp;BOM","slug":"yuque/【JavaScript】第七章 JS-Web-API DOM&BOM","date":"2020-04-05T00:54:26.000Z","updated":"2020-06-07T13:19:53.911Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第七章 JS-Web-API DOM&BOM/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第七章 JS-Web-API DOM&BOM/","excerpt":"","text":"title: 【JavaScript】第七章 JS-Web-API DOM&amp;BOMdate: 2019年04月08日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images DOM是哪种基本的数据结构？ DOM操作常用API有哪些？ DOM节点的attr和property有何区别？ 如何检测浏览器的类型？ 拆解URL的各个部分 回顾JS基础知识 特点：表面看来并不能用于工作中开发代码 内置函数：Object、Array、Boolean、String 等 内置对象：Math、JSON 等 我们连在网页弹出一句 hello world 都不能实现 常说的 JS（浏览器执行的 JS）包含两部分：JS 基础知识（ECMA262 标准）和 JS-Web-API（W3C 标准） JS 基础知识 ：ECMA262 标准，只是一个规则 JS-Web-API：W3C 标准，没有规定任何 JS 基础相关的东西，不管什么变量类型、原型、作用域和异步，只管定义用于浏览器中 JS 操作页面的 API 和全局变量 W3C 标准中关于 JS 的规定有：DOM 操作、BOM 操作、事件绑定、Ajax 请求（包括 http 协议）等 NodeJS 因为是基于 JS 所以符合 ECMA262 标准，但是其服务于服务器端，没有 window、document 等，而是有 network、service 等，不符合 W3C 标准 全面考虑，JS 内置的全局函数和对象有哪些？ 之前讲过的 Object、Array、Boolean、String、Math、JSON 刚刚提到的 window、document 所有未定义的全局变量，如 navigator.userAgent DOM 本质 XML 是一种可扩展的描述语言，可以描述任何结构化的数据 数据结构：树 HTML 是 XML 的一种特殊类型 DOM：浏览器把拿到的 HTML 代码，结构化一个浏览器能识别并且JS 可操作性的一个模型 Document 文档 Object 对象 Modal 模型 DOM 节点操作 获取 DOM 节点QuerySelector/QuerySelectorAll 和 getElementById/getElementsByClassName 的区别 12345678// div1、divList、containerList、pList都是JS对象var div1 = document.getElementById(\"div1\"); // 元素var divList = document.getElementByTagName(\"div\"); // 集合console.log(divList.length);console.log(divList[0]);var containerList = document.getElementByClassName(\".container\"); // 集合var pList = document.querySelectorAll(\"p\"); // 集合 property 文档直接修改，查看源码即可看到修改 修改的是 JS 对象的标准属性，有关 JS 的属性 12345678910var pList = document.querySelectorAll(\"p\"); // 集合var p = pList[0];console.log(p.style.width); // 获取样式p.style.width = \"100px\"; // 修改样式console.log(p.className); // 获取classp.className = \"p1\"; // 修改class// 获取nodeName和nodeTypeconsole.log(p.nodeClass);console.log(p.nodeType); Attribute 文档直接修改，查看源码即可看到修改 修改的是 HTML 代码文档内的标签，有关文档内标签的属性 setAttribute 原本没有的标签属性会自动添加 123456var pList = document.querySelectorAll(\"p\"); // 集合var p = pList[0];p.getAttribute(\"data-name\");p.setAttribute(\"data-name\", \"imooc\");p.getAttribute(\"style\");p.setAttribute(\"style\", \"font-size:30px;\"); DOM 结构操作 针对树的操作 获取父元素12var div1 = document.getElementById(\"div1\");var parent = div1.parentElement; 获取子元素在使用 childNodes 获取子元素时，换行也会算作 1 个 text，计为 1 个 Node 123456var div1 = document.getElementById(\"div1\");var child = div1.childNodes;console.log(child[0].nodeType); // text 3console.log(child[1].nodeType); // p 1 标签都是1console.log(child[0].nodeName); // text #textconsole.log(child[1].nodeName); // p P 新增节点123456789var div1 = document.getElementById(\"div1\");// 添加新节点var p1 = document.createElement(\"p\");p1.innerHTML = \"this is p1\";div1.appendChild(p1); // 添加新创建的元素// 移动已有节点var p2 = document.getElementById(\"p2\");div1.appendChild(p2); 删除节点123var div1 = document.getElementById(\"div1\");var child = div1.childNodes;div1.removeChild(child[0]); // 可能看不到效果，因为删除的child[0]可能是1个因换行引起的text Node BOM Browser 浏览器 Object 对象 Modal 模型 navigator123var ua = navigator.userAgent;var isChrome = ua.indexof(\"Chrome\");console.log(isChrome); screen12console.log(screen.width);console.log(screen.height); location123456console.log(location.href); // 整个urllocation.protocol; //协议：http or httpslocation.host; // 域名location.pathname; // 路径location.search; // ?后的参数location.hash; // #后面是哈希 history12history.back(); // 返回history.forward(); // 前进 题目解答 DOM 是哪种基本的数据结构？ 树 DOM 操作常用 API 有哪些？ 获取 DOM 节点以及节点的 property 和 Attribute 获取父节点、子节点 新增节点和删除节点 DOM 节点的 attr 和 property 有何区别？ property 只是一个 JS 对象的属性的修改和获取 Attribute 是对 HTML 标签属性的修改和获取 如何检测浏览器的类型？ 123var ua = navigator.userAgent;var isChrome = ua.indexof(\"Chrome\");console.log(isChrome); 拆解 URL 的各个部分 123456console.log(location.href); // 整个urllocation.protocol; //协议：http or httpslocation.host; // 域名location.pathname; // 路径location.search; // ?后的参数location.hash; // #后面是哈希","categories":[],"tags":[]},{"title":"【JavaScript】第六章 其它-日期、Math","slug":"yuque/【JavaScript】第六章 其它-日期、Math","date":"2020-04-05T00:54:21.000Z","updated":"2020-06-07T13:19:53.919Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第六章 其它-日期、Math/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第六章 其它-日期、Math/","excerpt":"","text":"title: 【JavaScript】第六章 其它-日期、Mathdate: 2019 年 04 月 08 日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 日期12345678910111213141516// Date是个构造函数// now是个属性，但也是个函数// 所以Date.now()也是个函数// 1552272178876// 获取当前时间毫秒数Date.now();// Mon Mar 11 2019 10:42:17 GMT+0800 (CST)// 会自动执行toString()，转化为字符串格式var dt = new Date();dt.getTime(); // 获取毫秒数dt.getFullYear(); // 年dt.getMonth(); // 月（0-11）从0开始的，比较特殊，需要+1dt.getDate(); // 日（0-31）dt.getHours(); // 小时（0-23）dt.getMinutes(); // 分钟（0-59）dt.getSeconds(); // 秒（0-59） Math 获取随机数 Math.random() 返回 0-1 之间的一个小数，位数不确定，一般很长，一般不会重复 常用于清除缓存","categories":[],"tags":[]},{"title":"【JavaScript】第九章 Ajax &amp; 跨域","slug":"yuque/【JavaScript】第九章 Ajax & 跨域","date":"2020-04-05T00:54:16.000Z","updated":"2020-06-07T13:19:53.949Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第九章 Ajax & 跨域/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第九章 Ajax & 跨域/","excerpt":"","text":"title: 【JavaScript】第九章 Ajax &amp; 跨域date: 2019年04月08日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 手动编写一个Ajax，不依赖第三方库 跨域的几种实现方式 XMLHttpRequest IE 低版本使用 ActiveXObject，和 W3C 标准不同 1234567891011var xhr = new XMLHttpRequest();xhr.open(\"GET\", \"/app\", false); // false 异步xhr.onreadystatechange = function () &#123; // 这里的函数异步执行，可参考之前JS基础中的异步模块 if (xhr.readyState == 4) &#123; if (xhr.state == 200) &#123; alert(xhr.responseText); &#125; &#125;&#125;;xhr.send(null); 状态码说明 xhr.readyState == 4 状态码 状态 说明 0 未初始化 还没有调用 send()方法 1 载入 已调用 send()方法，正在发生请求 2 载入完成 send()方法执行完成，已接收到全部相应内容 3 交互 正在解析相应内容 4* 完成 响应内容解析完成，可以在客户端调用了 xhr.status == 200 状态码 说明 2xx 表示成功处理请求，如 200 3xx 需要重定向，浏览器直接跳转 4xx 客户端请求错误，如 404 5xx 服务端错误 跨域 什么是跨域浏览器有同源策略，不允许 Ajax 访问其他域接口 跨域条件 协议 域名 端口（HTTP 默认 80；HTTPS 默认 443） 有一个不同就算跨域 http://www.yourname.com/page1.html http://m.imooc.com/course/ajaxcourserecom?cid45 但是有三个标签允许跨域加载资源 &lt;img src = xxx&gt;用于打点统计，统计网站可能是其他域，防盗链 &lt;link href = xxx&gt;、&lt;script src = xxx&gt;可以使用 CDN，CDN 的也是其他域 &lt;script src = xxx&gt;script 可以用于 JSONP 注意事项： 所有跨域请求都必须经过信息提供方允许 如果未经允许即可获取，那是浏览器同源策略出现漏洞 JSONP实现原理加载 http://codeing.m.imooc.com/classindex.html 不一定服务器端真正有一个 classindex.html 服务器可以根据请求，动态生成一个文件，返回 同理于&lt;script src = &#39;http://coding.m.imooc.com/api.js&#39;&gt; 例如你的网站要跨域访问慕课网的一个接口 慕课给你一个地址 http://coding.m.mooc.com/api.js 返回内容格式如callpack({x:100, y:200})（可动态生成） 1234567&lt;script&gt; window.callback = function (data) &#123; // 这里是我们跨域得到的信息 console.log(data) &#125;&lt;/script&gt;&lt;script src=\"http://coding.m.imooc.com/api.js\"&gt;&lt;/script&gt; 服务器端设置 http header跨域趋势，简洁方法，服务端设置 1234567response.setHeader(\"Access-Control-Allow-Origin\", \"http://a.com\");response.setHeader(\"Access-Control-Allow-Headers\", \"X-Requestd-Width\");response.setHeader( \"Access-Control-Allow-Method\", \"PUT,POST,GET,DELETE,OPTIONS\");response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); // 接受宽裕的cookie 题目解答 手动编写一个 Ajax，不依赖第三方库 跨域的几种实现方式 JSONP 服务器端设置 http header","categories":[],"tags":[]},{"title":"【JavaScript】第二章 变量类型和计算","slug":"yuque/【JavaScript】第二章 变量类型和计算","date":"2020-04-05T00:54:11.000Z","updated":"2020-06-07T13:19:54.080Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第二章 变量类型和计算/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第二章 变量类型和计算/","excerpt":"","text":"title: 【JavaScript】第二章 变量类型和计算 date: 2019 年 04 月 08 日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images JS 中使用 typeof 能得到的哪些类型 何时使用===何时使用== JS 中有哪些内置函数 JS 变量按照存储方式区分为哪些类型，并描述其特点 如何理解 JSON 变量类型JS 中有 7 种内置类型，7 种内置类型又分为两大类型 基本类型/值类型：null、undefined、boolean、number、string、symbol 对象/引用类型：object 基本类型/值类型是什么 把每一个值存放在对应变量内存的位置，数据分块存放在内存中，数据之间不会相互影响 1234var a = 100;var b = a;a = 200;console.log(b); // 100 条件 原始类型存储的都是值，是没有函数可以调用的，比如undefined.toString() &#39;1&#39;.toString() 是可以使用的。在这种情况下，&#39;1&#39; 已经不是原始类型了，而是被强制转换成了 String 类型（大写）也就是引用类型，所以可以调用 toString 函数 JS 的number 类型是浮点类型的，在使用中会遇到某些 Bug NaN也属于number类型，并且NaN不等于自身 0.1 + 0.2 !== 0.3 string类型是不可变的，无论你在string类型上调用何种方法，都不会对值有改变 对于null来说，很多人会认为他是个引用类型，其实这是错误的。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来 对象/引用类型是什么 当你创建了一个引用类型 a 的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针），引用类型 a 存储的就是这个地址 1const a = []; 对于常量 a 来说，假设内存地址（指针）为 #001，那么在地址 #001 的位置存放了值 []，常量 a 存放了地址（指针） #001 当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 b 存放的地址（指针）也是 #001，当我们进行数据修改的时候，就会修改存放在地址（指针） #001 上的值，也就导致了两个变量的值都发生了改变 123const a = [];const b = a;b.push(1); 产生原因 若 a 赋值成一个对象，特别大，a 再赋值给 b，b 也会占很大的空间，不合理，所以引用类型是为了让内存共用空间，好几个变量共用 1 个内存块，节省内存空间，赋值只是变量指针的赋值，并不是每次赋值都把对象真正的值复制一份，所以值的修改相互干预 分类边界 数组array、函数function、对象object 目的 无限制扩展属性，比如说对象有个 age 属性，可以加第 2 个属性 name 属性 组合 深浅拷贝 条件 函数参数是对象的情况 1234567891011121314151617function test(person) &#123; person.age = 26; person = &#123; name: \"yyy\", age: 30, &#125;; return person;&#125;const p1 = &#123; name: \"yck\", age: 25,&#125;;const p2 = test(p1);console.log(p1); // -&gt; ?console.log(p2); // -&gt; ? 首先，函数传参是传递对象指针的副本 到函数内部修改参数的属性这步，我相信大家都知道，当前 p1 的值也被修改了 但是当我们重新为 person 分配了一个对象时就出现了分歧，请看下图 所以最后 person 拥有了一个新的地址（指针），也就和 p1 没有任何关系了，导致了最终两个变量的值是不相同的 typeof 运算符是什么 只能区分基本类型的详细类型，引用类型无法细分 分类边界 typeof对于基本类型来说，除了null都可以显示正确的类型 123456typeof null; // 'object' BUGtypeof undefined; // 'undefined'typeof true; // 'boolean'typeof 1; // 'number'typeof \"1\"; // 'string'typeof Symbol(); // 'symbol' typeof对于引用类型来说，除了函数都会显示object，所以说typeof并不能准确判断引用变量到底是什么类型。因为函数是一个十分特殊的引用类型，在 JS 中函数的地位非常高，所以需要在任何地方轻松判断出这个是函数，所以 typeof 单独把函数列出来 123typeof []; // 'object'typeof &#123;&#125;; // 'object'typeof console.log; // 'function' 组合 instanceof 类型转换是什么 在 JS 中类型转换只有三种情况 转换为布尔值 转换为数字 转换为字符串 组合 转 Boolean在条件判断时，除了undefined、null、false、NaN、&#39;&#39;、0、-0，其他所有值都转为true，包括所有对象 引用类型转基本类型引用类型在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下 如果已经是基本类型了，那就不需要转换了 调用 x.valueOf()，如果转换为基础类型，就返回转换的值 调用 x.toString()，如果转换为基础类型，就返回转换的值 如果都没有返回基本类型，就会报错 当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高 123456789101112let a = &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return \"1\"; &#125;, [Symbol.toPrimitive]() &#123; return 2; &#125;,&#125;;1 + a; // =&gt; 3 四则运算目的 字符串拼接 运算 组合 加法运算中一方为字符串，那么就会把另一方也转换为字符串 加法运算中一方不是数字或字符串，那么会将它转换为数字或字符串 1231 + \"1\"; // '11'true + true; // 24 + [1, 2, 3]; // \"41,2,3\" 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 &#39;11&#39; 对于第二行代码来说，触发特点二，所以将 true 转为数字 1 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3 条件 对于加法还需要注意这个表达式 &#39;a&#39; + + &#39;b&#39; 1\"a\" + +\"b\"; // -&gt; \"aNaN\" 因为 + &#39;b&#39; 等于 NaN，所以结果为 &quot;aNaN&quot; Tips 用 + &#39;1&#39; 的形式来快速获取 number 类型 用!!判断变量会被当做true还是false 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字 1234 * \"3\"; // 124 * []; // 04 * [1, 2]; // NaN 比较运算符是什么 == &gt; &lt; != 组合 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过 unicode 字符索引来比较 123456789let a = &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return \"1\"; &#125;,&#125;;a &gt; -1; // true 在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值 题目解答 JS 中使用 typeof 能得到的哪些类型 typeof 可以识别 6 种数据类型：number、string、boolean、object、function、undefined 何时使用===何时使用== 使用 jQuery 源码中推荐的写法，当 obj.a 为 null 或 undefined 时，看一个对象的属性是否存在或看一个函数的参数是否存在，但对象和形参必须定义，否则会报错，可简写使用==，除此外一律用=== 123456789// 看一个对象的属性是否存在if(obj.a == null) &#123; // 相当于obj.a === null || obj.a ===undefined，简写形式&#125;// 看一个函数的参数是否存在function(a, b) &#123; if(a == null) &#123;...&#125;&#125; JS 中有哪些内置函数（数据封装类对象） 都是函数 Boolean Number String Object Array Function Date RegExp Error（一定要大写） 内置对象 Math JSON JS 变量按照存储方式区分为哪些类型，并描述其特点 基本类型：数据分块存放在内存中，数据不会相互干涉 1234var a = 100;var b = a;a = 200;console.log(b); //100 引用类型：好几个变量共用 1 个内存块，节省内存空间，赋值只是变量指针的赋值，并不是真正值的拷贝，所以值的修改相互干预 1234var a = &#123; age: 20 &#125;;var b = a;b.age = 21;conlose.log(a.age); //21 如何理解 JSON JSON 只不过是一个 JS 对象而已 JSON 也是一种数据格式 Math 也是 JS 对象 12JSON.stringify(&#123; a: 10, b: 20 &#125;); //将对象转换为字符串JSON.parse('&#123;\"a\": 10,\"b\":20&#125;'); //将字符串变为对象","categories":[],"tags":[]},{"title":"【JavaScript】第八章 事件","slug":"yuque/【JavaScript】第八章 事件","date":"2020-04-05T00:54:06.000Z","updated":"2020-06-07T13:19:54.132Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】第八章 事件/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】第八章 事件/","excerpt":"","text":"title: 【JavaScript】第八章 事件 date: 2019 年 04 月 08 日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 编写一个通用的事件监听函数 描述事件冒泡过程 对于一个无限下拉加载图片的页面，如何给每个图片绑定事件 通用事件绑定关于低版本 IE 兼容性问题 IE 低版本使用 attachEvent，和 W3C 标准不一样 IE 低版本使用量非常少，很多网站早已不支持 12345678910111213var btn = document.getElementById(\"btn1\");btn.addEventListener(\"click\", function (event) &#123; console.log(\"clicked\");&#125;);// 封装function bindEvent(elem, type, fn) &#123; elem.addEventListener(type, fn);&#125;var a = document.getElementById(\"link1\");bindEvent(a, \"click\", function (e) &#123; e.preventDefault(); // 阻止默认行为，比如：阻止a标签的跳转 alert(\"clicked\");&#125;); 事件冒泡 顺着 DOM 的顺序结构，底层叶节点的点击事件会一层一层根据顺序结构往其父元素上触发 点击 p1 后往上冒泡：触发 p1 的 click 事件 -&gt; 触发 div1 的 click 事件 -&gt; 触发 body 的 click 事件 1234567891011121314151617181920212223242526&lt;body&gt; &lt;div id=\"div1\"&gt; &lt;p id=\"p1\"&gt;激活&lt;/p&gt; &lt;p id=\"p2\"&gt;取消&lt;/p&gt; &lt;p id=\"p3\"&gt;取消&lt;/p&gt; &lt;p id=\"p4\"&gt;取消&lt;/p&gt; &lt;/div&gt; &lt;div id=\"div2\"&gt; &lt;p id=\"p5\"&gt;取消&lt;/p&gt; &lt;p id=\"p6\"&gt;取消&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var p1 = document.getElementById(\"p1\"); var body = document.body; bindEvent(p1, \"click\", function (e) &#123; e.stopPropagation(); // 阻止冒泡 alert(\"激活\"); &#125;); bindEvent(body, \"click\", function (e) &#123; alert(\"取消\"); &#125;);&lt;/script&gt; 代理 事件冒泡的应用：通过事件冒泡机制，在元素的上层增加事件绑定机制 代理到某个元素上： 好处：代码简洁，减少浏览器内存占用 12345678910111213141516171819&lt;body&gt; &lt;div id=\"div1\"&gt; &lt;a href=\"#\"&gt;a1&lt;/a&gt; &lt;a href=\"#\"&gt;a2&lt;/a&gt; &lt;a href=\"#\"&gt;a3&lt;/a&gt; &lt;a href=\"#\"&gt;a4&lt;/a&gt; &lt;!-- 会随时新增更多a标签 --&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var div1 = document.getElementById(\"div1\"); div1.addEventListener(\"click\", function (e) &#123; var target = e.target; if (target.nodeName === \"A\") &#123; alert(target.innerHTML); &#125; &#125;);&lt;/script&gt; 完善版本 1234567891011121314151617function bindEvent(elem, type, selector, fn) &#123; if (fn == null) &#123; fn = selector; selector = null; &#125; elem.addEventListener(type, function (e) &#123; var target; if (selector) &#123; target = e.target; if (target.matches(selector)) &#123; fn.call(target, e); // this = target &#125; else &#123; fn(e); &#125; &#125; &#125;);&#125; 123456789// 使用代理bindEvent(a, \"click\", \"a\", function (e) &#123; console.log(this.innerHTML);&#125;);// 不使用代理bindEvent(a, \"click\", function (e) &#123; console.log(this.innerHTML);&#125;); 题目解答 编写一个通用的事件监听函数 描述事件冒泡过程 DOM 树形结构 -&gt; 事件冒泡 -&gt; 阻止冒泡 -&gt; 冒泡的应用（代理） 对于一个无限下拉加载图片的页面，如何给每个图片绑定事件 使用代理","categories":[],"tags":[]},{"title":"【JavaScript】变量类型和计算","slug":"yuque/【JavaScript】变量类型和计算","date":"2020-04-05T00:54:01.000Z","updated":"2020-06-07T13:19:54.263Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】变量类型和计算/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】变量类型和计算/","excerpt":"","text":"title: 【JavaScript】变量类型和计算date: 2019年04月08日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 变量类型 JS 中有 7 种内置类型，7 种内置类型又分为两大类型 基本类型/值类型：null、undefined、boolean、number、string、symbol 对象/引用类型：object 基本类型/值类型 涉及面试题：原始类型有哪几种？null 是对象嘛？ 是什么 把每一个值存放在对应变量内存的位置，数据分块存放在内存中，数据之间不会相互影响 1234var a = 100;var b = a;a = 200;console.log(b); // 100 条件 原始类型存储的都是值，是没有函数可以调用的，比如undefined.toString() &#39;1&#39;.toString() 是可以使用的。在这种情况下，&#39;1&#39; 已经不是原始类型了，而是被强制转换成了 String 类型（大写）也就是引用类型，所以可以调用 toString 函数 JS 的number 类型是浮点类型的，在使用中会遇到某些 Bug NaN也属于number类型，并且NaN不等于自身 0.1 + 0.2 !== 0.3 string类型是不可变的，无论你在string类型上调用何种方法，都不会对值有改变 对于null来说，很多人会认为他是个引用类型，其实这是错误的。虽然 typeof null 会输出 object，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来 对象/引用类型 涉及面试题：对象类型和原始类型的不同之处？函数参数是对象会发生什么问题？ 是什么 当你创建了一个引用类型 a 的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针），引用类型 a 存储的就是这个地址 1const a = []; 对于常量 a 来说，假设内存地址（指针）为 #001，那么在地址 #001 的位置存放了值 []，常量 a 存放了地址（指针） #001 当我们将变量赋值给另外一个变量时，复制的是原本变量的地址（指针），也就是说当前变量 b 存放的地址（指针）也是 #001，当我们进行数据修改的时候，就会修改存放在地址（指针） #001 上的值，也就导致了两个变量的值都发生了改变 123const a = [];const b = a;b.push(1); 产生原因 若 a 赋值成一个对象，特别大，a 再赋值给 b，b 也会占很大的空间，不合理，所以引用类型是为了让内存共用空间，好几个变量共用 1 个内存块，节省内存空间，赋值只是变量指针的赋值，并不是每次赋值都把对象真正的值复制一份，所以值的修改相互干预 分类边界 数组array、函数function、对象object 目的 无限制扩展属性，比如说对象有个 age 属性，可以加第 2 个属性：name 属性 组合 深浅拷贝 涉及面试题：什么是浅拷贝？如何实现浅拷贝？什么是深拷贝？如何实现深拷贝？ 目的 对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况。通常在开发中我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个情况 123456let a = &#123; age: 1,&#125;;let b = a;a.age = 2;console.log(b.age); // 2 浅拷贝条件 通过 Object.assign 来解决这个问题 很多人认为这个函数是用来深拷贝的。其实并不是，Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝 123456let a = &#123; age: 1,&#125;;let b = Object.assign(&#123;&#125;, a);a.age = 2;console.log(b.age); // 1 通过展开运算符 ... 来实现浅拷贝 123456let a = &#123; age: 1,&#125;;let b = &#123; ...a &#125;;a.age = 2;console.log(b.age); // 1 通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了 123456789let a = &#123; age: 1, jobs: &#123; first: \"FE\", &#125;,&#125;;let b = &#123; ...a &#125;;a.jobs.first = \"native\";console.log(b.jobs.first); // native 浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。 深拷贝条件 这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决 123456789let a = &#123; age: 1, jobs: &#123; first: \"FE\", &#125;,&#125;;let b = JSON.parse(JSON.stringify(a));a.jobs.first = \"native\";console.log(b.jobs.first); // FE 但是该方法也是有局限性的： 会忽略 undefined 会忽略 symbol 不能序列化函数（会忽略函数） 不能解决循环引用的对象 1234567891011121314let obj = &#123; a: 1, b: &#123; c: 2, d: 3, &#125;,&#125;;obj.c = obj.b;obj.e = obj.a;obj.b.c = obj.c;obj.b.d = obj.b;obj.b.e = obj.b.c;let newObj = JSON.parse(JSON.stringify(obj));console.log(newObj); 如果你有这么一个循环引用对象，你会发现并不能通过该方法实现深拷贝 在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化 12345678let a = &#123; age: undefined, sex: Symbol(\"male\"), jobs: function () &#123;&#125;, name: \"yck\",&#125;;let b = JSON.parse(JSON.stringify(a));console.log(b); // &#123;name: \"yck\"&#125; 你会发现在上述情况中，该方法会忽略掉函数、 undefined 和 Symbol 。 但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题。 如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel 123456789101112131415161718192021222324function structuralClone(obj) &#123; return new Promise((resolve) =&gt; &#123; const &#123; port1, port2 &#125; = new MessageChannel(); port2.onmessage = (ev) =&gt; resolve(ev.data); port1.postMessage(obj); &#125;);&#125;var obj = &#123; a: 1, b: &#123; c: 2, &#125;,&#125;;obj.b.d = obj.b;// 注意该方法是异步的// 可以处理 undefined 和循环引用对象const test = async () =&gt; &#123; const clone = await structuralClone(obj); console.log(clone);&#125;;test(); 当然你可能想自己来实现一个深拷贝，但是其实实现一个深拷贝是很困难的，需要我们考虑好多种边界情况，比如原型链如何处理、DOM 如何处理等等，所以这里我们实现的深拷贝只是简易版，并且我其实更推荐使用 lodash 的深拷贝函数。 12345678910111213141516171819202122232425262728function deepClone(obj) &#123; function isObject(o) &#123; return (typeof o === \"object\" || typeof o === \"function\") &amp;&amp; o !== null; &#125; if (!isObject(obj)) &#123; throw new Error(\"非对象\"); &#125; let isArray = Array.isArray(obj); let newObj = isArray ? [...obj] : &#123; ...obj &#125;; Reflect.ownKeys(newObj).forEach((key) =&gt; &#123; newObj[key] = isObject(obj[key]) ? deepClone(obj[key]) : obj[key]; &#125;); return newObj;&#125;let obj = &#123; a: [1, 2, 3], b: &#123; c: 2, d: 3, &#125;,&#125;;let newObj = deepClone(obj);newObj.b.c = 1;console.log(obj.b.c); // 2 条件 函数参数是对象的情况 1234567891011121314151617function test(person) &#123; person.age = 26; person = &#123; name: \"yyy\", age: 30, &#125;; return person;&#125;const p1 = &#123; name: \"yck\", age: 25,&#125;;const p2 = test(p1);console.log(p1); // -&gt; ?console.log(p2); // -&gt; ? 首先，函数传参是传递对象指针的副本 到函数内部修改参数的属性这步，我相信大家都知道，当前 p1 的值也被修改了 但是当我们重新为 person 分配了一个对象时就出现了分歧，请看下图 所以最后 person 拥有了一个新的地址（指针），也就和 p1 没有任何关系了，导致了最终两个变量的值是不相同的 typeof 运算符 涉及面试题：typeof 是否能正确判断类型？instanceof 能正确判断对象的原理是什么？ 是什么 只能区分基本类型的详细类型，引用类型无法细分 分类边界 typeof对于基本类型来说，除了null都可以显示正确的类型 123456typeof null; // 'object' BUGtypeof undefined; // 'undefined'typeof true; // 'boolean'typeof 1; // 'number'typeof \"1\"; // 'string'typeof Symbol(); // 'symbol' typeof对于引用类型来说，除了函数都会显示object，所以说typeof并不能准确判断引用变量到底是什么类型。因为函数是一个十分特殊的引用类型，在 JS 中函数的地位非常高，所以需要在任何地方轻松判断出这个是函数，所以 typeof 单独把函数列出来 123typeof []; // 'object'typeof &#123;&#125;; // 'object'typeof console.log; // 'function' 组合 instanceof 类型转换 涉及面试题：该知识点常在笔试题中见到，熟悉了转换规则就不惧怕此类题目了。 是什么 在 JS 中类型转换只有三种情况 转换为布尔值 转换为数字 转换为字符串 组合 转 Boolean在条件判断时，除了undefined、null、false、NaN、&#39;&#39;、0、-0，其他所有值都转为true，包括所有对象 引用类型转基本类型引用类型在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下 如果已经是基本类型了，那就不需要转换了 调用 x.valueOf()，如果转换为基础类型，就返回转换的值 调用 x.toString()，如果转换为基础类型，就返回转换的值 如果都没有返回基本类型，就会报错 当然你也可以重写 Symbol.toPrimitive ，该方法在转原始类型时调用优先级最高 123456789101112let a = &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return \"1\"; &#125;, [Symbol.toPrimitive]() &#123; return 2; &#125;,&#125;;1 + a; // =&gt; 3 四则运算目的 字符串拼接 运算 组合 加法运算中一方为字符串，那么就会把另一方也转换为字符串 加法运算中一方不是数字或字符串，那么会将它转换为数字或字符串 1231 + \"1\"; // '11'true + true; // 24 + [1, 2, 3]; // \"41,2,3\" 对于第一行代码来说，触发特点一，所以将数字 1 转换为字符串，得到结果 &#39;11&#39; 对于第二行代码来说，触发特点二，所以将 true 转为数字 1 对于第三行代码来说，触发特点二，所以将数组通过 toString 转为字符串 1,2,3，得到结果 41,2,3 条件 对于加法还需要注意这个表达式 &#39;a&#39; + + &#39;b&#39; 1\"a\" + +\"b\"; // -&gt; \"aNaN\" 因为 + &#39;b&#39; 等于 NaN，所以结果为 &quot;aNaN&quot; Tips 用 + 快速获取 number 类型，如+ &#39;1&#39; === 1 用!!判断变量会被当做true还是false，如!!undefined === false 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字 1234 * \"3\"; // 124 * []; // 04 * [1, 2]; // NaN 比较运算符 是什么 === == &gt; &lt; !== 组合 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过 unicode 字符索引来比较 123456789let a = &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return \"1\"; &#125;,&#125;;a &gt; -1; // true 在以上代码中，因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值 == vs === 涉及面试题：== 和 === 有什么区别？ 对于 == 来说，如果对比双方的类型不一样的话，就会进行类型转换 假如我们需要对比 x 和 y 是否相同，就会进行如下判断流程： 首先会判断两者类型是否相同。相同的话就是比大小了 类型不相同的话，那么就会进行类型转换 会先判断是否在对比 null 和 undefined，是的话就会返回 true 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number 1231 == '1' ↓1 == 1 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断 12345'1' == true ↓'1' == 1 ↓ 1 == 1 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断 123'1' == &#123; name: 'yck' &#125; ↓'1' == '[object Object]' 思考题：看完了上面的步骤，对于 [] == ![] 你是否能正确写出答案呢？ 123456789[] == ![] ↓[] == !true ↓ // 在条件判断时，除了`undefined`、`null`、`false`、`NaN`、`''`、`0`、`-0`，其他所有值都转为`true`，包括所有对象[] == false ↓[] == 0 ↓ // 调用ToPrimitive.valueOf() 0 == 0 // true 流程图如下 当然了，这个流程图并没有将所有的情况都列举出来，我这里只将常用到的情况列举了，如果你想了解更多的内容可以参考 标准文档。 对于 === 来说就简单多了，就是判断两者类型和值是否相同。","categories":[],"tags":[]},{"title":"【JavaScript】闭包和作用域","slug":"yuque/【JavaScript】闭包和作用域","date":"2020-04-05T00:53:56.000Z","updated":"2020-06-07T13:19:54.388Z","comments":true,"path":"2020/04/05/yuque/【JavaScript】闭包和作用域/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【JavaScript】闭包和作用域/","excerpt":"","text":"title: 【JavaScript】闭包和作用域date: 2019年04月08日 00:27:43categories: JavaScripttypora-root-url: ..typora-copy-images-to: ../images 执行上下文（声明提升） 范围：一段&lt;script&gt;或者一个函数 全局（某个&lt;script&gt;）：变量定义提前，函数声明提前，且函数声明优先级高于变量定义 函数（函数即将执行之前）：变量定义提前，函数声明提前，确定 this 的值，确定 arguments 的值 注意：函数声明和函数表达式的区别 函数声明 1234fn(); // 不会报错，因为函数声明会提升function fn() &#123; ... // 函数声明&#125; 函数表示式 1234567fn1();// 会报错，fn1会被当做变量定义，会提升相当于var fn1 = undefined，再执行fn1();// 以下均为函数表达式，函数表达式本质上即为变量定义var a = 100;var fn1 = function () &#123; ...&#125; 假如下列代码在一个&lt;script&gt;中，在一个&lt;script&gt;中要定义一个全局的执行上下文，在执行第 1 行代码之前，会把所有的变量声明和函数声明都执行一遍，执行顺序如下： 第 2 行，变量定义 ，还未执行到此，所以不会赋值，把 a 先拿出来，用 undefined 代替来占位 第 4-8 行，函数声明，把整个函数拿出来，以此函数生效可以执行 第 1 行，undefined 第 2 行，a 被赋值成 100 第 3 行，进入函数体，函数顺利执行 第 7 行，变量定义，并用 undefined 代替来占位 第 5 行，age 被赋值成 20 第 6 行，打印 arguments 参数 12345678console.log(a); // undefinedvar a = 100;fn('zhangsan'); // 'zhangsan', 20function fn(name) &#123; age = 20; console.log(name, age); var age；&#125; 12345678910111213141516171819202122// 全局// var a = undefined;console.log(a);var a = 100;fn(\"zhangsan\");function fn(name) &#123; // 函数 // 函数代码执行之前（不是函数声明之前），就已经确定了this的值 console.log(this); // 函数代码执行之前（不是函数声明之前），就已经确定了arguments的值 // arguments：函数参数的集合体 console.log(arguments); age = 20; console.log(name, age); var age; bar(100); function bar(num) &#123; console.log(num); &#125;&#125; this 涉及面试题：如何正确判断 this？箭头函数的 this 是什么？ 是什么 指向当前对象 分类边界 可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 this 最终指向哪里。 首先，new 的方式优先级最高 接下来是 bind 这些函数 然后是 obj.foo() 这种调用方式 最后是 foo() 这种调用方式 箭头函数的 this 一旦被绑定，就不会再被任何方式所改变 如果你还是觉得有点绕，那么就看以下的这张流程图吧，图中的流程只针对于单个规则。 this 要在函数被调用，即将执行时才能确定值，定义时无法确认 一个函数后面加()，即为要执行 在此之前，函数永远处于定义状态 123456789101112var a = &#123; name: \"A\", fn: function () &#123; console.log(this.name); &#125;,&#125;;// 只看到这里不能确认this到底是什么a.fn(); // this === aa.fn.call(&#123; name: \"B\" &#125;); // this === &#123;name: 'B'&#125;var fn1 = a.fn;fn1(); // this === window 组合 call apply bind 中的 this 判断说到 bind，不知道大家是否考虑过，如果对一个函数进行多次 bind，那么上下文会是什么呢？ 12345let a = &#123;&#125;;let fn = function () &#123; console.log(this);&#125;;fn.bind().bind(a)(); // =&gt; ? 如果你认为输出结果是 a，那么你就错了，其实我们可以把上述代码转换成另一种形式 1234567// fn.bind().bind(a) 等于let fn2 = function fn1() &#123; return function () &#123; return fn.apply(); &#125;.apply(a);&#125;;fn2(); 可以从上述代码中发现，不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，bind 参数为空，所以结果永远是 window 12345let a = &#123; name: \"yck\" &#125;;function foo() &#123; console.log(this.name);&#125;foo.bind(a)(); // =&gt; 'yck' 题目描述将函数 fn 的执行上下文改为 obj，返回 fn 执行后的值 示例 1 输入 123456alterContext( function () &#123; return this.greeting + \", \" + this.name + \"!\"; &#125;, &#123; name: \"Rebecca\", greeting: \"Yo\" &#125;); 输出 1Yo, Rebecca! 回答 1234567891011function alterContext(fn, obj) &#123; return fn.bind(obj)(); // .bind()返回的是一个函数，所以需要立即执行&#125;function alterContext(fn, obj) &#123; return fn.call(obj);&#125;function alterContext(fn, obj) &#123; return fn.apply(obj);&#125; 条件 对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window 12345function foo() &#123; console.log(this.a);&#125;var a = 1;foo(); 对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象 12345const obj = &#123; a: 2, foo: foo,&#125;;obj.foo(); 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this 1const c = new foo(); 箭头函数 箭头函数中的 this 12345678function a() &#123; return () =&gt; &#123; return () =&gt; &#123; console.log(this); &#125;; &#125;;&#125;console.log(a()()()); 首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this 在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window 另外对箭头函数使用 bind 这类函数是无效的 最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window ex 作为构造函执行 123456function Foo(name) &#123; // this = &#123;&#125;; this.name = name; // return this;&#125;var f = new Foo(\"zhangsan\"); 作为对象属性执行 1234567var obj = &#123; name: \"A\", printName: function () &#123; console.log(this.name); // this === obj &#125;,&#125;;obj.printName(); 作为普通函数执行 1234function fn() &#123; console.log(this); // this === window&#125;fn(); call apply bind 12345678910111213141516171819function fn1(name, age) &#123; alert(name); alert(age); console.log(this); // this === window&#125;// call表示&#123;x:100&#125;为this，'zhangsan'为第1个参数，20为第2个参数，最常用fn1.call(&#123; x: 100 &#125;, \"zhangsan\", 20);// apply将后面当做数组，相当于fn1.apply(&#123; x: 100 &#125;, ['zhangsan', 20]);fn1.apply(&#123; x: 100 &#125;, \"zhangsan\", 20);// 使用bind修改默认this，.bind必须是函数表达式var fn2 = function (name, age) &#123; alert(name); alert(age); console.log(this);&#125;.bind(&#123; y: 200 &#125;);fn2(\"zhangsan\", 20); 作用域 没有块级作用域（ES6 中的 let 使得 JS 存在块级作用域） 但有函数和全局作用域 12345678910111213141516171819// 没有块级作用域if (true) &#123; // 在外面定义和定义在if语句块中是一样的 // 尽量不要在块中定义变量，容易使程序不易读 var name = \"zhangsan\";&#125;console.log(name); // 'zhangsan'// 但有函数和全局作用域var a = 100;function fn() &#123; var a = 200; // 函数中也有a，则使用函数中的a = 200 // 函数中的变量值，外面是改不了的 // 所以框架的第三方库就采用将变量定义在函数中的方法来防止变量被污染，与外面隔绝 console.log(\"fn\", a);&#125;console.log(\"global\", a); // 全局 a = 100fn(); // 函数 a = 200 作用域链 是什么 根据调用回到变量定义或函数声明的地方的父作用域，去父级作用域取值 目的 查找自由变量 组合 当前作用域没有定义的变量，即“自由变量” 12345678var a = 100;function fn() &#123; var b = 200; // 当前作用域没有定义的变量，即“自由变量” console.log(a); // 去父级作用域取值，变量定义或函数声明时的父作用域 console.log(b);&#125;fn(); 123456789101112131415var a = 100;function F1() &#123; var b = 200; function F2() &#123; var c = 300; // a是自由变量 // 父级F1中a未定义，再在F1父级中找a，a = 100 console.log(a); // b是自由变量 console.log(b); console.log(c); &#125; F2();&#125;F1(); 闭包 涉及面试题：什么是闭包？ 是什么 函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包 12345678function A() &#123; let a = 1; window.B = function () &#123; console.log(a); &#125;;&#125;A();B(); // 1 很多人对于闭包的解释可能是函数嵌套了函数，然后返回一个函数。其实这个解释是不完整的，就比如我上面这个例子就可以反驳这个观点。 目的 让我们可以间接访问函数内部的变量 在函数外面，根本不可能修改掉函数中定义的变量的值，以保证数据的安全不被污染 组合 经典面试题，循环中使用闭包解决 var 定义函数的问题 12345for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000);&#125; 首先因为 setTimeout 是个异步函数，所以会先把循环全部执行完毕，这时候 i 就是 6 了，所以会输出一堆 6 解决办法有三种 第一种是使用闭包的方式 1234567for (var i = 1; i &lt;= 5; i++) &#123; (function (j) &#123; setTimeout(function timer() &#123; console.log(j); &#125;, j * 1000); &#125;)(i);&#125; 在上述代码中，我们首先使用了立即执行函数将 i 传入函数内部，这个时候值就被固定在了参数 j 上面不会改变，当下次执行 timer 这个闭包的时候，就可以使用外部函数的变量 j，从而达到目的。 第二种就是使用 setTimeout 的第三个参数，这个参数会被当成 timer 函数的参数传入。 123456789for (var i = 1; i &lt;= 5; i++) &#123; setTimeout( function timer(j) &#123; console.log(j); &#125;, i * 1000, i );&#125; 第三种就是使用 let 定义 i 了来解决问题了，这个也是最为推荐的方式 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;, i * 1000);&#125; let 是 ES6 的新增命令，用法同 var， 但作用域不同 var 定义的变量会被提升，在整个函数作用域内都可以使用（在变量声明之前的代码也能够使用该变量，此时它的值是 undefined）。在函数作用域内只存在这一个变量 let 定义的变量是块级作用域，仅在代码块中有效，且不存在变量提升 123456&#123; var a = 1; let b = 1;&#125;a; // 1b; // ReferenceError: a is not defined 函数作用域在其完成使命后，会被析构掉。但如果函数内部的变量仍被外部引用，函数的生命周期则会延续到引用变量的函数被析构 for 语句执行完后，定时器传入的匿名函数仍保持对变量 i 的引用，而此时 i 的值经过迭代后，变为了 6，所以打印出来的值都是 6 如果把 let 声明的变量提到外面，其结果和 var 命令 是一样的 12345678910111213let j = 1;for (; j &lt;= 5; j++) &#123; setTimeout(function () &#123; console.log(j); &#125;);&#125;// 6 6 6 6 6for (var i = 1; i &lt;= 5; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;);&#125;// 6 6 6 6 6 重点在 for 循环机制上 在 for 三个语句中，第一个语句在循环代码块开始前执行，每次循环都会执行 由于 var 命令的变量提升机制，var 命令实际只会执行一次 而 let 命令不存在变量提升，所以每次循环都会执行一次，声明一个新变量（但初始化的值不一样） for 的每次循环都是不同的块级作用域，而 let 声明的变量是块级作用域的，所以也不存在重复声明的问题。 因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算。 《ES6 入门》· 阮一峰 因此，在第二个例子中，每个匿名函数实际上引用的都是一个新的变量 123456for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function () &#123; console.log(i); &#125;);&#125;// 1 2 3 4 5 条件 函数作为返回值 1234567891011121314function F1() &#123; // a是F1局部变量 var a = 100; // 返回一个函数（函数作为返回值） return function () &#123; // a是个自由变量 console.log(a); // 去父级作用域取值，声明时的父作用域 &#125;;&#125;var f1 = F1();// a是全局变量，不会影响到函数中定义的局部变量var a = 200;// 不是看此处执行时的作用域，而是回到其定义处的作用域f1(); // 100 函数作为参数传递 1234567891011121314151617function F1() &#123; // a是F1局部变量 var a = 100; // 返回一个函数（函数作为返回值） return function () &#123; // a是个自由变量 console.log(a); // 去父级作用域取值，声明时的父作用域 &#125;;&#125;var f1 = F1();function F2(fn) &#123; var a = 200; fn(); // 此处为执行作用域&#125;F2(f1);","categories":[],"tags":[]},{"title":"【J2EE】第一章 绪论","slug":"yuque/【J2EE】第一章 绪论","date":"2020-04-05T00:53:51.000Z","updated":"2020-06-07T13:19:54.390Z","comments":true,"path":"2020/04/05/yuque/【J2EE】第一章 绪论/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【J2EE】第一章 绪论/","excerpt":"","text":"image.png","categories":[],"tags":[]},{"title":"【J2EE】第五章 SSH整合","slug":"yuque/【J2EE】第五章 SSH整合","date":"2020-04-05T00:53:46.000Z","updated":"2020-06-07T13:19:54.392Z","comments":true,"path":"2020/04/05/yuque/【J2EE】第五章 SSH整合/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【J2EE】第五章 SSH整合/","excerpt":"","text":"image.png","categories":[],"tags":[]},{"title":"【J2EE】第四章 SpringMVC","slug":"yuque/【J2EE】第四章 SpringMVC","date":"2020-04-05T00:53:41.000Z","updated":"2020-06-07T13:19:54.396Z","comments":true,"path":"2020/04/05/yuque/【J2EE】第四章 SpringMVC/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【J2EE】第四章 SpringMVC/","excerpt":"","text":"image.png","categories":[],"tags":[]},{"title":"【J2EE】第三章 Hibernate","slug":"yuque/【J2EE】第三章 Hibernate","date":"2020-04-05T00:53:36.000Z","updated":"2020-06-07T13:19:54.397Z","comments":true,"path":"2020/04/05/yuque/【J2EE】第三章 Hibernate/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【J2EE】第三章 Hibernate/","excerpt":"","text":"image.png","categories":[],"tags":[]},{"title":"【J2EE】第二章 Spring框架&amp;AOP","slug":"yuque/【J2EE】第二章 Spring框架&AOP","date":"2020-04-05T00:53:31.000Z","updated":"2020-06-07T13:19:54.399Z","comments":true,"path":"2020/04/05/yuque/【J2EE】第二章 Spring框架&AOP/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【J2EE】第二章 Spring框架&AOP/","excerpt":"","text":"image.png","categories":[],"tags":[]},{"title":"【Framework】Vue 常考进阶知识点","slug":"yuque/【Framework】Vue 常考进阶知识点","date":"2020-04-05T00:53:26.000Z","updated":"2020-06-07T13:19:54.488Z","comments":true,"path":"2020/04/05/yuque/【Framework】Vue 常考进阶知识点/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【Framework】Vue 常考进阶知识点/","excerpt":"","text":"title: 【Framework】Vue 常考进阶知识点date: 2019年04月08日 00:27:43categories: Frameworktypora-root-url: ..typora-copy-images-to: ../images 响应式原理（数据双向绑定） Vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，Vue 内部使用了 Object.defineProperty() 来实现数据响应式，通过这个函数可以监听到 set 和 get 的事件。 12345678910111213141516171819202122232425262728293031323334var data = &#123; name: \"yck\" &#125;;observe(data);let name = data.name; // -&gt; get valuedata.name = \"yyy\"; // -&gt; change valuefunction observe(obj) &#123; // 判断类型 if (!obj || typeof obj !== \"object\") &#123; return; &#125; Object.keys(obj).forEach((key) =&gt; &#123; defineReactive(obj, key, obj[key]); &#125;);&#125;function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val); Object.defineProperty(obj, key, &#123; // 可枚举 enumerable: true, // 可配置 configurable: true, // 自定义函数 get: function reactiveGetter() &#123; console.log(\"get value\"); return val; &#125;, set: function reactiveSetter(newVal) &#123; console.log(\"change value\"); val = newVal; &#125;, &#125;);&#125; 以上代码简单的实现了如何监听数据的 set 和 get 的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。 123&lt;div&gt; &#123;&#123;name&#125;&#125;&lt;/div&gt; 在解析如上模板代码时，遇到 就会进行依赖收集。 接下来我们先来实现一个 Dep 类，用于解耦属性的依赖收集和派发更新操作。 123456789101112131415161718// 通过 Dep 解耦属性的依赖和更新操作class Dep &#123; constructor() &#123; this.subs = []; &#125; // 添加依赖 addSub(sub) &#123; this.subs.push(sub); &#125; // 更新 notify() &#123; this.subs.forEach((sub) =&gt; &#123; sub.update(); &#125;); &#125;&#125;// 全局属性，通过该属性配置 WatcherDep.target = null; 以上的代码实现很简单，当需要依赖收集的时候调用 addSub，当需要派发更新的时候调用 notify。 接下来我们先来简单的了解下 Vue 组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 Object.defineProperty()，然后实例化 Watcher，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。 因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。 12345678910111213141516171819class Watcher &#123; constructor(obj, key, cb) &#123; // 将 Dep.target 指向自己 // 然后触发属性的 getter 添加监听 // 最后将 Dep.target 置空 Dep.target = this; this.cb = cb; this.obj = obj; this.key = key; this.value = obj[key]; Dep.target = null; &#125; update() &#123; // 获得新值 this.value = this.obj[this.key]; // 调用 update 方法更新 Dom this.cb(this.value); &#125;&#125; 以上就是 Watcher 的简单实现，在执行构造函数的时候将 Dep.target 指向自身，从而使得收集到了对应的 Watcher，在派发更新的时候取出对应的 Watcher 然后执行 update 函数。 接下来，需要对 defineReactive 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码。 1234567891011121314151617181920212223function defineReactive(obj, key, val) &#123; // 递归子属性 observe(val); let dp = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter() &#123; console.log(\"get value\"); // 将 Watcher 添加到订阅 if (Dep.target) &#123; dp.addSub(Dep.target); &#125; return val; &#125;, set: function reactiveSetter(newVal) &#123; console.log(\"change value\"); val = newVal; // 执行 watcher 的 update 方法 dp.notify(); &#125;, &#125;);&#125; 以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。 现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了。 123456789var data = &#123; name: \"yck\" &#125;;observe(data);function update(value) &#123; document.querySelector(\"div\").innerText = value;&#125;// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作new Watcher(data, \"name\", update);// update Dom innerTextdata.name = \"yyy\"; Object.defineProperty() 的缺陷以上已经分析完了 Vue 的响应式原理，接下来说一点 Object.defineProperty 中的缺陷。 如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为 Object.defineProperty() 不能拦截到这些操作，Vue 提供了set API 更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题 对于第一个问题，Vue 提供了一个 API 解决 1234567891011121314151617181920212223242526export function set(target: Array&lt;any&gt; | Object, key: any, val: any): any &#123; // 判断是否为数组且下标是否有效 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; // 调用 splice 函数触发派发更新 // 该函数已被重写 target.length = Math.max(target.length, key); target.splice(key, 1, val); return val; &#125; // 判断 key 是否已经存在 if (key in target &amp;&amp; !(key in Object.prototype)) &#123; target[key] = val; return val; &#125; const ob = (target: any).__ob__; // 如果对象不是响应式对象，就赋值返回 if (!ob) &#123; target[key] = val; return val; &#125; // 进行双向绑定 defineReactive(ob.value, key, val); // 手动派发更新 ob.dep.notify(); return val;&#125; 对于数组而言，Vue 内部重写了以下函数实现派发更新 1234567891011121314151617181920212223242526272829303132333435363738// 获得数组原型const arrayProto = Array.prototype;export const arrayMethods = Object.create(arrayProto);// 重写以下函数const methodsToPatch = [ \"push\", \"pop\", \"shift\", \"unshift\", \"splice\", \"sort\", \"reverse\",];methodsToPatch.forEach(function (method) &#123; // 缓存原生函数 const original = arrayProto[method]; // 重写函数 def(arrayMethods, method, function mutator(...args) &#123; // 先调用原生函数获得结果 const result = original.apply(this, args); const ob = this.__ob__; let inserted; // 调用以下几个函数时，监听新数据 switch (method) &#123; case \"push\": case \"unshift\": inserted = args; break; case \"splice\": inserted = args.slice(2); break; &#125; if (inserted) ob.observeArray(inserted); // 手动派发更新 ob.dep.notify(); return result; &#125;);&#125;); 编译过程 想必大家在使用 Vue 开发的过程中，基本都是使用模板的方式。那么你有过「模板是怎么在浏览器中运行的」这种疑虑嘛？ 首先直接把模板丢到浏览器中肯定是不能运行的，模板只是为了方便开发者进行开发。Vue 会通过编译器将模板通过几个阶段最终编译为 render 函数，然后通过执行 render 函数生成 Virtual DOM 最终映射为真实 DOM。 接下来我们就来学习这个编译的过程，了解这个过程中大概发生了什么事情。这个过程其中又分为三个阶段，分别为： 将模板解析为 AST 优化 AST 将 AST 转换为 render 函数 在第一个阶段中，最主要的事情还是通过各种各样的正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接下来会生成一个最基本的 AST 对象 1234567891011121314&#123; // 类型 type: 1, // 标签 tag, // 属性列表 attrsList: attrs, // 属性映射 attrsMap: makeAttrsMap(attrs), // 父节点 parent, // 子节点 children: []&#125; 然后会根据这个最基本的 AST 对象中的属性，进一步扩展 AST。 当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 Content Model 规范等等问题。 接下来就是优化 AST 的阶段。在当前版本下，Vue 进行的优化内容其实还是不多的。只是对节点进行了静态内容提取，也就是将永远不会变动的节点提取了出来，实现复用 Virtual DOM，跳过对比算法的功能。在下一个大版本中，Vue 会在优化 AST 的阶段继续发力，实现更多的优化功能，尽可能的在编译阶段压榨更多的性能，比如说提取静态的属性等等优化行为。 最后一个阶段就是通过 AST 生成 render 函数了。其实这一阶段虽然分支有很多，但是最主要的目的就是遍历整个 AST，根据不同的条件生成不同的代码罢了。 NextTick 原理分析 nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM。 在 Vue 2.4 之前都是使用的 microtasks，但是 microtasks 的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都使用 macrotasks 又可能会出现渲染的性能问题。所以在新版本中，会默认使用 microtasks，但在特殊情况下会使用 macrotasks，比如 v-on。 对于实现 macrotasks ，会先判断是否能使用 setImmediate ，不能的话降级为 MessageChannel ，以上都不行的话就使用 setTimeout 123456789101112131415161718192021if (typeof setImmediate !== \"undefined\" &amp;&amp; isNative(setImmediate)) &#123; macroTimerFunc = () =&gt; &#123; setImmediate(flushCallbacks); &#125;;&#125; else if ( typeof MessageChannel !== \"undefined\" &amp;&amp; (isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === \"[object MessageChannelConstructor]\")) &#123; const channel = new MessageChannel(); const port = channel.port2; channel.port1.onmessage = flushCallbacks; macroTimerFunc = () =&gt; &#123; port.postMessage(1); &#125;;&#125; else &#123; macroTimerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0); &#125;;&#125; 以上代码很简单，就是判断能不能使用相应的 API。 小结 以上就是 Vue 的几个高频核心问题了，如果你还想了解更多的源码相关的细节，强烈推荐黄老师的 Vue 技术揭秘。","categories":[],"tags":[]},{"title":"【Framework】React VS Vue","slug":"yuque/【Framework】React VS Vue","date":"2020-04-05T00:53:21.000Z","updated":"2020-06-07T13:19:54.571Z","comments":true,"path":"2020/04/05/yuque/【Framework】React VS Vue/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【Framework】React VS Vue/","excerpt":"","text":"title: 【Framework】React VS Vuedate: 2019年04月08日 00:27:43categories: Frameworktypora-root-url: ..typora-copy-images-to: ../images MVVM 涉及面试题：什么是 MVVM？比之 MVC 有什么区别？ 是什么 M (Model) V (View) VM (ViewModel) 目的 在 MVVM 架构中，引入了 ViewModel 的概念 ViewModel 只关心数据和业务的处理，不关心 View 如何处理数据，类似 Controller View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方 可以将一些可复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel View 和 ViewModel 通过隐式的 Binder 层实现数据的双向绑定（Vue 插值和指令） MVVM 的精髓是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，而不是数据双向绑定 以 Vue 框架来举例，ViewModel 就是组件的实例。View 就是模板，Model 的话在引入 Vuex 的情况下是完全可以和组件分离的。 除了以上三个部分，其实在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定。 同样以 Vue 框架来举例，这个隐式的 Binder 层就是 Vue 通过解析模板中的插值和指令从而实现 View 与 ViewModel 的绑定。 对于 MVVM 来说，其实最重要的并不是通过双向绑定或者其他的方式将 View 与 ViewModel 绑定起来，而是通过 ViewModel 将视图中的状态和用户的行为分离出一个抽象，这才是 MVVM 的精髓。 组合 MVC是什么 M (Model)：Model 同样很简单，一般就是本地数据和数据库中的数据 V (View)：View 很简单，就是用户看到的视图 C (Controller) 基本上，我们写的产品就是通过接口从数据库中读取数据，然后将数据经过处理展现到用户看到的视图上。当然我们还可以从视图上读取用户的输入，然后又将用户的输入通过接口写入到数据库中。但是，如何将数据展示到视图上，然后又如何将用户的输入写入到数据中，不同的人就产生了不同的看法，从此出现了很多种架构设计。 传统的 MVC 架构 使用控制器从模型中获取数据去渲染视图 当用户有输入时，会通过控制器去更新模型，并且通知视图进行更新 但是 MVC 有一个巨大的缺陷就是控制器承担的责任太大了，随着项目愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况 Tips 不管是 React 还是 Vue，它们都不是 MVVM 框架，只是有借鉴 MVVM 的思路 Virtual DOM 涉及面试题：什么是 Virtual DOM？为什么 Virtual DOM 比原生 DOM 快？ 是什么 将 Virtual DOM 作为一个兼容层，让我们还能对接非 Web 端的系统，实现跨端开发 通过 Virtual DOM 我们可以渲染到其他的平台，比如实现 SSR、同构渲染等 实现组件的高度抽象化 提高性能，O(n) 如何实现 大家都知道操作 DOM 是很慢的，那么相较于 DOM 来说，操作 JS 对象会快很多，并且我们也可以通过 JS 来模拟 DOM 12345678910const ul = &#123; tag: \"ul\", props: &#123; class: \"list\", &#125;, children: &#123; tag: \"li\", children: \"1\", &#125;,&#125;; 上述代码对应的 DOM 就是 123&lt;ul class=\"list\"&gt; &lt;li&gt;1&lt;/li&gt;&lt;/ul&gt; 那么既然 DOM 可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM。当然了，通过 JS 来模拟 DOM 并且渲染对应的 DOM 只是第一步，难点在于如何判断新旧两个 JS 对象的最小差异并且实现局部更新 DOM。 首先 DOM 是一个多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。 实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。 所以判断差异的算法就分为了两步 首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异 在第一步算法中我们需要判断新旧节点的 tagName 是否相同，如果不相同的话就代表节点被替换了 如果没有更改 tagName 的话，进入第 2 步，判断是否有子元素 一旦节点有子元素，就去判断子元素是否有不同 判断原本的列表中是否有节点被移除 在新的列表中需要判断是否有新的节点加入 判断节点是否有移动 举个例子来说，假设页面中只有一个列表，我们对列表中的元素进行了变更 12345// 假设这里模拟一个 ul，其中包含了 5 个 li[1, 2, 3, 4, 5][ // 这里替换上面的 li (1, 2, 5, 4)]; 从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。 那么在实际的算法中，我们如何去识别改动的是哪个节点呢？这就引入了 key 这个属性，想必大家在 Vue 或者 React 的列表中都用过这个属性。这个属性是用来给每一个节点打标志的，用于判断是否是同一个节点。 当然在判断以上差异的过程中，我们还需要判断节点的属性是否有变化等等。 把这些差异记录下来。当对比完两棵树以后，就可以通过差异去局部更新 DOM，实现性能的最优化 路由原理 涉及面试题：前端路由原理？两种实现方式有什么区别？ 是什么 监听 URL 的变化 匹配路由规则 显示相应的页面 无须再次页面 组合 目前前端使用的路由就只有两种实现方式 Hash 模式 History 模式 Hash 模式www.test.com/#/ 就是 Hash URL，当 # 后面的哈希值发生变化时，可以通过 hashchange 事件来监听到 URL 的变化，从而进行跳转页面 无论哈希值如何变化，服务端接收到的 URL 请求永远是 www.test.com 123window.addEventListener(\"hashchange\", () =&gt; &#123; // ... 具体逻辑&#125;); Hash 模式相对来说更简单，并且兼容性也更好。 History 模式History 模式是 HTML5 新推出的功能，主要使用 history.pushState 、 history.popState 和 history.replaceState 改变 URL。 通过 History 模式改变 URL 同样不会引起页面的刷新，只会更新浏览器的历史记录。 1234// 新增历史记录history.pushState(stateObject, title, URL);// 替换当前历史记录history.replaceState(stateObject, title, URL); 当用户做出浏览器动作时，比如点击后退按钮时会触发 popState 事件 1234window.addEventListener(\"popstate\", (e) =&gt; &#123; // e.state 就是 pushState(stateObject) 中的 stateObject console.log(e.state);&#125;); 两种模式对比 Hash 模式只可以更改 # 后面的内容，History 模式可以通过 API 设置任意的同源 URL History 模式可以通过 API 添加任意类型的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串 Hash 模式无需后端配置，并且兼容性好。History 模式在用户手动输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 页面用于匹配不到静态资源的时候 Vue 和 React 之间的区别 - Vue 的表单可以使用 v-model 支持双向绑定，相比于 React 来说开发上更加方便，当然了 v-model 其实就是个语法糖，本质上和 React 写表单的方式没什么区别。 - 改变数据方式不同，Vue 修改状态相比来说要简单许多，并且 Vue 的底层使用了依赖追踪，页面更新渲染已经是最优的了，但是 React 还是需要用户手动去优化这方面的问题，React 需要使用 setState 来改变状态，并且使用这个 API 也有一些坑点 - React 16 以后，有些钩子函数会执行多次，这是因为引入 Fiber 的原因，这在后续的章节中会讲到。 - React 需要使用 JSX，有一定的上手成本，并且需要一整套的工具链支持，但是完全可以通过 JS 来控制页面，更加的灵活。Vue 使用了模板语法，相比于 JSX 来说没有那么灵活，但是完全可以脱离工具链，通过直接编写 render 函数就能在浏览器中运行。 - 在生态上来说，两者其实没多大的差距，当然 React 的用户是远远高于 Vue 的。 - 在上手成本上来说，Vue 一开始的定位就是尽可能的降低前端开发的门槛，然而 React 更多的是去改变用户去接受它的概念和思想，相较于 Vue 来说上手成本略高。","categories":[],"tags":[]},{"title":"【DataStruct】常见数据结构","slug":"yuque/【DataStruct】常见数据结构","date":"2020-04-05T00:53:16.000Z","updated":"2020-06-07T13:19:54.747Z","comments":true,"path":"2020/04/05/yuque/【DataStruct】常见数据结构/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【DataStruct】常见数据结构/","excerpt":"","text":"title: 【DataStruct】常见数据结构date: 2019年04月08日 00:27:43categories: DataStructtypora-root-url: ..typora-copy-images-to: ../images 时间复杂度 目的 我们通常使用最差的时间复杂度来衡量一个算法的好坏 如何达成 在计算时间复杂度的时候，数据量通常是非常大的，所以我们忽略低阶项和常数项，计算出操作次数为 aN + 1，N 代表数据量。那么该算法的时间复杂度就是 O(N) 条件 常数时间O(1)代表这个操作和数据量没关系，是一个固定时间的操作，比如说四则运算 计算出操作次数为 aN + 1，N 代表数据量。那么该算法的时间复杂度就是 O(N) 当出现两个算法都是 O(N) 的时间复杂度，那么对比两个算法的好坏就要通过对比低阶项和常数项了 栈 是什么 栈是一个线性结构，在计算机中是一个相当常见的数据结构 分类边界 只能在某一端添加或删除数据，遵循先进后出的原则 如何达成 每种数据结构都可以用很多种方式来实现，其实可以把栈看成是数组的一个子集，所以这里使用数组来实现 1234567891011121314151617181920212223242526class Stack &#123; // 构造器 constructor() &#123; this.stack = []; &#125; // 入栈 push(item) &#123; this.stack.push(item); &#125; // 出栈 pop() &#123; this.stack.pop(); &#125; // 栈内元素个数 getCount() &#123; return this.stack.length; &#125; // 判断栈是否为空 isEmpty() &#123; return this.getCount() === 0; &#125; // 栈顶元素的值 peek() &#123; return this.stack[this.getCount() - 1]; &#125;&#125; 条件 选取了 LeetCode 上序号为 20 的题目 题意是匹配括号，可以通过栈的特性来完成这道题目 12345678910111213141516171819202122var isValid = function (s) &#123; let map = &#123; \"(\": -1, \")\": 1, \"[\": -2, \"]\": 2, \"&#123;\": -3, \"&#125;\": 3, &#125;; let stack = []; for (let i = 0; i &lt; s.length; i++) &#123; if (map[s[i]] &lt; 0) &#123; stack.push(s[i]); &#125; else &#123; let last = stack.pop(); // 注意这里是[] if (map[last] + map[s[i]] != 0) return false; &#125; &#125; if (stack.length &gt; 0) return false; return true;&#125;; 在 Vue 中关于模板解析的代码，就有应用到匹配尖括号的内容 队列 是什么 队列是一个线性结构 分类边界 在某一端添加数据，在另一端删除数据，遵循先进先出的原则 组合 单链队列 O(n)12345678910111213141516171819202122232425class Queue &#123; constructor() &#123; this.queue = []; &#125; // 入队 enQueue(item) &#123; this.queue.push(item); &#125; // 出队 deQueue() &#123; return this.queue.shift(); &#125; // 队首元素 getHeader() &#123; return this.queue[0]; &#125; // 队中元素个数 getLength() &#123; return this.queue.length; &#125; // 队列是否为空 isEmpty() &#123; return this.getLength() === 0; &#125;&#125; 因为单链队列在出队操作的时候需要 O(n) 的时间复杂度，所以引入了循环队列。循环队列的出队操作平均是 O(1) 的时间复杂度 循环队列 O(1)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class SqQueue &#123; constructor(length) &#123; this.queue = new Array(length + 1); // 队头 this.first = 0; // 队尾 this.last = 0; // 当前队列大小 this.size = 0; &#125; enQueue(item) &#123; // 判断队尾 + 1 是否为队头 // 如果是就代表需要扩容数组 // % this.queue.length 是为了防止数组越界 if (this.first === (this.last + 1) % this.queue.length) &#123; this.resize(this.getLength() * 2 + 1); &#125; this.queue[this.last] = item; this.size++; this.last = (this.last + 1) % this.queue.length; &#125; deQueue() &#123; if (this.isEmpty()) &#123; throw Error(\"Queue is empty\"); &#125; let r = this.queue[this.first]; this.queue[this.first] = null; this.first = (this.first + 1) % this.queue.length; this.size--; // 判断当前队列大小是否过小 // 为了保证不浪费空间，在队列空间等于总长度四分之一时 // 且不为 2 时缩小总长度为当前的一半 if (this.size === this.getLength() / 4 &amp;&amp; this.getLength() / 2 !== 0) &#123; this.resize(this.getLength() / 2); &#125; return r; &#125; getHeader() &#123; if (this.isEmpty()) &#123; throw Error(\"Queue is empty\"); &#125; return this.queue[this.first]; &#125; getLength() &#123; return this.queue.length - 1; &#125; isEmpty() &#123; return this.first === this.last; &#125; resize(length) &#123; let q = new Array(length); for (let i = 0; i &lt; length; i++) &#123; q[i] = this.queue[(i + this.first) % this.queue.length]; &#125; this.queue = q; this.first = 0; this.last = this.size; &#125;&#125; 链表 是什么 链表是一个线性结构，同时也是一个天然的递归结构 链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理 但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大 分类边界 组合 单向链表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// 定义节点class Node &#123; constructor(v, next) &#123; this.value = v; this.next = next; &#125;&#125;// 链表class LinkList &#123; constructor() &#123; // 链表长度 this.size = 0; // 虚拟头部 this.dummyNode = new Node(null, null); &#125; // 查找 find(header, index, currentIndex) &#123; if (index === currentIndex) return header; return this.find(header.next, index, currentIndex + 1); &#125; // index：要查找元素的索引位置 find(header, index) &#123; for (let i = 0; header === null; i++) &#123; if (i === index) &#123; return header; &#125; header = header.next; &#125; &#125; // 添加节点 addNode(v, index) &#123; this.checkIndex(index); // 当往链表末尾插入时，prev.next 为空 // 其他情况时，因为要插入节点，所以插入的节点的 next 应该是 prev.next // 然后设置 prev.next 为插入的节点 let prev = this.find(this.dummyNode, index); prev.next = new Node(v, prev.next); this.size++; return prev.next; &#125; // 插入节点 insertNode(v, index) &#123; return this.addNode(v, index); &#125; // 添加到链表开头 addToFirst(v) &#123; return this.addNode(v, 0); &#125; // 添加到链表末尾 addToLast(v) &#123; return this.addNode(v, this.size); &#125; // 删除节点 removeNode(index, isLast) &#123; this.checkIndex(index); index === isLast ? index - 1 : index; let prev = this.find(this.dummyNode, index); let node = prev.next; prev.next = node.next; node.next = null; this.size--; return node; &#125; // 删除第一个节点 removeFirstNode() &#123; return this.removeNode(0); &#125; // 删除最后一个节点 removeLastNode() &#123; return this.removeNode(this.size, true); &#125; // 检查节点 checkIndex(index) &#123; if (index &lt; 0 || index &gt; this.size) throw Error(\"Index error\"); &#125; // 获取节点 getNode(index) &#123; this.checkIndex(index); if (this.isEmpty()) return; return this.find(this.dummyNode, index).next; &#125; // 判断链表是否为空 isEmpty() &#123; return this.size === 0; &#125; // 获取链表大小 getSize() &#123; return this.size; &#125;&#125; 树 二叉树是什么 树拥有很多种结构，二叉树是树中最常用的结构，同时也是一个天然的递归结构 组合 二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一颗树的叶节点数量为满时，该树可以称之为满二叉树 二分搜索树（BST）是什么 二分搜索树也是二叉树，拥有二叉树的特性 分类边界 二分搜索树每个节点的值都比他的左子树的值大，比右子树的值小 目的 便于数据搜索。如下图所示，当需要查找 6 的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率。 如何达成 1234567891011121314151617181920212223242526272829303132333435class Node &#123; constructor(value) &#123; this.value = value; this.left = null; this.right = null; &#125;&#125;class BST &#123; constructor() &#123; this.root = null; this.size = 0; &#125; getSize() &#123; return this.size; &#125; isEmpty() &#123; return this.size === 0; &#125; addNode(v) &#123; this.root = this._addChild(this.root, v); &#125; // 添加节点时，需要比较添加的节点值和当前节点值的大小 _addChild(node, v) &#123; if (!node) &#123; this.size++; return new Node(v); &#125; if (node.value &gt; v) &#123; node.left = this._addChild(node.left, v); &#125; else if (node.value &lt; v) &#123; node.right = this._addChild(node.right, v); &#125; return node; &#125;&#125; 组合 对于树的遍历（深度遍历）来说，有三种遍历方法，分别是 先序遍历 中序遍历 后序遍历 每次都单独抽离出一颗子树来考虑 三种遍历的区别在于何时访问节点。在遍历树的过程中，每个节点都会遍历三次，分别是遍历到自己，遍历左子树和遍历右子树。如果需要实现先序遍历，那么只需要第一次遍历到节点时进行操作即可。 12345678910111213141516171819202122232425262728293031323334353637383940// 先序遍历可用于打印树的结构// 先序遍历先访问根节点，然后访问左节点，最后访问右节点preTraversal() &#123; this._pre(this.root)&#125;_pre(node) &#123; if (node) &#123; console.log(node.value) this._pre(node.left) this._pre(node.right) &#125;&#125;// 中序遍历可用于排序// 对于 BST 来说，中序遍历可以实现一次遍历就得到有序的值// 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点midTraversal() &#123; this._mid(this.root)&#125;_mid(node) &#123; if (node) &#123; this._mid(node.left) console.log(node.value) this._mid(node.right) &#125;&#125;// 后序遍历可用于先操作子节点// 再操作父节点的场景// 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。backTraversal() &#123; this._back(this.root)&#125;_back(node) &#123; if (node) &#123; this._back(node.left) this._back(node.right) console.log(node.value) &#125;&#125; 以上的这几种遍历都可以称之为深度遍历，对应的还有种遍历叫做广度遍历，也就是一层层地遍历树。对于广度遍历来说，我们需要利用之前讲过的队列结构来完成。 123456789101112131415breadthTraversal() &#123; if (!this.root) return null let q = new Queue() // 将根节点入队 q.enQueue(this.root) // 循环判断队列是否为空，为空代表树遍历完毕 while (!q.isEmpty()) &#123; // 将队首出队，判断是否有左右子树 // 有的话，就先左后右入队 let n = q.deQueue() console.log(n.value) if (n.left) q.enQueue(n.left) if (n.right) q.enQueue(n.right) &#125;&#125; 接下来先介绍如何在树中寻找最小值或最大数。因为二分搜索树的特性，所以最小值一定在根节点的最左边，最大值相反 1234567891011121314getMin() &#123; return this._getMin(this.root).value&#125;_getMin(node) &#123; if (!node.left) return node return this._getMin(node.left)&#125;getMax() &#123; return this._getMax(this.root).value&#125;_getMax(node) &#123; if (!node.right) return node return this._getMin(node.right)&#125; 向上取整和向下取整，这两个操作是相反的，所以代码也是类似的，这里只介绍如何向下取整。既然是向下取整，那么根据二分搜索树的特性，值一定在根节点的左侧。只需要一直遍历左子树直到当前节点的值不再大于等于需要的值，然后判断节点是否还拥有右子树。如果有的话，继续上面的递归判断 12345678910111213141516floor(v) &#123; let node = this._floor(this.root, v) return node ? node.value : null&#125;_floor(node, v) &#123; if (!node) return null if (node.value === v) return v // 如果当前节点值还比需要的值大，就继续递归 if (node.value &gt; v) &#123; return this._floor(node.left, v) &#125; // 判断当前节点是否拥有右子树 let right = this._floor(node.right, v) if (right) return right return node&#125; 排名，这是用于获取给定值的排名或者排名第几的节点的值，这两个操作也是相反的，所以这个只介绍如何获取排名第几的节点的值。对于这个操作而言，我们需要略微的改造点代码，让每个节点拥有一个 size 属性。该属性表示该节点下有多少子节点（包含自身）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Node &#123; constructor(value) &#123; this.value = value this.left = null this.right = null // 修改代码 this.size = 1 &#125;&#125;// 新增代码_getSize(node) &#123; return node ? node.size : 0&#125;_addChild(node, v) &#123; if (!node) &#123; return new Node(v) &#125; if (node.value &gt; v) &#123; // 修改代码 node.size++ node.left = this._addChild(node.left, v) &#125; else if (node.value &lt; v) &#123; // 修改代码 node.size++ node.right = this._addChild(node.right, v) &#125; return node&#125;select(k) &#123; let node = this._select(this.root, k) return node ? node.value : null&#125;_select(node, k) &#123; if (!node) return null // 先获取左子树下有几个节点 let size = node.left ? node.left.size : 0 // 判断 size 是否大于 k // 如果大于 k，代表所需要的节点在左节点 if (size &gt; k) return this._select(node.left, k) // 如果小于 k，代表所需要的节点在右节点 // 注意这里需要重新计算 k，减去根节点除了右子树的节点数量 if (size &lt; k) return this._select(node.right, k - size - 1) return node&#125; 接下来讲解的是二分搜索树中最难实现的部分：删除节点。因为对于删除节点来说，会存在以下几种情况 需要删除的节点没有子树 删除 需要删除的节点只有一条子树 接上 需要删除的节点有左右两条树 取出右子树中最小的那个节点来替换父节点 对于前两种情况很好解决，但是第三种情况就有难度了，所以先来实现相对简单的操作：删除最小节点，对于删除最小节点来说，是不存在第三种情况的，删除最大节点操作是和删除最小节点相反的，所以这里也就不再赘述。 1234567891011121314delectMin() &#123; this.root = this._delectMin(this.root) console.log(this.root)&#125;_delectMin(node) &#123; // 一直递归左子树 // 如果左子树为空，就判断节点是否拥有右子树 // 有右子树的话就把需要删除的节点替换为右子树 if ((node != null) &amp; !node.left) return node.right node.left = this._delectMin(node.left) // 最后需要重新维护下节点的 `size` node.size = this._getSize(node.left) + this._getSize(node.right) + 1 return node&#125; 最后讲解的就是如何删除任意节点了。对于这个操作，T.Hibbard 在 1962 年提出了解决这个难题的办法，也就是如何解决第三种情况。 当遇到这种情况时，需要取出当前节点的后继节点（也就是当前节点右子树的最小节点）来替换需要删除的节点。然后将需要删除节点的左子树赋值给后继结点，右子树删除后继结点后赋值给他。 你如果对于这个解决办法有疑问的话，可以这样考虑。因为二分搜索树的特性，父节点一定比所有左子节点大，比所有右子节点小。那么当需要删除父节点时，势必需要拿出一个比父节点大的节点来替换父节点。这个节点肯定不存在于左子树，必然存在于右子树。然后又需要保持父节点都是比右子节点小的，那么就可以取出右子树中最小的那个节点来替换父节点 12345678910111213141516171819202122232425262728293031delect(v) &#123; this.root = this._delect(this.root, v)&#125;_delect(node, v) &#123; if (!node) return null // 寻找的节点比当前节点小，去左子树找 if (node.value &lt; v) &#123; node.right = this._delect(node.right, v) &#125; else if (node.value &gt; v) &#123; // 寻找的节点比当前节点大，去右子树找 node.left = this._delect(node.left, v) &#125; else &#123; // 进入这个条件说明已经找到节点 // 先判断节点是否拥有拥有左右子树中的一个 // 是的话，将子树返回出去，这里和 `_delectMin` 的操作一样 if (!node.left) return node.right if (!node.right) return node.left // 进入这里，代表节点拥有左右子树 // 先取出当前节点的后继结点，也就是取当前节点右子树的最小值 let min = this._getMin(node.right) // 取出最小值后，删除最小值 // 然后把删除节点后的子树赋值给最小值节点 min.right = this._delectMin(node.right) // 左子树不动 min.left = node.left node = min &#125; // 维护 size node.size = this._getSize(node.left) + this._getSize(node.right) + 1 return node&#125; AVL 树 是什么 AVL 树改进了二分搜索树，在 AVL 树中任意节点的左右子树的高度差都 ≤ 1（高度从下往上数层数，包括根节点），这样保证了时间复杂度是严格的 O(logN)。基于此，对 AVL 树增加或删除节点时可能需要旋转树来达到高度的平衡 目的 二分搜索树实际在业务中是受到限制的，因为并不是严格的 O(logN)，在极端情况下会退化成链表，比如加入一组升序的数字就会造成这种情况 组合 对于 AVL 树来说，添加节点会有四种情况 右旋即为顺时针 左旋即为逆时针 对于左左情况（左边多出来加左侧）来说 新增加的节点位于节点 2 的左侧，这时树已经不平衡，需要旋转。因为搜索树的特性，节点比左节点大，比右节点小，所以旋转以后也要实现这个特性。 旋转之前：new &lt; 2 &lt; C &lt; 3 &lt; B &lt; 5 &lt; A，右旋之后节点 3 为根节点，这时候需要将节点 3 的右节点加到节点 5 的左边，最后还需要更新节点的高度。 - 对于右右情况（右边多出来加右侧）来说，相反于左左情况，所以不再赘述。 - 对于左右情况（左边多出来加右侧）来说，新增加的节点位于节点 4 的右侧 对于这种情况，需要通过两次旋转来达到目的。 首先对节点的左节点左旋，这时树满足左左的情况，再对节点进行一次右旋就可以达到目的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113class Node &#123; constructor(value) &#123; this.value = value; this.left = null; this.right = null; this.height = 1; &#125;&#125;class AVL &#123; constructor() &#123; this.root = null; &#125; addNode(v) &#123; this.root = this._addChild(this.root, v); &#125; _addChild(node, v) &#123; if (!node) &#123; return new Node(v); &#125; if (node.value &gt; v) &#123; node.left = this._addChild(node.left, v); &#125; else if (node.value &lt; v) &#123; node.right = this._addChild(node.right, v); &#125; else &#123; node.value = v; &#125; node.height = 1 + Math.max(this._getHeight(node.left), this._getHeight(node.right)); let factor = this._getBalanceFactor(node); // 当需要右旋时，根节点的左树一定比右树高度高 if (factor &gt; 1 &amp;&amp; this._getBalanceFactor(node.left) &gt;= 0) &#123; return this._rightRotate(node); &#125; // 当需要左旋时，根节点的左树一定比右树高度矮 if (factor &lt; -1 &amp;&amp; this._getBalanceFactor(node.right) &lt;= 0) &#123; return this._leftRotate(node); &#125; // 左右情况 // 节点的左树比右树高，且节点的左树的右树比节点的左树的左树高 if (factor &gt; 1 &amp;&amp; this._getBalanceFactor(node.left) &lt; 0) &#123; node.left = this._leftRotate(node.left); return this._rightRotate(node); &#125; // 右左情况 // 节点的左树比右树矮，且节点的右树的右树比节点的右树的左树矮 if (factor &lt; -1 &amp;&amp; this._getBalanceFactor(node.right) &gt; 0) &#123; node.right = this._rightRotate(node.right); return this._leftRotate(node); &#125; return node; &#125; _getHeight(node) &#123; if (!node) return 0; return node.height; &#125; _getBalanceFactor(node) &#123; return this._getHeight(node.left) - this._getHeight(node.right); &#125; // 节点右旋 // 5 2 // / \\ / \\ // 2 6 ==&gt; 1 5 // / \\ / / \\ // 1 3 new 3 6 // / // new _rightRotate(node) &#123; // 旋转后新根节点 let newRoot = node.left; // 需要移动的节点 let moveNode = newRoot.right; // 节点 2 的右节点改为节点 5 newRoot.right = node; // 节点 5 左节点改为节点 3 node.left = moveNode; // 更新树的高度 node.height = 1 + Math.max(this._getHeight(node.left), this._getHeight(node.right)); newRoot.height = 1 + Math.max(this._getHeight(newRoot.left), this._getHeight(newRoot.right)); return newRoot; &#125; // 节点左旋 // 4 6 // / \\ / \\ // 2 6 ==&gt; 4 7 // / \\ / \\ \\ // 5 7 2 5 new // \\ // new _leftRotate(node) &#123; // 旋转后新根节点 let newRoot = node.right; // 需要移动的节点 let moveNode = newRoot.left; // 节点 6 的左节点改为节点 4 newRoot.left = node; // 节点 4 右节点改为节点 5 node.right = moveNode; // 更新树的高度 node.height = 1 + Math.max(this._getHeight(node.left), this._getHeight(node.right)); newRoot.height = 1 + Math.max(this._getHeight(newRoot.left), this._getHeight(newRoot.right)); return newRoot; &#125;&#125; Trie 是什么 在计算机科学，trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串 分类边界 根节点代表空字符串，每个节点都有 N（假如搜索英文字符，就有 26 条）条链接，每条链接代表一个字符 节点不存储字符，只有路径才存储，这点和其他的树结构不同 从根节点开始到任意一个节点，将沿途经过的字符连接起来就是该节点对应的字符串 目的 为了方便搜索字符串 如何达成 总得来说 Trie 的实现相比别的树结构来说简单的很多，实现就以搜索英文字符为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class TrieNode &#123; constructor() &#123; // 代表每个字符经过节点的次数 this.path = 0; // 代表到该节点的字符串有几个 this.end = 0; // 链接 this.next = new Array(26).fill(null); &#125;&#125;class Trie &#123; constructor() &#123; // 根节点，代表空字符 this.root = new TrieNode(); &#125; // 插入字符串 insert(str) &#123; if (!str) return; let node = this.root; for (let i = 0; i &lt; str.length; i++) &#123; // 获得字符先对应的索引 let index = str[i].charCodeAt() - \"a\".charCodeAt(); // 如果索引对应没有值，就创建 if (!node.next[index]) &#123; node.next[index] = new TrieNode(); &#125; node.path += 1; node = node.next[index]; &#125; node.end += 1; &#125; // 搜索字符串出现的次数 search(str) &#123; if (!str) return; let node = this.root; for (let i = 0; i &lt; str.length; i++) &#123; let index = str[i].charCodeAt() - \"a\".charCodeAt(); // 如果索引对应没有值，代表没有需要搜素的字符串 if (!node.next[index]) &#123; return 0; &#125; node = node.next[index]; &#125; return node.end; &#125; // 删除字符串 delete(str) &#123; if (!this.search(str)) return; let node = this.root; for (let i = 0; i &lt; str.length; i++) &#123; let index = str[i].charCodeAt() - \"a\".charCodeAt(); // 如果索引对应的节点的 Path 为 0，代表经过该节点的字符串 // 已经一个，直接删除即可 if (--node.next[index].path == 0) &#123; node.next[index] = null; return; &#125; node = node.next[index]; &#125; node.end -= 1; &#125;&#125; 并查集 是什么 并查集是一种特殊的树结构 分类边界 该结构中每个节点都有一个父节点，如果只有当前一个节点，那么该节点的父节点指向自己 这个结构中有两个重要的操作，分别是： Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 Union：将两个子集合并成同一个集合。 目的 用于处理一些不交集的合并及查询问题 如何达成 1234567891011121314151617181920212223242526272829303132333435363738394041424344class DisjointSet &#123; // 初始化样本 constructor(count) &#123; // 初始化时，每个节点的父节点都是自己 this.parent = new Array(count); // 用于记录树的深度，优化搜索复杂度 this.rank = new Array(count); for (let i = 0; i &lt; count; i++) &#123; this.parent[i] = i; this.rank[i] = 1; &#125; &#125; find(p) &#123; // 寻找当前节点的父节点是否为自己，不是的话表示还没找到 // 开始进行路径压缩优化 // 假设当前节点父节点为 A // 将当前节点挂载到 A 节点的父节点上，达到压缩深度的目的 while (p != this.parent[p]) &#123; this.parent[p] = this.parent[this.parent[p]]; p = this.parent[p]; &#125; return p; &#125; isConnected(p, q) &#123; return this.find(p) === this.find(q); &#125; // 合并 union(p, q) &#123; // 找到两个数字的父节点 let i = this.find(p); let j = this.find(q); if (i === j) return; // 判断两棵树的深度，深度小的加到深度大的树下面 // 如果两棵树深度相等，那就无所谓怎么加 if (this.rank[i] &lt; this.rank[j]) &#123; this.parent[i] = j; &#125; else if (this.rank[i] &gt; this.rank[j]) &#123; this.parent[j] = i; &#125; else &#123; this.parent[i] = j; this.rank[j] += 1; &#125; &#125;&#125; 堆 是什么 堆通常是一个可以被看做一棵树的数组对象 分类边界 堆的实现通过构造二叉堆，实为二叉树的一种。这种数据结构具有以下性质 任意节点小于（或大于）它的所有子节点 堆总是一棵完全树。即除了最底层，其他层的节点都被元素填满，且最底层从左到右填入 将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆 优先队列也完全可以用堆来实现，操作是一模一样的。 组合 实现大根堆 堆的每个节点的左边子节点索引是 i * 2 + 1，右边是 i * 2 + 2，父节点是 (i - 1) /2。 堆有两个核心的操作，分别是 shiftUp 和 shiftDown 。前者用于添加元素，后者用于删除根节点。 shiftUp 的核心思路是一路将节点与父节点对比大小，如果比父节点大，就和父节点交换位置。 shiftDown 的核心思路是先将根节点和末尾交换位置，然后移除末尾元素。接下来循环判断父节点和两个子节点的大小，如果子节点大，就把最大的子节点和父节点交换。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class MaxHeap &#123; constructor() &#123; this.heap = []; &#125; size() &#123; return this.heap.length; &#125; empty() &#123; return this.size() == 0; &#125; add(item) &#123; this.heap.push(item); this._shiftUp(this.size() - 1); &#125; removeMax() &#123; this._shiftDown(0); &#125; getParentIndex(k) &#123; return parseInt((k - 1) / 2); &#125; getLeftIndex(k) &#123; return k * 2 + 1; &#125; _shiftUp(k) &#123; // 如果当前节点比父节点大，就交换 while (this.heap[k] &gt; this.heap[this.getParentIndex(k)]) &#123; this._swap(k, this.getParentIndex(k)); // 将索引变成父节点 k = this.getParentIndex(k); &#125; &#125; _shiftDown(k) &#123; // 交换首位并删除末尾 this._swap(k, this.size() - 1); this.heap.splice(this.size() - 1, 1); // 判断节点是否有左孩子，因为二叉堆的特性，有右必有左 while (this.getLeftIndex(k) &lt; this.size()) &#123; let j = this.getLeftIndex(k); // 判断是否有右孩子，并且右孩子是否大于左孩子 if (j + 1 &lt; this.size() &amp;&amp; this.heap[j + 1] &gt; this.heap[j]) j++; // 判断父节点是否已经比子节点都大 if (this.heap[k] &gt;= this.heap[j]) break; this._swap(k, j); k = j; &#125; &#125; _swap(left, right) &#123; let rightValue = this.heap[right]; this.heap[right] = this.heap[left]; this.heap[left] = rightValue; &#125;&#125;","categories":[],"tags":[]},{"title":"【CSS】Bootstrap学习小记","slug":"yuque/【CSS】Bootstrap学习小记","date":"2020-04-05T00:53:11.000Z","updated":"2020-06-07T13:19:54.774Z","comments":true,"path":"2020/04/05/yuque/【CSS】Bootstrap学习小记/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【CSS】Bootstrap学习小记/","excerpt":"","text":"title: 【CSS】Bootstrap 学习小记 date: 2019 年 04 月 08 日 00:27:43categories: CSStypora-root-url: ..typora-copy-images-to: ../images Bootstrap 引入123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;贴吧后台管理页面&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"../css/bootstrap.min.css\" /&gt; &lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"../js/bootstrap.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 页眉 --&gt; &lt;header&gt; &lt;!-- 导航条部分 --&gt; &lt;nav&gt; ... &lt;/nav&gt; &lt;/header&gt; &lt;!-- 主要内容 --&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;!-- 左侧目录 --&gt; &lt;div class=\"col-xs-12 col-sm-2 col-md-2 col-lg-2\"&gt; ... &lt;/div&gt; &lt;!-- 右侧主要内容 --&gt; &lt;div class=\"col-xs-12 col-sm-10 col-md-10 col-lg-10\"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页尾 --&gt; &lt;footer&gt; ... &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 制作一个页面的流程 引入框架 实现页面布局代码 构建导航的整体架构 设计标题和导航链接 设计搜索框和通知系统 设置管理员登录系统 设计响应式导航 左侧边栏设计 页面主体设计 span1/2/3/4ul.unstyledul.inline响应式导航条Glyphicons 或者动态模态对话框滚动监听工具提示框弹出框状态按钮 加载中… 折叠幻灯视频响应式123456&lt;div class=\"embed-responsive embed-responsive-16by9\"&gt; &lt;iframe class=\"embed-responsive-item\" src=\"iqiyi.catilog2015/24551221.swf\" &gt;&lt;/iframe&gt;&lt;/div&gt; 扁平化风格页面各种风格的按钮jQuery 插件 DataTables 响应式表格 支持及时分页、搜索、排序 Json、数组、Ajax 可视化图表 EChartsjQuery UI Bootstrap 工具","categories":[],"tags":[]},{"title":"【CSS】background与background-color区别","slug":"yuque/【CSS】background与background-color区别","date":"2020-04-05T00:53:06.000Z","updated":"2020-06-07T13:19:54.794Z","comments":true,"path":"2020/04/05/yuque/【CSS】background与background-color区别/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【CSS】background与background-color区别/","excerpt":"","text":"title: 【CSS】background 与 background-color 区别 date: 2019 年 04 月 08 日 00:27:43categories: CSStypora-root-url: ..typora-copy-images-to: ../images 理论 background 可以设置图片，背景图拉伸、背景图大小、背景图相对位置、背景颜色等 而 background-color 只能设置背景色 验证123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cn\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; a &#123; background: url(\"./1.png\"); &#125; /* 使用background */ a:hover &#123; background: blue; &#125; /* 使用background-color */ a:hover &#123; background-color: blue; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"#\" &gt;冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥冯天祥&lt;/a &gt; &lt;/body&gt;&lt;/html&gt; 以上代码的目的是，当鼠标停留在 a 文字上时，用蓝色替换红色背景图片，运行效果如下 使用 background，生效 使用 background-color，不生效 结论background-color 改变的只是背景色，而不是背景图，效果是有的，只是图片把背景色遮住了看不到，所以建议改变背景颜色时，尽可能使用 background","categories":[],"tags":[]},{"title":"【CSS】元素居中指南","slug":"yuque/【CSS】元素居中指南","date":"2020-04-05T00:53:01.000Z","updated":"2020-06-07T13:19:54.885Z","comments":true,"path":"2020/04/05/yuque/【CSS】元素居中指南/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【CSS】元素居中指南/","excerpt":"","text":"title: 【CSS】元素居中指南date: 2019年04月08日 00:27:43categories: CSStypora-root-url: ..typora-copy-images-to: ../images 水平居中 inline or inline-*元素（比如文字或者链接） 让一个父元素为块级元素的行内元素水平居中 text-align 用于父元素，用于块元素，而不是用于 a line-heigh 设置于父元素或 a 均可 vertical-align: middle 设置于文本 123.center-children &#123; text-align: center;&#125; 单个块级元素 这个块级元素是被设置了一个 width 属性了，否则它会占满宽度，这时候已经不需要居中了 你可以设置块级元素的 margin-left 和 margin-right 为 auto 来使它水平居中 无论父级容器和块级元素的宽度如何变化，都不会影响块级元素的居中效果 float 属性是不能实现元素居中的 123.center-me &#123; margin: 0 auto;&#125; 多个块级元素如果有两个或者更多的块级元素需要在被一行里水平居中，那么你最好设置他们不同的 display 属性来达到效果了。 方法一：设置为 inline-block 1234567891011121314&lt;main class=\"inline-block-center\"&gt; &lt;div&gt; I'm an element that is block-like with my siblings and we're centered in a row. &lt;/div&gt; &lt;div&gt; I'm an element that is block-like with my siblings and we're centered in a row. I have more content in me than my siblings do. &lt;/div&gt; &lt;div&gt; I'm an element that is block-like with my siblings and we're centered in a row. &lt;/div&gt;&lt;/main&gt; 123456.inline-block-center &#123; text-align: center;&#125;.inline-block-center div &#123; display: inline-block;&#125; 方法二：设置为 flexbox 1234567891011121314&lt;main class=\"flex-center\"&gt; &lt;div&gt; I'm an element that is block-like with my siblings and we're centered in a row. &lt;/div&gt; &lt;div&gt; I'm an element that is block-like with my siblings and we're centered in a row. I have more content in me than my siblings do. &lt;/div&gt; &lt;div&gt; I'm an element that is block-like with my siblings and we're centered in a row. &lt;/div&gt;&lt;/main&gt; 1234.flex-center &#123; display: flex; justify-content: center;&#125; 除非你是想让多个块级元素堆积在彼此的顶部，那么 margin: auto 还是依然适用的 1234567891011121314151617main div &#123; background: black; margin: 0 auto; color: white; padding: 15px; margin: 5px auto;&#125;main div:nth-child(1) &#123; width: 200px;&#125;main div:nth-child(2) &#123; width: 400px;&#125;main div:nth-child(3) &#123; width: 125px;&#125; 垂直居中 inline or inline-*元素（比如文字或者链接）单行 有时候行内元素或者文字显示为垂直居中，仅仅是因为它们的上下内边距相等 这样的情况下，文字也水平居中 123456&lt;main&gt; &lt;a href=\"#0\"&gt;We're&lt;/a&gt; &lt;a href=\"#0\"&gt;Centered&lt;/a&gt; &lt;a href=\"#0\"&gt;Bits of&lt;/a&gt; &lt;a href=\"#0\"&gt;Text&lt;/a&gt;&lt;/main&gt; 123456main a &#123; background: black; color: white; padding: 40px 30px; text-decoration: none;&#125; 如果 padding 出于某些原因不能用，并且你要使一些不换行的文字居中，这里有一个技巧，就是设置文字的 line-height 和 height 的值相等 12345.center-text-trick &#123; height: 100px; line-height: 100px; white-space: nowrap;&#125; 多行对于多行文本，同样可以使用等值 padding-top 和 padding-bottom 的方式实现垂直居中。如果你在使用过程中发现这种方法没见效，那么你可以通过 CSS 为文本设置一个类似 table-cell 的父级容器，然后使用vertical-align属性实现垂直居中 真实 table 1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt; I'm vertically centered multiple lines of text in a real table cell. &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 123456789101112131415table &#123; background: white; width: 240px; border-collapse: separate; margin: 20px; height: 250px;&#125;table td &#123; background: black; color: white; padding: 20px; border: 10px solid white; /* default is vertical-align: middle; */&#125; table cell 123456&lt;div class=\"center-table\"&gt; &lt;p&gt; I'm vertically centered multiple lines of text in a CSS-created table layout. &lt;/p&gt;&lt;/div&gt; 12345678910111213141516.center-table &#123; display: table; height: 250px; background: white; width: 240px; margin: 20px;&#125;.center-table p &#123; display: table-cell; margin: 0; background: black; color: white; padding: 20px; border: 10px solid white; vertical-align: middle;&#125; 如果没法用类 table 方式，还可以使用 flexbox 实现垂直居中，对于父级容器为 display: flex 的元素来说，它的每一个子元素都是垂直居中的 123456.flex-center-vertically &#123; display: flex; justify-content: center; flex-direction: column; height: 400px;&#125; 请记住这个方法仅仅适用于父容器具有一个固定的高度（px，%，等等），这也是为什么容器有一个高度。 如果上述方法都不起作用，那么你就需要使用被称为幽灵元素（ghost element）的非常规解决方式：在垂直居中的元素上添加伪元素，设置伪元素的高等于父级容器的高，然后为文本添加 vertical-align: middle; 样式，即可实现垂直居中 1234567891011121314.ghost-center &#123; position: relative;&#125;.ghost-center::before &#123; content: \" \"; display: inline-block; height: 100%; width: 1%; vertical-align: middle;&#125;.ghost-center p &#123; display: inline-block; vertical-align: middle;&#125; 块级元素已知元素的高度无法获知元素的具体高度是非常常见的一种状况，比如：视区宽度变化，会触发布局重绘，从而改变高度；对文本施加不同的样式会改变高度；文本的内容量不同会改变高度；当宽度变化时，对于宽高比例固定的元素（比如图片），也会自动调整高度 如果我们知道元素的高度，可以这样来实现垂直居中 需要用负 margin 进行调整：- 子元素height * 50% - padding-top/left 123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; height: 100px; margin-top: -50px; /* account for padding and border if not using box-sizing: border-box; */&#125; 元素高度未知可以通过 transform 来达到目的 12345678.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; transform: translateY(-50%);&#125; 使用 flexbox毫无疑问，用 flexbox 简单太多了 12345.parent &#123; display: flex; flex-direction: column; justify-content: center;&#125; 垂直水平居中 元素有固定的宽和高设定父级容器为相对定位的容器，设定子元素绝对定位的位置 position: absolute; top: 50%; left: 50%，最后使用负向 margin 实现水平和垂直居中，- 子元素height/width * 50% - padding-top/left 123456789101112.parent &#123; position: relative;&#125;.child &#123; width: 300px; height: 100px; padding: 20px; position: absolute; top: 50%; left: 50%; margin: -70px 0 0 -170px;&#125; 元素的宽和高未知如果无法获取确定的宽高，同样需要设定父级容器为相对定位的容器，设定子元素绝对定位的位置 position: absolute; top: 50%; left: 50%。不同的是，接下来需要使用 transform: translate(-50%, -50%); 实现垂直居中 123456789.parent &#123; position: relative;&#125;.child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; 使用 transform 有一个缺陷，就是当计算结果含有小数时（比如 0.5），会让整个元素看起来是模糊的，一种解决方案就是为父级元素设置 transform-style: preserve-3d; 123456.parent &#123; position: relative; -webkit-transform-style: preserve-3d; -moz-transform-style: preserve-3d; transform-style: preserve-3d;&#125; 使用 flexbox使用 flexbox 实现水平和垂直居中，只需使用两条居中属性即可 12345.parent &#123; display: flex; justify-content: center; align-items: center;&#125; 使用 grid123456789body,html &#123; height: 100%; display: grid;&#125;span &#123; /* thing to center */ margin: auto;&#125; 参考资料 [1]https://www.w3cplus.com/css/centering-css-complete-guide.html [2]https://css-tricks.com/centering-css-complete-guide/","categories":[],"tags":[]},{"title":"【CSS】选择器","slug":"yuque/【CSS】选择器","date":"2020-04-05T00:52:56.000Z","updated":"2020-06-07T13:19:54.921Z","comments":true,"path":"2020/04/05/yuque/【CSS】选择器/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【CSS】选择器/","excerpt":"","text":"title: 【CSS】选择器 date: 2019 年 04 月 08 日 00:27:43categories: CSStypora-root-url: ..typora-copy-images-to: ../images| 选择器 | 例子 | 例子描述 | CSS || — | — | — | — || .class | .intro | 类选择器：选择 class=&quot;intro&quot; 的所有元素 | 1 || #id | #firstname | ID 选择器：选择 id=&quot;firstname&quot; 的所有元素 | 1 || * | * | 通用选择器：选择所有元素 | 2 || element | p | 标签选择器：选择所有 &lt;p&gt; 元素 | 1 || element, element | div, p | 选择所有 &lt;div&gt; 元素和所有 &lt;p&gt; 元素 | 1 || element element | div p | 选择 &lt;div&gt; 元素内部的所有 &lt;p&gt; 元素，跨层也可 | 1 || element &gt; element | div &gt; p | 选择父元素为 &lt;div&gt; 元素的所有 &lt;p&gt; 元素，只寻找一级（第一代子元素），&lt;p&gt;中的&lt;p&gt;不会找到，而element element全部找到 | 2 || element + element | div + p | 选择紧接在 &lt;div&gt; 元素之后的一个同辈 &lt;p&gt; 元素 | 2 || [attribute] | [target] | 选择带有 target 属性所有元素 | 2 || [attribute=value] | [target=_blank] | 选择 target=”_blank” 的所有元素 | 2 || [attribute~=value] | [title~=flower] | 选择 title 属性包含单词 “flower” 的所有元素 | 2 || [attribute|=value] | [lang|=en] | 选择 lang 属性值以 “en” 开头的所有元素 | 2 || :link | a:link | 选择所有未被访问的链接 | 1 || :visited | a:visited | 选择所有已被访问的链接 | 1 || :active | a:active | 选择活动链接 | 1 || :hover | a:hover | 选择鼠标指针位于其上的链接 | 1 || :focus | input:focus | 选择获得焦点的 input 元素 | 2 || :first-letter | p:first-letter | 选择每个 &lt;p&gt; 元素的首字母 | 1 || :first-line | p:first-line | 选择每个 &lt;p&gt; 元素的首行 | 1 || :first-child | p:first-child | 选择属于父元素的第一个子元素的每个 &lt;p&gt; 元素 | 2 || :before | p:before | 在每个 &lt;p&gt; 元素的内容之前插入内容 | 2 || :after | p:after | 在每个 &lt;p&gt; 元素的内容之后插入内容 | 2 || :lang(language) | p:lang(it) | 选择带有以 “it” 开头的 lang 属性值的每个 &lt;p&gt; 元素 | 2 || element1~element2 | p~ul | 选择前面有 &lt;p&gt; 元素的每个 &lt;ul&gt; 元素 | 3 || [attribute^=value] | a[src^=&quot;https&quot;] | 选择其 src 属性值以 “https” 开头的每个 &lt;a&gt; 元素 | 3 || [attribute$=value] | a[src$=&quot;.pdf&quot;] | 选择其 src 属性以 “.pdf” 结尾的所有 &lt;a&gt; 元素 | 3 || [attribute*=value] | a[src*=&quot;abc&quot;] | 选择其 src 属性中包含 “abc” 子串的每个 &lt;a&gt; 元素 | 3 || :first-of-type | p:first-of-type | 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素 | 3 || :last-of-type | p:last-of-type | 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素 | 3 || :only-of-type | p:only-of-type | 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素 | 3 || :only-child | p:only-child | 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素 | 3 || :nth-child(n) | p:nth-child(2) | 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素 | 3 || :nth-last-child(n) | p:nth-last-child(2) | 同上，从最后一个子元素开始计数 | 3 || :nth-of-type(n) | p:nth-of-type(2) | 选择属于其父元素第二个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素 | 3 || :nth-last-of-type(n) | p:nth-last-of-type(2) | 同上，但是从最后一个子元素开始计数 | 3 || :last-child | p:last-child | 选择属于其父元素最后一个子元素每个 &lt;p&gt; 元素 | 3 || :root | :root | 选择文档的根元素 | 3 || :empty | p:empty | 选择没有子元素的每个 &lt;p&gt; 元素（包括文本节点） | 3 || :target | #news:target | 选择当前活动的 #news 元素 | 3 || :enabled | input:enabled | 选择每个启用的 &lt;input&gt; 元素 | 3 || :disabled | input:disabled | 选择每个禁用的 &lt;input&gt; 元素 | 3 || :checked | input:checked | 选择每个被选中的 &lt;input&gt; 元素 | 3 || :not(selector) | :not(p) | 选择非 &lt;p&gt; 元素的每个元素 | 3 || ::selection | ::selection | 选择被用户选取的元素部分 | 3 |","categories":[],"tags":[]},{"title":"【CSS】简介","slug":"yuque/【CSS】简介","date":"2020-04-05T00:52:51.000Z","updated":"2020-06-07T13:19:54.935Z","comments":true,"path":"2020/04/05/yuque/【CSS】简介/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【CSS】简介/","excerpt":"","text":"title: 【CSS】简介date: 2019年04月08日 00:27:43categories: CSStypora-root-url: ..typora-copy-images-to: ../images 是什么 CSS 指层叠样式表 (Cascading Style Sheets) 目的 给 html 加各种各样的样式 html 结构和 CSS 样式分离 便于维护更新 组合 CSS 语法选择器{属性名:属性值;属性名:属性值;} 说明： 一个 CSS 样式包括选择器和格式声明语句 选择器就是选择给哪个 html 标签加样式 格式声明语句包括属性值:属性名 格式声明语句要用{} 属性名 w3c 已经定义好，直接使用 属性值不用双引号 属性值有单位通常是以 px 为单位，通常情况下必须带单位 CSS 引入 行内样式：通过在标签中设置 style 属性来达到实现控制标签的样式的效果。（临时做测试用） 1&lt;h1 style=\"color: red;\"&gt;传智播客-前端与移动开发学院的CSS基础视频教程&lt;/h1&gt; 2.内嵌样式表：在 head 标签中，嵌套一个 style 标签，在 style 标签中可以书写 CSS 的样式内容。（常用）","categories":[],"tags":[]},{"title":"【CSS】盒模型","slug":"yuque/【CSS】盒模型","date":"2020-04-05T00:52:46.000Z","updated":"2020-06-07T13:19:54.971Z","comments":true,"path":"2020/04/05/yuque/【CSS】盒模型/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【CSS】盒模型/","excerpt":"","text":"title: 【CSS】盒模型date: 2019年04月08日 00:27:43categories: CSStypora-root-url: ..typora-copy-images-to: ../images 是什么 盒模型又称框模型（Box Model）,包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）几个要素 目的 方便计算宽度 更好布局 组合 W3C 标准模型是什么 默认都是 W3C 标准模型 12width = content.widthheight = content.height 、分类边界1&lt;!DOCTYPE html&gt; 组合 通过 CSS3 新增的属性 box-sizing: content-box设置盒模型为标准模型（content-box） 12345678.content-box &#123; box-sizing: content-box; width: 100px; height: 50px; padding: 10px; border: 5px solid red; margin: 15px;&#125; .content-box 设置为标准模型，它的元素宽度 width=100px IE 模型是什么 12width = content.width + 2padding-left + 2border-leftheight = content.height + 2padding-top + 2border-top 分类边界 form 表单中的部分元素还是基于 IE 的怪异盒模型，input 中的 radio checkbox button 如果给其设置 border 和 padding 它们也只会往元素盒内延伸 如果不加 DOCTYPE 声明，那么各个浏览器会根据自己的行为去理解网页 IE 浏览器会采用 IE 盒子模型去解释你的盒子 Chrome、Firefox 等浏览器会采用标准 W3C 盒子模型解释你的盒子 如果加上了 DOCTYPE 声明，那么所有浏览器都会采用标准 W3C 盒子模型去解释你的盒子，网页就能在各个浏览器中显示一致了 组合 通过 CSS3 新增的属性 box-sizing: border-box设置盒模型为 IE 模型（border-box） 12345678.border-box &#123; box-sizing: border-box; width: 100px; height: 50px; padding: 10px; border: 5px solid red; margin: 15px;&#125; .border-box设置为 IE 模型，它的元素宽度width = content + 2padding + 2border = 70px + 2*10px + 2*5px = 100px BFC是什么 块级格式化上下文 BFC 决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用 当设计到可视化布局的时候，BFC 提供了一个环境，HTML 元素在这个环境中按照一定的规则进行布局 一个环境中的元素不会影响到其他环境中的布局。 顺序 overflow 不为 visible; float 的值不为 none； position 的值不为 static 或 relative； display 属性为inline-blocks, table, table-cell, table-caption, flex, inline-flex 条件 BFC 元素垂直方向的边距会发生重叠。属于不同 BFC 外边距不会发生重叠 BFC 的区域不会与浮动元素的布局重叠 BFC 元素是一个独立的容器，外面的元素不会影响里面的元素。里面的元素也不会影响外面的元素 计算 BFC 高度的时候，浮动元素也会参与计算(清除浮动) 条件 外边距重叠是什么 当两个垂直外边距相遇时，他们将形成一个外边距，合并后的外边距高度等于两个发生合并的外边距的高度中的较大者 分类边界 只有普通文档流中块框的垂直外边距才会发生外边距合并，行内框、浮动框或绝对定位之间的外边距不会合并 顺序","categories":[],"tags":[]},{"title":"【Browser】浏览器渲染原理","slug":"yuque/【Browser】浏览器渲染原理","date":"2020-04-05T00:52:41.000Z","updated":"2020-06-07T13:19:55.065Z","comments":true,"path":"2020/04/05/yuque/【Browser】浏览器渲染原理/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【Browser】浏览器渲染原理/","excerpt":"","text":"title: 【Browser】浏览器渲染原理date: 2019年04月08日 00:27:43categories: Browsertypora-root-url: ..typora-copy-images-to: ../images 执行 JS 有一个 JS 引擎，那么执行渲染也有一个渲染引擎。同样，渲染引擎在不同的浏览器中也不是都相同的。比如在 Firefox 中叫做 Gecko，在 Chrome 和 Safari 中都是基于 WebKit 开发的 浏览器接收到 HTML 文件并转换为 DOM 树 当我们打开一个网页时，浏览器都会去请求对应的 HTML 文件。虽然平时我们写代码时都会分为 JS、CSS、HTML 文件，也就是字符串，但是计算机硬件是不理解这些字符串的，所以在网络中传输的内容其实都是 0 和 1 这些字节数据。当浏览器接收到这些字节数据以后，它会将这些字节数据转换为字符串，也就是我们写的代码。 当数据转换为字符串以后，浏览器会先将这些字符串通过词法分析转换为标记（token），这一过程在词法分析中叫做标记化（tokenization）。 那么什么是标记呢？这其实属于编译原理这一块的内容了。简单来说，标记还是字符串，是构成代码的最小单位。这一过程会将代码分拆成一块块，并给这些内容打上标记，便于理解这些最小单位的代码是什么意思。 当结束标记化后，这些标记会紧接着转换为 Node，最后这些 Node 会根据不同 Node 之前的联系构建为一颗 DOM 树。 以上就是浏览器从网络中接收到 HTML 文件然后一系列的转换过程。 当然，在解析 HTML 文件的时候，浏览器还会遇到 CSS 和 JS 文件，这时候浏览器也会去下载并解析这些文件，接下来就让我们先来学习浏览器如何解析 CSS 文件。 将 CSS 文件转换为 CSSOM 树 其实转换 CSS 到 CSSOM 树的过程和上一小节的过程是极其类似的 在这一过程中，浏览器会确定下每一个节点的样式到底是什么，并且这一过程其实是很消耗资源的。因为样式你可以自行设置给某个节点，也可以通过继承获得。在这一过程中，浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。 如果你有点不理解为什么会消耗资源的话，我这里举个例子 1234567891011&lt;div&gt; &lt;a&gt; &lt;span&gt;&lt;/span&gt; &lt;/a&gt;&lt;/div&gt;&lt;style&gt; span &#123; color: red; &#125; div &gt; a &gt; span &#123; color: red; &#125;&lt;/style&gt; 对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。 生成渲染树 当我们生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。 在这一过程中，不是简单的将两者合并就行了。渲染树只会包括需要显示的节点和这些节点的样式信息，如果某个节点是 display: none 的，那么就不会在渲染树中显示。 当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。对于这一部分的内容因为过于底层，还涉及到了硬件相关的知识，这里就不再继续展开内容了。 那么通过以上内容，我们已经详细了解到了浏览器从接收文件到将内容渲染在屏幕上的这一过程。接下来，我们将会来学习上半部分遗留下来的一些知识点。 为什么操作 DOM 慢 想必大家都听过操作 DOM 性能很差，但是这其中的原因是什么呢？ 因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。 经典面试题：插入几万个 DOM，如何实现页面不卡顿？ 对于这道题目来说，首先我们肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。大部分人应该可以想到通过 requestAnimationFrame 的方式去循环的插入 DOM，其实还有种方式去解决这个问题：虚拟滚动（virtualized scroller）。 这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。 从上图中我们可以发现，即使列表很长，但是渲染的 DOM 元素永远只有那么几个，当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这道经典面试题。如果你想了解更多的内容可以了解下这个 react-virtualized。 什么情况阻塞渲染首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。 然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。 当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。 当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。 对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。 重绘（Repaint）和回流（Reflow）重绘和回流会在我们设置节点样式时频繁出现，同时也会很大程度上影响性能。 重绘是当节点需要更改外观而不会影响布局的，比如改变 color 就叫称为重绘 回流是布局或者几何属性需要改变就称为回流。 回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变父节点里的子节点很可能会导致父节点的一系列回流。 以下几个动作可能会导致性能问题： 改变 window 大小 改变字体 添加或删除样式 文字改变 定位或者浮动 盒模型 并且很多人不知道的是，重绘和回流其实也和 Eventloop 有关。 当 Eventloop 执行完 Microtasks 后，会判断 document 是否需要更新，因为浏览器是 60Hz 的刷新率，每 16.6ms 才会更新一次。 然后判断是否有 resize 或者 scroll 事件，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。 以上内容来自于 HTML 文档。 既然我们已经知道了重绘和回流会影响性能，那么接下来我们将会来学习如何减少重绘和回流的次数。 减少重绘和回流 使用 transform 替代 top 12345678910111213141516&lt;div class=\"test\"&gt;&lt;/div&gt;&lt;style&gt; .test &#123; position: absolute; top: 10px; width: 100px; height: 100px; background: red; &#125;&lt;/style&gt;&lt;script&gt; setTimeout(() =&gt; &#123; // 引起回流 document.querySelector(\".test\").style.top = \"100px\"; &#125;, 1000);&lt;/script&gt; - 使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局） - 不要把节点的属性值放在一个循环里当成循环里的变量 1234for (let i = 0; i &lt; 1000; i++) &#123; // 获取 offsetTop 会导致回流，因为需要去获取正确的值 console.log(document.querySelector(\".test\").style.offsetTop);&#125; - 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局 - 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame - CSS 选择符从右往左匹配查找，避免节点层级过多 - 将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。 设置节点为图层的方式有很多，我们可以通过以下几个常用属性可以生成新图层 will-change video、iframe 标签 思考题 思考题：在不考虑缓存和优化网络协议的前提下，考虑可以通过哪些方式来最快的渲染页面，也就是常说的关键渲染路径，这部分也是性能优化中的一块内容。 首先你可能会疑问，那怎么测量到底有没有加快渲染速度呢 当发生 DOMContentLoaded 事件后，就会生成渲染树，生成渲染树就可以进行渲染了，这一过程更大程度上和硬件有关系了。 提示如何加速： 从文件大小考虑 从 script 标签使用上来考虑 从 CSS、HTML 的代码书写上来考虑 从需要下载的内容是否需要在首屏使用上来考虑","categories":[],"tags":[]},{"title":"【Browser】浏览器基础知识","slug":"yuque/【Browser】浏览器基础知识","date":"2020-04-05T00:52:36.000Z","updated":"2020-06-07T13:19:55.171Z","comments":true,"path":"2020/04/05/yuque/【Browser】浏览器基础知识/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【Browser】浏览器基础知识/","excerpt":"","text":"title: 【Browser】浏览器基础知识date: 2019年04月08日 00:27:43categories: Browsertypora-root-url: ..typora-copy-images-to: ../images 事件机制 涉及面试题：事件的触发过程是怎么样的？知道什么是事件代理嘛？ 事件触发三阶段事件触发有三个阶段： window 往事件触发处传播，遇到注册的捕获事件会触发 传播到事件触发处时触发注册的事件 从事件触发处往 window 传播，遇到注册的冒泡事件会触发 事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个 body 中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。 123456789101112131415// 以下会先打印冒泡然后是捕获node.addEventListener( \"click\", (event) =&gt; &#123; console.log(\"冒泡\"); &#125;, false);node.addEventListener( \"click\", (event) =&gt; &#123; console.log(\"捕获 \"); &#125;, true); 注册事件通常我们使用 addEventListener 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false ，useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性 capture：布尔值，和 useCapture 作用一样 once：布尔值，值为 true 表示该回调只会调用一次，调用后会移除监听 passive：布尔值，表示永远不会调用 preventDefault 一般来说，如果我们只希望事件只触发在目标上，这时候可以使用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。 12345678910111213141516node.addEventListener( \"click\", (event) =&gt; &#123; event.stopImmediatePropagation(); console.log(\"冒泡\"); &#125;, false);// 点击 node 只会执行上面的函数，该函数不会执行node.addEventListener( \"click\", (event) =&gt; &#123; console.log(\"捕获 \"); &#125;, true); 事件代理如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上 12345678910111213&lt;ul id=\"ul\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; let ul = document.querySelector('#ul') ul.addEventListener('click', (event) =&gt; &#123; console.log(event.target); &#125;)&lt;/script&gt; 事件代理的方式相较于直接给目标注册事件来说，有以下优点： 节省内存 不需要给子节点注销事件 跨域 涉及面试题：什么是跨域？为什么浏览器要使用同源策略？你有几种方式可以解决跨域问题？了解预检请求嘛？ 因为浏览器出于安全考虑，有同源策略。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求会失败。 那么是出于什么安全考虑才会引入这种机制呢？ 其实主要是用来防止 CSRF 攻击的。简单点说，CSRF 攻击是利用用户的登录态发起恶意请求。 也就是说，没有同源策略的情况下，A 网站可以被任意其他来源的 Ajax 访问到内容。如果你当前 A 网站还存在登录态，那么对方就可以通过 Ajax 获得你的任何信息。当然跨域并不能完全阻止 CSRF。 然后我们来考虑一个问题，请求跨域了，那么请求到底发出去没有？ 请求必然是发出去了，但是浏览器拦截了响应。你可能会疑问明明通过表单的方式可以发起跨域请求，为什么 Ajax 就不会。因为归根结底，跨域是为了阻止用户读取到另一个域名下的内容，Ajax 可以获取响应，浏览器认为这不安全，所以拦截了响应。但是表单并不会获取新的内容，所以可以发起跨域请求。同时也说明了跨域并不能完全阻止 CSRF，因为请求毕竟是发出去了。 接下来我们将来学习几种常见的方式来解决跨域的问题。 JSONPJSONP 的原理很简单，就是利用 &lt;script&gt; 标签没有跨域限制的漏洞。通过 &lt;script&gt; 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。 123456&lt;script src=\"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp\"&gt;&lt;/script&gt;&lt;script&gt; function jsonp(data) &#123; console.log(data) &#125;&lt;/script&gt; JSONP 使用简单且兼容性不错，但是只限于 get 请求。 在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现 12345678910111213function jsonp(url, jsonpCallback, success) &#123; let script = document.createElement(\"script\"); script.src = url; script.async = true; script.type = \"text/javascript\"; window[jsonpCallback] = function (data) &#123; success &amp;&amp; success(data); &#125;; document.body.appendChild(script);&#125;jsonp(\"http://xxx\", \"callback\", function (value) &#123; console.log(value);&#125;); CORSCORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。 浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。只要后端实现了 CORS，就实现了跨域。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 虽然设置 CORS 和前端没什么关系，但是通过这种方式解决跨域问题的话，会在发送请求时出现两种情况，分别为简单请求和复杂请求。 简单请求以 Ajax 为例，当满足以下条件时，会触发简单请求 1. 使用下列方法之一： - GET - HEAD - POST 2. Content-Type 的值仅限于下列三者之一： - text/plain - multipart/form-data - application/x-www-form-urlencoded 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； XMLHttpRequestUpload 对象可以使用 XMLHttpRequest.upload 属性访问。 复杂请求那么很显然，不符合以上条件的请求就肯定是复杂请求了。 对于复杂请求来说，首先会发起一个预检请求，该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 对于预检请求来说，如果你使用过 Node 来设置 CORS 的话，可能会遇到过这么一个坑。 以下以 express 框架举例： 123456789app.use((req, res, next) =&gt; &#123; res.header(\"Access-Control-Allow-Origin\", \"*\"); res.header(\"Access-Control-Allow-Methods\", \"PUT, GET, POST, DELETE, OPTIONS\"); res.header( \"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept, Authorization, Access-Control-Allow-Credentials\" ); next();&#125;); 该请求会验证你的 Authorization 字段，没有的话就会报错。 当前端发起了复杂请求后，你会发现就算你代码是正确的，返回结果也永远是报错的。因为预检请求也会进入回调中，也会触发 next 方法，因为预检请求并不包含 Authorization 字段，所以服务端会报错。 想解决这个问题很简单，只需要在回调中过滤 option 方法即可 123res.statusCode = 204;res.setHeader(\"Content-Length\", \"0\");res.end(); document.domain该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。 只需要给页面添加 document.domain = &#39;test.com&#39; 表示二级域名都相同就可以实现跨域 postMessage这种方式通常用于获取嵌入页面中的第三方页面数据。一个页面发送消息，另一个页面判断来源并接收消息 12345678910// 发送消息端window.parent.postMessage(\"message\", \"http://test.com\");// 接收消息端var mc = new MessageChannel();mc.addEventListener(\"message\", (event) =&gt; &#123; var origin = event.origin || event.originalEvent.origin; if (origin === \"http://test.com\") &#123; console.log(\"验证通过\"); &#125;&#125;); 存储 涉及面试题：有几种方式可以实现存储功能，分别有什么优缺点？什么是 Service Worker？ cookie，localStorage，sessionStorage，indexDB我们先来通过表格学习下这几种存储方式的区别 特性 cookie localStorage sessionStorage indexDB 数据生命周期 一般由服务器生成，可以设置过期时间 除非被清理，否则一直存在 页面关闭就清理 除非被清理，否则一直存在 数据存储大小 4K 5M 5M 无限 与服务端通信 每次都会携带在 header 中，对于请求性能影响 不参与 不参与 不参与 从上表可以看到，cookie 已经不建议用于存储。如果没有大量数据存储需求的话，可以使用 localStorage 和 sessionStorage 。对于不怎么改变的数据尽量使用 localStorage 存储，否则可以用 sessionStorage 存储。 对于 cookie 来说，我们还需要注意安全性。 属性 作用 value 如果用于保存用户登录态，应该将该值加密，不能使用明文的用户标识 http-only 不能通过 JS 访问 Cookie，减少 XSS 攻击 secure 只能在协议为 HTTPS 的请求中携带 same-site 规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击 Service WorkerService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现： 123456789101112131415161718192021222324252627282930313233// index.jsif (navigator.serviceWorker) &#123; navigator.serviceWorker .register(\"sw.js\") .then(function (registration) &#123; console.log(\"service worker 注册成功\"); &#125;) .catch(function (err) &#123; console.log(\"servcie worker 注册失败\"); &#125;);&#125;// sw.js// 监听 `install` 事件，回调中缓存所需文件self.addEventListener(\"install\", (e) =&gt; &#123; e.waitUntil( caches.open(\"my-cache\").then(function (cache) &#123; return cache.addAll([\"./index.html\", \"./index.js\"]); &#125;) );&#125;);// 拦截所有请求事件// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据self.addEventListener(\"fetch\", (e) =&gt; &#123; e.respondWith( caches.match(e.request).then(function (response) &#123; if (response) &#123; return response; &#125; console.log(\"fetch source\"); &#125;) );&#125;); 打开页面，可以在开发者工具中的 Application 看到 Service Worker 已经启动了 在 Cache 中也可以发现我们所需的文件已被缓存 当我们重新刷新页面可以发现我们缓存的数据是从 Service Worker 中读取的","categories":[],"tags":[]},{"title":"【Algorithm】用JS刷剑指offer","slug":"yuque/【Algorithm】用JS刷剑指offer","date":"2020-04-05T00:52:31.000Z","updated":"2020-06-07T13:19:55.352Z","comments":true,"path":"2020/04/05/yuque/【Algorithm】用JS刷剑指offer/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【Algorithm】用JS刷剑指offer/","excerpt":"","text":"title: 【Algorithm】用 JS 刷剑指 offerdate: 2019 年 04 月 08 日 00:27:43categories: Algorithmtypora-root-url: ..typora-copy-images-to: ../images 1 二维数组的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题目分析该二维数组中的一个数，它左边的数都比它小，下边的数都比它大。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。 代码1234567891011121314151617181920function Find(target, array) &#123; // 边界条件 if (array == null || array.length === 0 || array[0].length === 0) &#123; return false; &#125; var rows = array.length; var cols = array[0].length; var r = 0; var c = cols - 1; while (r &lt;= rows - 1 &amp;&amp; c &gt;= 0) &#123; if (target == array[r][c]) &#123; return true; &#125; else if (target &gt; array[r][c]) &#123; r++; &#125; else &#123; c--; &#125; &#125; return false;&#125; 2 替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20Are%20Happy。 题目分析我们如果要替换空格，两步 先知道空格的位置 替换，但是字符串中有多个空格，所以我们就要循环，替换完之后再去查找字符串空格位置 当然你也可以选择用正则 代码123function replaceSpace(str) &#123; return str.replace(/\\s/g, \"%20\");&#125; 3 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个 ArrayList。 题目分析 代码123456789function printListFromTailToHead(head) &#123; // write code here let arr = []; while (head) &#123; arr.push(head.val); head = head.next; &#125; return arr.reverse();&#125; 4 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 题目分析前序遍历的第一个值为根节点的值，使用这个值将中序遍历结果分成两部分，左部分为树的左子树中序遍历结果，右部分为树的右子树中序遍历的结果。 代码12345678910111213141516171819202122/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null;&#125; */function reConstructBinaryTree(pre, vin) &#123; // write code here // 边界条件 if (pre.lenght === 0 || vin.length === 0) &#123; return null; &#125; let index = vin.indexOf(pre[0]); let left = vin.slice(0, index); let right = vin.slice(index + 1); return &#123; val: pre[0], left: reConstructBinaryTree(pre.slice(1, index + 1), left), right: reConstructBinaryTree(pre.slice(index + 1), right), &#125;;&#125; 5 用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。 题目分析in 栈用来处理入栈（push）操作，out 栈用来处理出栈（pop）操作。一个元素进入 in 栈之后，出栈的顺序被反转。当元素要出栈时，需要先进入 out 栈，此时元素出栈顺序再一次被反转，因此出栈顺序就和最开始入栈顺序是相同的，先进入的元素先退出，这就是队列的顺序。 代码123456789101112131415var inStack = [];var outStack = [];function push(node) &#123; // write code here inStack.push(node);&#125;function pop() &#123; if (!outStack.length) &#123; while (inStack.length) &#123; outStack.push(inStack.pop()); &#125; &#125; return outStack.pop();&#125; 6 旋转数组中的最小数字题目描述把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大小为 0，请返回 0。 题目分析在一个有序数组中查找一个元素可以用二分查找，二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度都为O(logN)。 本题可以修改二分查找算法进行求解： 当 nums[mid] &lt;= nums[high] 的情况下，说明解在 [low, mid] 之间，此时令 high = mid； 否则解在 [mid + 1, high] 之间，令 low = mid + 1。 代码暴力使用 sort 1234567function minNumberInRotateArray(rotateArray) &#123; // 边界条件 if (rotateArray.length === 0) return 0; return rotateArray.sort(function (a, b) &#123; return a - b; &#125;)[0];&#125; 二分法 1234567891011function minNumberInRotateArray(rotateArray) &#123; if (rotateArray.length == 0) return 0; var low = 0; var high = rotateArray.length - 1; while (low &lt; high) &#123; var mid = (low + high) &gt;&gt; 1; if (rotateArray[mid] &lt;= rotateArray[high]) high = mid; else low = mid + 1; &#125; return rotateArray[low];&#125; 7 斐波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数 n，请你输出斐波那契数列的第 n 项（从 0 开始，第 0 项为 0）。 n&lt;=39 题目分析 代码递归 虽然可以实现，但是运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。 12345function Fibonacci(n) &#123; // write code here if (n &gt;= 0 &amp;&amp; n &lt; 2) return n; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 动态规划 12345678910function Fibonacci(n) &#123; // write code here let arr = []; arr[0] = 0; arr[1] = 1; for (let i = 2; i &lt;= n; i++) &#123; arr[i] = arr[i - 1] + arr[i - 2]; &#125; return arr[n];&#125; 8 跳台阶题目描述一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 题目分析 稍微分析就知道这是斐波那契数列，所以可以动态规划来做 如果两种跳法，1 阶或者 2 阶，那么假定第一次跳的是一阶，那么剩下的是 n-1 个台阶，跳法是 f(n-1) 假定第一次跳的是 2 阶，那么剩下的是 n-2 个台阶，跳法是 f(n-2) 由 1、2 假设可以得出总跳法为：f(n) = f(n-1) + f(n-2) 通过实际的情况可以得出：只有一阶的时候 f(1) = 1 ,只有两阶的时候可以有 f(2) = 2 可以发现最终得出的是一个斐波那契数列 代码递归 12345function jumpFloor(number) &#123; // write code here if (number &lt;= 2) return number; return jumpFloor(number - 1) + jumpFloor(number - 2);&#125; 动态规划 1234567891011function jumpFloor(number) &#123; // write code here let arr = new Array(number + 1).fill(null); arr[0] = 0; arr[1] = 1; arr[2] = 2; for (let i = 3; i &lt;= number; i++) &#123; arr[i] = arr[i - 1] + arr[i - 2]; &#125; return arr[number];&#125; 9 变态跳台阶题目描述一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级……它也可以跳上 n 级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 题目分析根据上一个题目可以知道，青蛙只跳 1 或 2 可以得出是一个斐波那契问题，即a[n] = a[n-1] + a[n-2]，那么能跳 1,2,3 个台阶时a[n] = a[n-1] + a[n-2] + a[n-3] + ... + a[1] 那么有： 12a[n] = a[n-1] + a[n-2] + ... + a[1] ①a[n-1] = a[n-2] + a[n-3] + ... + a[1] ② ② - ①可得：a[n] = 2*a[n-1] 代码12345678function jumpFloorII(number) &#123; // write code here let acc = 1; while (--number) &#123; acc = acc * 2; &#125; return acc;&#125; 10 矩形覆盖题目描述我们可以用 2_1 的小矩形横着或者竖着去覆盖更大的矩形。请问用 n 个 2_1 的小矩形无重叠地覆盖一个 2*n 的大矩形，总共有多少种方法？ 题目分析其本质就是一个斐波那契数列 代码1234567891011function rectCover(number) &#123; // write code here var arr = []; arr[0] = 0; arr[1] = 1; arr[2] = 2; for (let i = 3; i &lt;= number; i++) &#123; arr[i] = arr[i - 2] + arr[i - 1]; &#125; return arr[number];&#125; 11 二进制中 1 的个数题目描述题目分析如果一个整数与 1 做与运算的结果是 1，则表示该整数最右边一位是 1，否则是 0 那么解法就出来了：一个一个向右移位，并且判断最右边的那个位是否为 1，为 1 就 count++ 但是这样输入负数时会陷入死循环，因为负数右移时，最高位补得是 1，那么这样会有无数个 1 此时这时候有两个解决办法： 既然不能对要操作的数一个一个右移位，那么我们可以考虑对另一个数 1 进行左移位计算 把一个整数减去 1，再和原整数做与运算，会把该整数最右边一个 1 变成 0。那么一个整数的二进制有多少个 1，就可以进行多少次这样的操作 代码方法 1 12345678910function NumberOf1(n) &#123; let count = 0; let flag = 1; while (flag) &#123; // 循环的次数等于整数二进制的位数，32位的整数需要循环32位 if (flag &amp; n) count++; flag = flag &lt;&lt; 1; &#125; return count;&#125; 方法 2 123456789function NumberOf1(n) &#123; let count = 0; while (n) &#123; // 有几位就循环几次，效率高 n = n &amp; (n - 1); count++; &#125; return count;&#125; Java 12345678910111213public class Solution &#123; public int NumberOf1(int n) &#123; int count = 0; int flag = 1; while(flag != 0) &#123; if((n &amp; flag) != 0) &#123; count++; &#125; flag = flag &lt;&lt; 1; &#125; return count; &#125;&#125; 12 数值的整数次方题目描述给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。 题目分析 js 中所有数字都是浮点数，所以3 / 2 === 1.5，所以在进行位运算和乘除运算时，最好都使用parseInt() 用右移运算（&gt;&gt;）代替除运算（/），所以parseInt(3) / 2 === parseInt(3) &gt;&gt; 1，直接3 &gt;&gt; 1也可以，但是浮点数位运算效率十分低 用位与运算代替求余运算（%），所以parseInt(3) % 2 === parseInt(3) &amp; 1，直接3 &amp; 1也可以，但是浮点数位运算效率十分低 代码12345678910111213function Power(base, exponent) &#123; // write code here if (exponent === 0) return 1; if (exponent === 1) return base; var isNegative = false; if (exponent &lt; 0) &#123; exponent = -exponent; isNegative = true; &#125; var pow = Power(base * base, parseInt(exponent) &gt;&gt; 1); if (parseInt(exponent) &amp; (1 !== 0)) pow = pow * base; return isNegative ? 1 / pow : pow;&#125; 13 调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 题目分析两个变量作为奇数和偶数的下标，我们可以维护两个指针 第一个指针初始化时指向数组的第一个数字，它只向后移动 第二个指针初始化时指向数组的最后一个数字，它只向前移动 在两个指针相遇之前，第一个指针总是位于第二个指针的前面。如果第一个指针指向的数字是偶数，并且第二个指针指向的数字是奇数，则交换这两个数字 代码1234567891011121314151617function reOrderArray(array) &#123; // write code here let oddbegin = 0; let oddcount = 0; let arr = []; for (let i = 0; i &lt; array.length; i++) &#123; if (array[i] &amp; 1) oddcount++; &#125; for (let i = 0; i &lt; array.length; i++) &#123; if (array[i] &amp; 1) &#123; arr[oddbegin++] = array[i]; &#125; else &#123; arr[oddcount++] = array[i]; &#125; &#125; return arr;&#125; 14 链表中倒数第 k 个节点题目描述输入一个链表，输出该链表中倒数第 k 个结点。 题目分析 代码我的解法 1234567891011121314/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/function FindKthToTail(head, k) &#123; // write code here if (head == null || k &lt;= 0) return null; let arr = []; while (head) &#123; arr.push(head); head = head.next; &#125; return arr[arr.length - k];&#125; 引用类型不是共享内存吗？应使用浅拷贝 123456789101112131415161718192021/* function ListNode(x)&#123; this.val = x; this.next = null; &#125;*/function FindKthToTail(head, k) &#123; if (head === null || k &lt;= 0) return null; let pNode1 = head; let pNode2 = head; while (--k) &#123; if (pNode2.next !== null) &#123; pNode2 = pNode2.next; &#125; else &#123; return null; &#125; &#125; while (pNode2.next !== null) &#123; pNode1 = pNode1.next; pNode2 = pNode2.next; &#125; return pNode1;&#125; 15 反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 题目分析 所以第一步要把当前节点的 next 记住 定义 3 个指针 当前遍历到的节点 它的前一个节点 它的后一个节点 代码123456789101112131415161718192021222324252627/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/function ReverseList(pHead) &#123; // write code here // 链表题都要判断边界条件，下句比较通用，都可以写 if (!pHead || !pHead.next) return pHead; // 记录当前节点 let current = pHead; // 记录当前节点的前一个节点 let pre = null; // 记录当前节点的后一个节点 let next; while (current) &#123; // 先记录当前节点的下一个节点，到时候断掉就找不到了 next = current.next; // 将当前节点的下一节点指向前一个节点 current.next = pre; // 前一个节点后移1位 pre = current; // 当前节点后移1位 current = next; &#125; return pre;&#125; 16 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调递增规则。 题目分析运用递归 代码123456789101112131415161718/*function ListNode(x)&#123; this.val = x; this.next = null;&#125;*/function Merge(pHead1, pHead2) &#123; // write code here if (!pHead1) return pHead2; if (!pHead2) return pHead1; let pMergeHead = null; if (pHead1.val &lt; pHead2.val) &#123; pMergeHead = pHead1; pMergeHead.next = Merge(pHead1.next, pHead2); &#125; else &#123; pMergeHead = pHead2; pMergeHead.next = Merge(pHead1, pHead2.next); &#125; return pMergeHead;&#125; 17 树的子结构 ❓题目描述输入两棵二叉树 A，B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构） 题目分析分析如何判断树 B 是不是树 A 的子结构，只需要两步。很容易看出来这是一个递归的过程。一般在树的求解方面都和递归有关。 在树 A 中找到和 B 的根结点的值一样的结点 R 判断树 A 中以 R 为根结点的子树是不是包含和树 B 一样的结点 代码1234567891011121314151617181920212223/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null; &#125; */function HasSubtree(pRoot1, pRoot2) &#123; let res = false; if (pRoot1 === null || pRoot2 === null) return false; if (pRoot1.val === pRoot2.val) res = doesTree1HasTree2(pRoot1, pRoot2); if (!res) res = HasSubtree(pRoot1.left, pRoot2); if (!res) res = HasSubtree(pRoot1.right, pRoot2); return res;&#125;function doesTree1HasTree2(pRoot1, pRoot2) &#123; if (pRoot2 === null) return true; if (pRoot1 === null) return false; if (pRoot1.val !== pRoot2.val) return false; return ( doesTree1HasTree2(pRoot1.left, pRoot2.left) &amp;&amp; doesTree1HasTree2(pRoot1.right, pRoot2.right) );&#125; 18 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像 二叉树的镜像定义：源二叉树 题目分析递归交换左右节点 代码123456789101112131415/* function TreeNode(x) &#123; this.val = x; this.left = null; this.right = null;&#125; */function Mirror(root) &#123; // write code here if (root === null) return; if (root.left === null &amp;&amp; root.right === null) return; let temp = root.left; root.left = root.right; root.right = temp; if (root.left) Mirror(root.left); if (root.right) Mirror(root.right);&#125; 19 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如 题目分析用左上和右下的坐标定位出一次要旋转打印的数据，一次旋转打印结束后，往对角分别前进和后退一个单位。 代码123456789101112131415161718192021222324252627282930313233343536function printMatrix(matrix) &#123; // write code here if (matrix == null) return; const rows = matrix.length; const cols = matrix[0].length; let start = 0; let result = []; while (rows &gt; start * 2 &amp;&amp; cols &gt; start * 2) &#123; result = result.concat(printMatrixInCircle(matrix, rows, cols, start)); start++; &#125; return result;&#125;function printMatrixInCircle(matrix, rows, cols, start) &#123; const endX = cols - 1 - start; const endY = rows - 1 - start; let result = []; // 从左往右 for (let i = start; i &lt;= endX; i++) &#123; result.push(matrix[start][i]); &#125; // 从上往下 for (let i = start + 1; i &lt;= endY; i++) &#123; result.push(matrix[i][endX]); &#125; // 从右往左 for (let i = endX - 1; i &gt;= start &amp;&amp; endY &gt; start; i--) &#123; result.push(matrix[endY][i]); &#125; // 从下往上 for (let i = endY - 1; i &gt;= start + 1 &amp;&amp; endX &gt; start; i--) &#123; result.push(matrix[i][start]); &#125; return result;&#125; 20 包含 min 函数的栈 中等 辅助栈21 栈的压入、弹出序列 中等 辅助栈22 从上往下打印二叉树 简单 广度遍历、队列23 二叉树的后续遍历序列 中等 画图24 二叉树和为某一值的遍历序列 中等 深度遍历、递归25 复杂链表的复制 难 map 保存&lt;N,N’&gt; || N-&gt;N’得 S-&gt;S‘26 二叉搜索树与双向链表 中等偏难 递归、中序遍历27 字符串的排列 难 回溯法 || 递归全排列法28 数组中出现次数超过一半的数 中等 partion 法 || times 变量变化法29 最小的 k 个数 中等 partion 法30 连续子数组的最大值 中等 找规律、动态规划、注意判断条件31 （~n 整数中 1 出现的次数 中等 位运算 || 数学分析把数组排成最小的数 简单偏难 改变排序规则丑数 难 动态规划、注意判断条件第一个只出现一次的字符 哈希表记录数组中的逆序对 难+ 基于归并排序、临时数组两个链表中的第一个公共节点 简单 双指针法数字在排序数组中出现的次数 简单偏难 二分法改造二叉树的深度 简单 递归平衡二叉树 简单 递归数组中只出现一次的数字 简单 indexOf || map 记录 || 异或和为 S 的连续正数序列 中等 数学分析和为 S 的字符串 简单 双指针左旋转字符串 简单 裁剪拼接单次翻转序列 简单 转数组，对每项反序扑克牌顺子 中等 注意题目条件、位运算判断数字重复孩子们的游戏 难 数学分析得出公式 || 画图按题目做、注意下标求 1+2+3+…+n 中等 位运算、递归不用加减乘除做加法 中等 位运算把字符串转成整数 中等 位运算数组中重复的数字 中等 将值放到对应位置上构建乘积数组 中等偏上 借助中间变量存储后面的乘积正则表达式的匹配 难 注意判断条件、递归表示数值的字符串 中等 正则字符流中第一个不重复的数字 中等 map 记录 || indexOf 法链表中环的入口节点 中等 双指针法、数学分析删除链表中重复的节点 中等 加头节点、注意多个重复二叉树的下一个节点 中等 画图、分析各种情况对称的二叉树 中等 递归、对称遍历按之字形顺序打印二叉树 难 广度遍历、两个栈把二叉树打印成多行 中等偏难 队列+两个记录变量序列化二叉树 中等 数组代表流、递归二叉搜索树的第 k 个节点 中等 中序遍历+计数变量数据流的中位数 中等 partion 法 || 维持排序 || 排序链表法 || AVL 树 || 最大堆和最小堆滑动窗口中的最大值 难 改变参考对象、双端队列、存下标矩阵中的路径 中等 回溯法机器人的运动范围 中等 回溯法参考资料 [1]https://www.cnblogs.com/wuguanglin/p/code-interview.html [2]https://github.com/cyc2018/cs-notes/blob/master/docs/notes/剑指 offer 题解 - 目录.md [3]https://www.cnblogs.com/wuguanglin/p/summaryofjsdoalgorithmproblem.html","categories":[],"tags":[]},{"title":"【Algorithm】常考算法题解析","slug":"yuque/【Algorithm】常考算法题解析","date":"2020-04-05T00:52:26.000Z","updated":"2020-06-07T13:19:55.565Z","comments":true,"path":"2020/04/05/yuque/【Algorithm】常考算法题解析/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【Algorithm】常考算法题解析/","excerpt":"","text":"title: 【Algorithm】常考算法题解析 date: 2019 年 04 月 08 日 00:27:43categories: Algorithmtypora-root-url: ..typora-copy-images-to: ../images 常考算法题解析这一章节依托于数据结构的内容，毕竟了解了数据结构我们才能写出更好的算法。 对于大部分公司的面试来说，排序的内容已经足以应付了，由此为了更好的符合大众需求，排序的内容是最多的。当然如果你还想冲击更好的公司，那么整一个章节的内容都是需要掌握的。对于字节跳动这类十分看重算法的公司来说，这一章节是远远不够的，剑指 Offer应该是你更好的选择。 有一个可视化界面会相对减少点学习的难度，具体可以阅读 algorithm-visualizer 这个仓库。 位运算在进入正题之前，我们先来学习一下位运算的内容。因为位运算在算法中很有用，速度可以比四则运算快很多。 在学习位运算之前应该知道十进制如何转二进制，二进制如何转十进制。这里说明下简单的计算方式 十进制 33 可以看成是 32 + 1 ，并且 33 应该是六位二进制的（因为 33 近似 32，而 32 是 2 的五次方，所以是六位），那么 十进制 33 就是 100001 ，只要是 2 的次方，那么就是 1 否则都为 0 2^1 = 2, 2^2 = 4, 2^3 = 8, 2^4 = 16, 2^5 = 32, 2^6 = 64, 2^7 = 128 那么二进制 100001 同理，首位是 2^5 ，末位是 2^0 ，相加得出 33 算数左移 &lt;&lt;110 &lt;&lt; 1; // -&gt; 20 左移就是将二进制全部往左移动，10 在二进制中表示为 1010 ，左移一位后变成 10100 ，转换为十进制也就是 20，所以基本可以把左移看成以下公式 a * (2 ^ b) 算数右移 &gt;&gt;110 &gt;&gt; 1; // -&gt; 5 算数右移就是将二进制全部往右移动并去除多余的右边，10 在二进制中表示为 1010 ，右移一位后变成 101 ，转换为十进制也就是 5，所以基本可以把右移看成以下公式 a / (2 ^ b) 条件 右移很好用，比如可以用在二分算法中取中间值 113 &gt;&gt; 1; // -&gt; 6 按位操作按位与 每一位都为 1，结果才为 1，否则为 0 128 &amp; 7; // -&gt; 0// 1000 &amp; 0111 -&gt; 0000 -&gt; 0 按位或 其中一位为 1，结果就是 1 128 | 7; // -&gt; 15// 1000 | 0111 -&gt; 1111 -&gt; 15 按位异或 每一位都不同，结果才为 1 12348 ^ 7; // -&gt; 158 ^ 8; // -&gt; 0// 1000 ^ 0111 -&gt; 1111 -&gt; 15// 1000 ^ 1000 -&gt; 0000 -&gt; 0 从以上代码中可以发现按位异或就是不进位加法 面试题：两个数不使用四则运算得出和 这道题中可以按位异或，因为按位异或就是不进位加法，8 ^ 8 = 0 如果进位了，就是 16 了，所以我们只需要将两个数进行异或操作，然后进位。那么也就是说两个二进制都是 1 的位置，左边应该有一个进位 1，所以可以得出以下公式 a + b = (a ^ b) + ((a &amp; b) &lt;&lt; 1) ，然后通过迭代的方式模拟加法 1234567function sum(a, b) &#123; if (a == 0) return b; if (b == 0) return a; let newA = a ^ b; let newB = (a &amp; b) &lt;&lt; 1; return sum(newA, newB);&#125; 排序以下两个函数是排序中会用到的通用函数，就不一一写了 12345678function checkArray(array) &#123; if (!array) return;&#125;function swap(array, left, right) &#123; let rightValue = array[right]; array[right] = array[left]; array[left] = rightValue;&#125; 冒泡排序冒泡排序的原理如下，从第一个元素开始，把当前元素和下一个索引元素进行比较。如果当前元素大，那么就交换位置，重复操作直到比较到最后一个元素，那么此时最后一个元素就是该数组中最大的数。下一轮重复以上操作，但是此时最后一个元素已经是最大数了，所以不需要再比较最后一个元素，只需要比较到 length - 2 的位置。 12345678910function bubble(array) &#123; checkArray(array); for (let i = array.length - 1; i &gt; 0; i--) &#123; // 从 0 到 `length - 1` 遍历 for (let j = 0; j &lt; i; j++) &#123; if (array[j] &gt; array[j + 1]) swap(array, j, j + 1); &#125; &#125; return array;&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 插入排序插入排序的原理如下。第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。那么此时第一个元素就是当前的最小数，所以下次取出操作从第三个元素开始，向前对比，重复之前的操作。 以下是实现该算法的代码 12345678function insertion(array) &#123; checkArray(array); for (let i = 1; i &lt; array.length; i++) &#123; for (let j = i - 1; j &gt;= 0 &amp;&amp; array[j] &gt; array[j + 1]; j--) swap(array, j, j + 1); &#125; return array;&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 选择排序选择排序的原理如下。遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。如上操作后，第一个元素就是数组中的最小值，下次遍历就可以从索引 1 开始重复上述操作。 以下是实现该算法的代码 1234567891011function selection(array) &#123; checkArray(array); for (let i = 0; i &lt; array.length - 1; i++) &#123; let minIndex = i; for (let j = i + 1; j &lt; array.length; j++) &#123; minIndex = array[j] &lt; array[minIndex] ? j : minIndex; &#125; swap(array, i, minIndex); &#125; return array;&#125; 该算法的操作次数是一个等差数列 n + (n - 1) + (n - 2) + 1 ，去掉常数项以后得出时间复杂度是 O(n * n) 归并排序归并排序的原理如下。递归的将数组两两分开直到最多包含两个元素，然后将数组排序合并，最终合并为排序好的数组。假设我有一组数组 [3, 1, 2, 8, 9, 7, 6]，中间数索引是 3，先排序数组 [3, 1, 2, 8] 。在这个左边数组上，继续拆分直到变成数组包含两个元素（如果数组长度是奇数的话，会有一个拆分数组只包含一个元素）。然后排序数组 [3, 1] 和 [2, 8] ，然后再排序数组 [1, 3, 2, 8] ，这样左边数组就排序完成，然后按照以上思路排序右边数组，最后将数组 [1, 2, 3, 8] 和 [6, 7, 9] 排序。 以下是实现该算法的代码 12345678910111213141516171819202122232425262728293031323334function sort(array) &#123; checkArray(array); mergeSort(array, 0, array.length - 1); return array;&#125;function mergeSort(array, left, right) &#123; // 左右索引相同说明已经只有一个数 if (left === right) return; // 等同于 `left + (right - left) / 2` // 相比 `(left + right) / 2` 来说更加安全，不会溢出 // 使用位运算是因为位运算比四则运算快 let mid = parseInt(left + ((right - left) &gt;&gt; 1)); mergeSort(array, left, mid); mergeSort(array, mid + 1, right); let help = []; let i = 0; let p1 = left; let p2 = mid + 1; while (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123; help[i++] = array[p1] &lt; array[p2] ? array[p1++] : array[p2++]; &#125; while (p1 &lt;= mid) &#123; help[i++] = array[p1++]; &#125; while (p2 &lt;= right) &#123; help[i++] = array[p2++]; &#125; for (let i = 0; i &lt; help.length; i++) &#123; array[left + i] = help[i]; &#125; return array;&#125; 以上算法使用了递归的思想。递归的本质就是压栈，每递归执行一次函数，就将该函数的信息（比如参数，内部的变量，执行到的行数）压栈，直到遇到终止条件，然后出栈并继续执行函数。对于以上递归函数的调用轨迹如下 1234567891011121314mergeSort(data, 0, 6); // mid = 3mergeSort(data, 0, 3); // mid = 1mergeSort(data, 0, 1); // mid = 0mergeSort(data, 0, 0); // 遇到终止，回退到上一步mergeSort(data, 1, 1); // 遇到终止，回退到上一步// 排序 p1 = 0, p2 = mid + 1 = 1// 回退到 `mergeSort(data, 0, 3)` 执行下一个递归mergeSort(2, 3); // mid = 2mergeSort(3, 3); // 遇到终止，回退到上一步// 排序 p1 = 2, p2 = mid + 1 = 3// 回退到 `mergeSort(data, 0, 3)` 执行合并逻辑// 排序 p1 = 0, p2 = mid + 1 = 2// 执行完毕回退// 左边数组排序完毕，右边也是如上轨迹 该算法的操作次数是可以这样计算：递归了两次，每次数据量是数组的一半，并且最后把整个数组迭代了一次，所以得出表达式 2T(N / 2) + T(N) （T 代表时间，N 代表数据量）。根据该表达式可以套用 该公式 得出时间复杂度为 O(N * logN) 快排快排的原理如下。随机选取一个数组中的值作为基准值，从左至右取值与基准值对比大小。比基准值小的放数组左边，大的放右边，对比完成后将基准值和第一个比基准值大的值交换位置。然后将数组以基准值的位置分为两部分，继续递归以上操作。 图解：https://my.oschina.net/albert2011/blog/785604 以下是实现该算法的代码 1234567891011121314151617181920212223242526272829303132333435363738function sort(array) &#123; checkArray(array); quickSort(array, 0, array.length - 1); return array;&#125;function quickSort(array, left, right) &#123; if (left &lt; right) &#123; swap(array, , right) // 随机取值，然后和末尾交换，这样做比固定取一个位置的复杂度略低 let indexs = part(array, parseInt(Math.random() * (right - left + 1)) + left, right); quickSort(array, left, indexs[0]); quickSort(array, indexs[1] + 1, right); &#125;&#125;function part(array, left, right) &#123; let less = left - 1; let more = right; while (left &lt; more) &#123; if (array[left] &lt; array[right]) &#123; // 当前值比基准值小，`less` 和 `left` 都加一 ++less; ++left; &#125; else if (array[left] &gt; array[right]) &#123; // 当前值比基准值大，将当前值和右边的值交换 // 并且不改变 `left`，因为当前换过来的值还没有判断过大小 swap(array, --more, left); &#125; else &#123; // 和基准值相同，只移动下标 left++; &#125; &#125; // 将基准值和比基准值大的第一个值交换位置 // 这样数组就变成[比基准值小, 基准值, 比基准值大] swap(array, right, more); return [less, more];&#125; 该算法的复杂度和归并排序是相同的，但是额外空间复杂度比归并排序少，只需 O(logN)，并且相比归并排序来说，所需的常数时间也更少。 面试题Sort Colors：该题目来自 LeetCode，题目需要我们将 [2,0,2,1,1,0] 排序成 [0,0,1,1,2,2] ，这个问题就可以使用三路快排的思想。 123456789101112131415var sortColors = function (nums) &#123; let left = -1; let right = nums.length; let i = 0; // 下标如果遇到 right，说明已经排序完成 while (i &lt; right) &#123; if (nums[i] == 0) &#123; swap(nums, i++, ++left); &#125; else if (nums[i] == 1) &#123; i++; &#125; else &#123; swap(nums, i, --right); &#125; &#125;&#125;; Kth Largest Element in an Array：该题目来自 LeetCode，题目需要找出数组中第 K 大的元素，这问题也可以使用快排的思路。并且因为是找出第 K 大元素，所以在分离数组的过程中，可以找出需要的元素在哪边，然后只需要排序相应的一边数组就好。 123456789101112131415161718192021222324252627282930313233343536var findKthLargest = function (nums, k) &#123; let l = 0; let r = nums.length - 1; // 得出第 K 大元素的索引位置 k = nums.length - k; while (l &lt; r) &#123; // 分离数组后获得比基准树大的第一个元素索引 let index = part(nums, l, r); // 判断该索引和 k 的大小 if (index &lt; k) &#123; l = index + 1; &#125; else if (index &gt; k) &#123; r = index - 1; &#125; else &#123; break; &#125; &#125; return nums[k];&#125;;function part(array, left, right) &#123; let less = left - 1; let more = right; while (left &lt; more) &#123; if (array[left] &lt; array[right]) &#123; ++less; ++left; &#125; else if (array[left] &gt; array[right]) &#123; swap(array, --more, left); &#125; else &#123; left++; &#125; &#125; swap(array, right, more); return more;&#125; 堆排序堆排序利用了二叉堆的特性来做，二叉堆通常用数组表示，并且二叉堆是一颗完全二叉树（所有叶节点（最底层的节点）都是从左往右顺序排序，并且其他层的节点都是满的）。二叉堆又分为大根堆与小根堆。 大根堆是某个节点的所有子节点的值都比他小 小根堆是某个节点的所有子节点的值都比他大 堆排序的原理就是组成一个大根堆或者小根堆。以小根堆为例，某个节点的左边子节点索引是 i * 2 + 1，右边是 i * 2 + 2，父节点是 (i - 1) /2。 首先遍历数组，判断该节点的父节点是否比他小，如果小就交换位置并继续判断，直到他的父节点比他大 重新以上操作 1，直到数组首位是最大值 然后将首位和末尾交换位置并将数组长度-1，表示数组末尾已是最大值，不需要再比较大小 对比左右节点哪个大，然后记住大的节点的索引并且和父节点对比大小，如果子节点大就交换位置 重复以上操作 3 - 4 直到整个数组都是大根堆。 以下是实现该算法的代码 123456789101112131415161718192021222324252627282930313233343536373839function heap(array) &#123; checkArray(array); // 将最大值交换到首位 for (let i = 0; i &lt; array.length; i++) &#123; heapInsert(array, i); &#125; let size = array.length; // 交换首位和末尾 swap(array, 0, --size); while (size &gt; 0) &#123; heapify(array, 0, size); swap(array, 0, --size); &#125; return array;&#125;function heapInsert(array, index) &#123; // 如果当前节点比父节点大，就交换 while (array[index] &gt; array[parseInt((index - 1) / 2)]) &#123; swap(array, index, parseInt((index - 1) / 2)); // 将索引变成父节点 index = parseInt((index - 1) / 2); &#125;&#125;function heapify(array, index, size) &#123; let left = index * 2 + 1; while (left &lt; size) &#123; // 判断左右节点大小 let largest = left + 1 &lt; size &amp;&amp; array[left] &lt; array[left + 1] ? left + 1 : left; // 判断子节点和父节点大小 largest = array[index] &lt; array[largest] ? largest : index; if (largest === index) break; swap(array, index, largest); index = largest; left = index * 2 + 1; &#125;&#125; 以上代码实现了小根堆，如果需要实现大根堆，只需要把节点对比反一下就好。 该算法的复杂度是 O(logN) 系统自带排序实现每个语言的排序内部实现都是不同的。 对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序 源码实现 。选择插入排序是因为虽然时间复杂度很差，但是在数据量很小的情况下和 O(N * logN)相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。 对于 Java 来说，还会考虑内部的元素的类型。对于存储对象的数组来说，会采用稳定性好的算法。稳定性的意思就是对于相同值来说，相对顺序不能改变。 链表反转单向链表该题目来自 LeetCode，题目需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前节点的前后节点，虽然这题很简单，但是却是一道面试常考题 以下是实现该算法的代码 12345678910111213141516171819var reverseList = function (head) &#123; // 判断下变量边界问题 if (!head || !head.next) return head; // 初始设置为空，因为第一个节点反转后就是尾部，尾部节点指向 null let pre = null; let current = head; let next; // 判断当前节点是否为空 // 不为空就先获取当前节点的下一节点 // 然后把当前节点的 next 设为上一个节点 // 然后把 current 设为下一个节点，pre 设为当前节点 while (current) &#123; next = current.next; current.next = pre; pre = current; current = next; &#125; return pre;&#125;; 树二叉树的先序，中序，后序遍历先序遍历表示先访问根节点，然后访问左节点，最后访问右节点。 中序遍历表示先访问左节点，然后访问根节点，最后访问右节点。 后序遍历表示先访问左节点，然后访问右节点，最后访问根节点。 递归实现递归实现相当简单，代码如下 1234567891011121314151617181920212223function TreeNode(val) &#123; this.val = val; this.left = this.right = null;&#125;var traversal = function (root) &#123; if (root) &#123; // 先序 console.log(root); traversal(root.left); traversal(root.right); // 中序 traversal(root.left); console.log(root); traversal(root.right); // 后序 traversal(root.left); traversal(root.right); console.log(root); &#125;&#125;; 对于递归的实现来说，只需要理解每个节点都会被访问三次就明白为什么这样实现了。 非递归实现非递归实现使用了栈的结构，通过栈的先进后出模拟递归实现。 以下是先序遍历代码实现 123456789101112131415161718192021function pre(root) &#123; if (root) &#123; let stack = []; // 先将根节点 push stack.push(root); // 判断栈中是否为空 while (stack.length &gt; 0) &#123; // 弹出栈顶元素 root = stack.pop(); console.log(root); // 因为先序遍历是先左后右，栈是先进后出结构 // 所以先 push 右边再 push 左边 if (root.right) &#123; stack.push(root.right); &#125; if (root.left) &#123; stack.push(root.left); &#125; &#125; &#125;&#125; 以下是中序遍历代码实现 1234567891011121314151617181920function mid(root) &#123; if (root) &#123; let stack = []; // 中序遍历是先左再根最后右 // 所以首先应该先把最左边节点遍历到底依次 push 进栈 // 当左边没有节点时，就打印栈顶元素，然后寻找右节点 // 对于最左边的叶节点来说，可以把它看成是两个 null 节点的父节点 // 左边打印不出东西就把父节点拿出来打印，然后再看右节点 while (stack.length &gt; 0 || root) &#123; if (root) &#123; stack.push(root); root = root.left; &#125; else &#123; root = stack.pop(); console.log(root); root = root.right; &#125; &#125; &#125;&#125; 以下是后序遍历代码实现，该代码使用了两个栈来实现遍历，相比一个栈的遍历来说要容易理解很多 1234567891011121314151617181920212223function pos(root) &#123; if (root) &#123; let stack1 = []; let stack2 = []; // 后序遍历是先左再右最后根 // 所以对于一个栈来说，应该先 push 根节点 // 然后 push 右节点，最后 push 左节点 stack1.push(root); while (stack1.length &gt; 0) &#123; root = stack1.pop(); stack2.push(root); if (root.left) &#123; stack1.push(root.left); &#125; if (root.right) &#123; stack1.push(root.right); &#125; &#125; while (stack2.length &gt; 0) &#123; console.log(s2.pop()); &#125; &#125;&#125; 中序遍历的前驱后继节点实现这个算法的前提是节点有一个 parent 的指针指向父节点，根节点指向 null 。 如图所示，该树的中序遍历结果是 4, 2, 5, 1, 6, 3, 7 前驱节点对于节点 2 来说，他的前驱节点就是 4 ，按照中序遍历原则，可以得出以下结论 如果选取的节点的左节点不为空，就找该左节点最右的节点。对于节点 1 来说，他有左节点 2 ，那么节点 2 的最右节点就是 5 如果左节点为空，且目标节点是父节点的右节点，那么前驱节点为父节点。对于节点 5 来说，没有左节点，且是节点 2 的右节点，所以节点 2 是前驱节点 如果左节点为空，且目标节点是父节点的左节点，向上寻找到第一个是父节点的右节点的节点。对于节点 6 来说，没有左节点，且是节点 3 的左节点，所以向上寻找到节点 1 ，发现节点 3 是节点 1 的右节点，所以节点 1 是节点 6 的前驱节点 以下是算法实现 12345678910111213141516171819202122function predecessor(node) &#123; if (!node) return; // 结论 1 if (node.left) &#123; return getRight(node.left); &#125; else &#123; let parent = node.parent; // 结论 2 3 的判断 while (parent &amp;&amp; parent.right === node) &#123; node = parent; parent = node.parent; &#125; return parent; &#125;&#125;function getRight(node) &#123; if (!node) return; node = node.right; while (node) node = node.right; return node;&#125; 后继节点对于节点 2 来说，他的后继节点就是 5 ，按照中序遍历原则，可以得出以下结论 如果有右节点，就找到该右节点的最左节点。对于节点 1 来说，他有右节点 3 ，那么节点 3 的最左节点就是 6 如果没有右节点，就向上遍历直到找到一个节点是父节点的左节点。对于节点 5 来说，没有右节点，就向上寻找到节点 2 ，该节点是父节点 1 的左节点，所以节点 1 是后继节点 以下是算法实现 1234567891011121314151617181920212223function successor(node) &#123; if (!node) return; // 结论 1 if (node.right) &#123; return getLeft(node.right); &#125; else &#123; // 结论 2 let parent = node.parent; // 判断 parent 为空 while (parent &amp;&amp; parent.left === node) &#123; node = parent; parent = node.parent; &#125; return parent; &#125;&#125;function getLeft(node) &#123; if (!node) return; node = node.left; while (node) node = node.left; return node;&#125; 树的深度树的最大深度：该题目来自 Leetcode，题目需要求出一颗二叉树的最大深度 以下是算法实现 1234var maxDepth = function (root) &#123; if (!root) return 0; return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;&#125;; 对于该递归函数可以这样理解：一旦没有找到节点就会返回 0，每弹出一次递归函数就会加一，树有三层就会得到 3。 动态规划动态规划背后的基本思想非常简单。就是将一个问题拆分为子问题，一般来说这些子问题都是非常相似的，那么我们可以通过只解决一次每个子问题来达到减少计算量的目的。 一旦得出每个子问题的解，就存储该结果以便下次使用。 斐波那契数列斐波那契数列就是从 0 和 1 开始，后面的数都是前两个数之和 0，1，1，2，3，5，8，13，21，34，55，89…. 那么显然易见，我们可以通过递归的方式来完成求解斐波那契数列 12345function fib(n) &#123; if (n &lt; 2 &amp;&amp; n &gt;= 0) return n; return fib(n - 1) + fib(n - 2);&#125;fib(10); 以上代码已经可以完美的解决问题。但是以上解法却存在很严重的性能问题，当 n 越大的时候，需要的时间是指数增长的，这时候就可以通过动态规划来解决这个问题。 动态规划的本质其实就是两点 自底向上分解子问题 通过变量存储已经计算过的解 根据上面两点，我们的斐波那契数列的动态规划思路也就出来了 斐波那契数列从 0 和 1 开始，那么这就是这个子问题的最底层 通过数组来存储每一位所对应的斐波那契数列的值 12345678910function fib(n) &#123; let array = new Array(n + 1).fill(null); array[0] = 0; array[1] = 1; for (let i = 2; i &lt;= n; i++) &#123; array[i] = array[i - 1] + array[i - 2]; &#125; return array[n];&#125;fib(10); 0 - 1 背包问题该问题可以描述为：给定一组物品，每种物品都有自己的重量和价格，在限定的总重量内，我们如何选择，才能使得物品的总价格最高。每个问题只能放入至多一次。 假设我们有以下物品 物品 ID / 重量 价值 1 3 2 7 3 12 对于一个总容量为 5 的背包来说，我们可以放入重量 2 和 3 的物品来达到背包内的物品总价值最高。 对于这个问题来说，子问题就两个，分别是放物品和不放物品，可以通过以下表格来理解子问题 物品 ID / 剩余容量 0 1 2 3 4 5 1 0 3 3 3 3 3 2 0 3 7 10 10 10 3 0 3 7 12 15 19 直接来分析能放三种物品的情况，也就是最后一行 当容量少于 3 时，只取上一行对应的数据，因为当前容量不能容纳物品 3 当容量 为 3 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，总价值为 12，所以应该放入物品 3 当容量 为 4 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，和放入物品 1 的价值相加，得出总价值为 15，所以应该放入物品 3 当容量 为 5 时，考虑两种情况，分别为放入物品 3 和不放物品 3 不放物品 3 的情况下，总价值为 10 放入物品 3 的情况下，和放入物品 2 的价值相加，得出总价值为 19，所以应该放入物品 3 1234567891011121314151617181920212223242526272829303132333435363738/** * @param &#123;*&#125; w 物品重量 * @param &#123;*&#125; v 物品价值 * @param &#123;*&#125; C 总容量 * @returns */function knapsack(w, v, C) &#123; let length = w.length; if (length === 0) return 0; // 对照表格，生成的二维数组，第一维代表物品，第二维代表背包剩余容量 // 第二维中的元素代表背包物品总价值 let array = new Array(length).fill(new Array(C + 1).fill(null)); // 完成底部子问题的解 for (let i = 0; i &lt;= C; i++) &#123; // 对照表格第一行， array[0] 代表物品 1 // i 代表剩余总容量 // 当剩余总容量大于物品 1 的重量时，记录下背包物品总价值，否则价值为 0 array[0][i] = i &gt;= w[0] ? v[0] : 0; &#125; // 自底向上开始解决子问题，从物品 2 开始 for (let i = 1; i &lt; length; i++) &#123; for (let j = 0; j &lt;= C; j++) &#123; // 这里求解子问题，分别为不放当前物品和放当前物品 // 先求不放当前物品的背包总价值，这里的值也就是对应表格中上一行对应的值 array[i][j] = array[i - 1][j]; // 判断当前剩余容量是否可以放入当前物品 if (j &gt;= w[i]) &#123; // 可以放入的话，就比大小 // 放入当前物品和不放入当前物品，哪个背包总价值大 array[i][j] = Math.max(array[i][j], v[i] + array[i - 1][j - w[i]]); &#125; &#125; &#125; return array[length - 1][C];&#125; 最长递增子序列最长递增子序列意思是在一组数字中，找出最长一串递增的数字，比如 0, 3, 4, 17, 2, 8, 6, 10 对于以上这串数字来说，最长递增子序列就是 0, 3, 4, 8, 10，可以通过以下表格更清晰的理解 数字 0 3 4 17 2 8 6 10 长度 1 2 3 4 2 4 4 5 通过以上表格可以很清晰的发现一个规律，找出刚好比当前数字小的数，并且在小的数组成的长度基础上加一。 这个问题的动态思路解法很简单，直接上代码 1234567891011121314151617181920function lis(n) &#123; if (n.length === 0) return 0; // 创建一个和参数相同大小的数组，并填充值为 1 let array = new Array(n.length).fill(1); // 从索引 1 开始遍历，因为数组已经所有都填充为 1 了 for (let i = 1; i &lt; n.length; i++) &#123; // 从索引 0 遍历到 i // 判断索引 i 上的值是否大于之前的值 for (let j = 0; j &lt; i; j++) &#123; if (n[i] &gt; n[j]) &#123; array[i] = Math.max(array[i], 1 + array[j]); &#125; &#125; &#125; let res = 1; for (let i = 0; i &lt; array.length; i++) &#123; res = Math.max(res, array[i]); &#125; return res;&#125;","categories":[],"tags":[]},{"title":"【数据结构】第一章 绪论","slug":"yuque/【数据结构】第一章 绪论","date":"2020-04-05T00:52:21.000Z","updated":"2020-06-07T13:19:55.598Z","comments":true,"path":"2020/04/05/yuque/【数据结构】第一章 绪论/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【数据结构】第一章 绪论/","excerpt":"","text":"title: 【数据结构】第一章 绪论 date: 2019 年 04 月 08 日 00:27:43categories: DataStructtypora-root-url: ..typora-copy-images-to: ../images 基本概念和术语(1) 数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。数据不仅仅包括整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型 (2) 数据对象是性质相同的数据元素的集合，是数据的子集 (3) 数据元素 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录 数据元素才是数据结构中建立数据模型的着眼点 (4) 数据项一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位 (5) 关系 2 数据结构(1) 逻辑结构A 集合 B 线性结构 C 树 D 图 (2) 存储结构（物理结构）A 顺序存储结构排队占位。大家都按顺序排好，每个人占一小段空间，大家谁也别插谁的队 B 链式存储结构 把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的 数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置 ###(3) 数据的运算 3 常见的时间复杂度所耗时间的大小排列 4 算法的基本概念算法是解决某个特定问题的一种方法或一个过程，是由若干条指令组成的有穷序列 5 算法评价(1) 五大特性有穷性、确定性、可行性、输入、输出 (2) 算法设计要求正确性、可读性、健壮性、时间与空间效率 6 算法分析(1) 时间复杂度(2) 空间复杂度(3) 大 O 表示法O(k 层 for 循环) = O(nk) O(while) = O(log2n) 7 辨析(1) 数据 vs 信息 信息指含有一定含义的数据，或者说我们人类可以直接理解的内容 数据则常指信息的载体，把信息进行转化以便于保存和处理 (2) 程序 vs 软件 软件是由程序组成的，他是属于看的见的东西；程序是一些数字信息，是看不见的 程序文件（.exe、.dll 等类型文件）是一种可执行的文件；而软件是让我们通过他去支配电脑做事情 (3) 数值计算 vs 非数值计算 数值型数据指直接使用自然数或度量衡单位进行计量的具体的数值 非数值数据处理对象是(如文字、图像、声音等)的计算机应用领域。如模式识别、情报检索、人工智能、数学定理证明、语言翻译、计算机辅助教学等 (4) 结构化数据 vs 非结构化数据 结构化数据即行数据,存储在数据库里,可以用二维表结构来逻辑表达实现的数据 非结构化数据即不方便用数据库二维逻辑表来表现的数据，包括所有格式的办公文档、文本、图片、XML、HTML、各类报表、图像和音频/视频信息等等","categories":[],"tags":[]},{"title":"【数据结构】第三章 栈和队列","slug":"yuque/【数据结构】第三章 栈和队列","date":"2020-04-05T00:52:16.000Z","updated":"2020-06-07T13:19:55.636Z","comments":true,"path":"2020/04/05/yuque/【数据结构】第三章 栈和队列/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【数据结构】第三章 栈和队列/","excerpt":"","text":"title: 【数据结构】第三章 栈和队列 date: 2019 年 04 月 08 日 00:27:43categories: DataStructtypora-root-url: ..typora-copy-images-to: ../images 1 栈的概念 栈：限定仅在表尾进行插入和删除操作的线性表，后进先出的线性表，简称 LIFO 结构 栈顶：表尾，允许插入和删除的一端 栈底：表头，不允许插入和删除的一端 空栈：不含任何数据元素的栈 2 栈的顺序存储结构(1) 结构代码123456typedef int SElemTypetypedef struct&#123; SElemType data[MAXSIZE]; int top;&#125;SqStack; (2) 属性从最底端 0 开始 (3) 操作A 插入 push：进栈123456789int Push(SqStack *S,SElemType e)&#123; if(S-&gt;top==MAXSIZE-1)&#123; //栈满 return 0; &#125; S-&gt;top++; //栈顶指针增加 S-&gt;data[S-&gt;top]=e; //将新插入元素赋值给栈顶空间 return 1;&#125; B 删除 pop：出栈123456789int Pop(SqStack *S,SElemType *e)&#123; if(S-&gt;top==-1)&#123; return 0; &#125; *e=S-&gt;data[S-&gt;top]; //将要删除的栈顶元素赋值给e S-&gt;top--; //栈顶指针减1 return 1;&#125; C 进栈出栈有多种情况，只要保证是栈顶元素出栈就可以3 栈的链式存储结构(1) 结构代码1234567891011typedef struct StackNode&#123; SElemType data; struct StackNode *next;&#125;StackNode,*LinkStackPtr;typedef struct LinkStack&#123; LinkStackPtr top; int count;&#125;LinkStack; (2) 操作A 插入 push：进栈123456789Status Push(LinkStack *S,SElemType e)&#123; LinkStackPtr p=(LinkStackPtr)malloc(sizeof(StackNode)); p-&gt;data=e; p-&gt;next=S-&gt;top; //把当前的栈顶元素赋值给新结点的直接后继 S-&gt;top=p; //将新的结点s赋值给栈顶指针 S-&gt;count++; return OK;&#125; 1234567891011121314151617181920B 删除pop：出栈 Status Pop(LinkStack *S,SElemType *e) &#123; LinkStackPtr p; if(StackEmpty(*S))&#123; return ERROR; &#125; *e=S-&gt;top-&gt;data; p=S-&gt;top; //将栈顶结点赋值给p S-&gt;top=S-&gt;top-&gt;next; //使得栈顶指针下移一位，指向后一结点 free(p); //释放结点p S-&gt;count--; return OK; &#125;C 判断栈为空 int empty_LinkStack(LinkStack* top) &#123; if（top==null） return 1; else return 0; &#125; *4 两栈共享空间 (1) 定义 一个栈增加，一个栈缩短，当 top1+top2==top2 时栈满 123456789101112131415161718192021222324252627282930313233343536373839(2) 结构代码 typedef struck &#123; SElemType data[MAXSIZE]; int top1; int top2; &#125;SqDoubleStack;(3) 操作 A 插入push：进栈 Status Push(SqDoubleStack *S,SElemType e,int stackNumber) &#123; if(S-&gt;top1+1==S-&gt;top2)&#123; //栈已满，不能再push新元素了 return ERROR; &#125; if(stackNumber==1)&#123; //栈 1 有元素进栈 S-&gt;data[++S-&gt;top1]=e; //若是栈1则先top1+1后给数组元素赋值 &#125; else if(stackNumber==2)&#123; //栈2有元素进栈 S-&gt;data[--S-&gt;top2]=e; //若是栈2则先top2-1后给数组元素赋值 &#125; return OK; &#125; B 删除pop：出栈 Status Pop(SqDoubleStack *S,SElemType *e,int stackNumber) &#123; if(stackNumber==1)&#123; if(S-&gt;top1==-1)&#123; return ERROR; //说明栈1已经是空栈，溢出 &#125; *e=S-&gt;data[S-&gt;top1--]; //将栈1的栈顶元素出栈 &#125; else if(stackNumber==2)&#123; if(S-&gt;top2==MAXSIZE)&#123; return ERROR; //说明栈2已经是空栈，溢出 &#125; *e=S-&gt;data[S-&gt;top2++]; //将栈 2 的栈顶元素出栈 &#125; return OK; &#125; 5 栈的应用 (1) 递归 递归函数：一个直接调用自己或通过一系列的调用语句间接地调用自己的函数 (2) 将中缀表达式转化为后缀表达式 A 规则 l 从左到右遍历中缀表达式的每个数字和符号，若是数字就输出，成为后缀表达式的一部分 l 若是符号，则判断其与栈顶符号的优先级，乘除优先加减 l 遇到(，将其入栈 l 遇到)，将栈元素弹出，输出直到遇到(为止。只弹出并不输出 l 遇到任何其他的操作符，从栈中弹出所有比待压入元素优先级高的元素直到遇到更低优先级的元素(或者栈为空)(优先级相等也要弹出)为止 l 弹出完这些元素后，才将遇到的操作符压入到栈中。只有在遇到)的情况下我们才弹出(，其他情况我们都不会弹出( l 读到了输入的末尾，则将栈中所有元素依次弹出 B 流程 l 中缀表达式 9+(3-1)×3+10÷2 转化为后缀表达式 9 3 1 - 3 * + 10 2 / + l 初始化一空栈，用来对符号进行出栈使用 1234567891011121314151617181920212223242526272829303132 l 第一个字符是数字9，输出9，后面是符号+，进栈 l 第三个字符是(，依然是符号，因其只是左括号，还未配对，故进栈 l 第四个字符是数字3，输出，总表达式为9 3，接着是-，进栈 l 接下来是数字1，输出，总表达式为9 3 1，后面是符号)，此时，我们需要去匹配此前的(，所以栈顶依次出栈，并输出，直到(出栈为止。此时左括号上方只有-，因此输出-。总的输出表达式为9 3 1 - l 接着是数字3，输出，总的表达式为9 3 1 - 3。紧接着是符号×，因为此时的栈顶符号为+号，优先级低于×，因此不输出，*进栈 l 之后是符号+，此时当前栈顶元素比这个+的优先级高，因此栈中元素出栈并输出（没有比+更低的优先级，所以全部出栈），总输出表达式为9 3 1 - 3 * +。然后将当前这个符号+进栈。也就是说，前6张图的栈底的+是指中缀表达式中开头的9后面那个+，而图中的栈底（也是栈顶）的+是指9+(3一1)×3+中的最后一个+ l 紧接着数字10，输出，总表达式变为9 3 1 - 3 * + 10。后是符号÷，所以/进栈 l 最后一个数字2，输出，总的表达式为9 3 1 - 3 * + 10 2 l 因已经到最后，所以将栈中符号全部出栈并输出。最终输出的后缀表达式结果为9 3 1 - 3 * + 10 2 / +(3) 将后缀表达式进行运算得出结果 A 规则 从左到右遍历表达式的每个数字和符号，遇到是数字就进栈，遇到是符号，就将处于栈顶两个数字出栈，进行运算，运算结果进栈，一直到最终获得结果 B 流程 l 计算后缀表达式9 3 1 - 3 * + 10 2 / + l 初始化一个空栈。此栈用来对要运算的数字进出使用 l 后缀表达式中前三个都是数字，所以9 3 1进栈 l 接下来是-，所以将栈中的1出栈作为减数，3出栈作为被减数，并运算3-1得到2，再将2进栈 l 接着是数字3进栈 l 后面是*，也就意味着栈中3和2出栈，2与3相乘，得到6，并将6进栈 l 下面是+，所以栈中6和9出栈，9与6相加，得到15，将15进栈 l 接着是10与2两数字进栈 l 接下来是符号/，因此，栈顶的2与10出栈，10与2相除，得到5，将5进栈 l 最后一个是符号+，所以15与5出栈并相加，得到20，将20进栈 l 结果是20出栈，栈变为空 6 队列的概念 l 只允许在一端进行插入操作，而在另一端进行删除操作的线性表 l 队头：允许删除的一端 l 队尾：允许插入的一端 l 先进先出 7 队列的顺序结构 (1) 定义 l front 指针指向队头元素，rear 指针指向队尾元素的下一个位置，当 front=rear 时，成为空队列 l 为了防止假溢出，我们将队列收尾相接，形成一种特殊的顺序结构——循环队列 l 队列的最大尺寸为 QueueSize l 队列满的条件：(rear+1)%QueueSize==front l 计算队列长度的公式：(rear-front+QueueSize)%QueueSize (2) 结构代码 typedef int QElemType; /_ QElemType 类型根据实际情况而定，这里假设为 int _/ /_ 循环队列的顺序存储结构 _/ typedef struct { QElemType data[MAXSIZE]; int front; /_ 头指针 _/ int rear; /_ 尾指针，若队列不空，指向队列尾元素的下一个位置 _/ } *SqQueue; (3) 操作 A 初始化 /_ 初始化一个空队列 Q _/ int InitQueue(SqQueue *Q) { Q-&gt;front=0; Q-&gt;rear=0; return 1; } B 求队列长度 int QueueLength(SqQueue Q) { return (Q.rear-Q.front+MAXSIZE)%MAXSIZE; } C 入队 int EnQueue(SqQueue Q,QElemType e) { if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front){ //队列满的判断 return 0; } Q-&gt;data[Q-&gt;rear]=e; //将元素 e 赋值给队尾 Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE; //rear 指针向后移一位置 //若到最后则转到数组头部 return 1; } D 出队 int DeQueue(SqQueue Q,QElemType e) { if (Q-&gt;front == Q-&gt;rear){ //队列空的判断 return 0; } e=Q-&gt;data[Q-&gt;front]; //将队头元素赋值给 e Q-&gt;front=(Q-&gt;front+1)%MAXSIZE; //front 指针向后移一位置 //若到最后则转到数组头部 return 1; } 8 队列的链式结构 (1) 定义 队头指针指向链队列的头结点，队尾指针指向终端结点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546(2) 结构代码 typedef int QElemType; //QElemType 类型根据实际情况而定，这里假设为int typedef struct QNode //结点结构 &#123; QElemType data; struct QNode *next; &#125;QNode,*QueuePtr; typedef struct //队列的链表结构 &#123; QueuePtr front,rear; //队头、队尾指针 &#125; *LinkQueue;*(3) 操作 A 入队 /*插入元素e为Q的新的队尾元素*/ int EnQueue(LinkQueue Q,QElemType e) &#123; QueuePtr s=(QueuePtr)malloc(sizeof(QNode)); if(!s)&#123; //存储分配失败 exit(-1); &#125; s-&gt;data=e; s-&gt;next=NULL; Q-&gt;rear-&gt;next=s; //把拥有元素e的新结点s赋值给原队尾结点的后继 Q-&gt;rear=s; //把当前的s设置为队尾结点，rear指向s return 1; &#125; B 出队 int DeQueue(LinkQueue Q,QElemType e) &#123; QueuePtr p; if(Q-&gt;front==Q-&gt;rear)&#123; return ERROR; &#125; p=Q-&gt;front-&gt;next; //将欲删除的队头结点暂存给p e=p-&gt;data; //将欲删除的队头结点的值赋值给e Q-&gt;front-&gt;next=p-&gt;next; //将原队头结点的后继p-&gt;next赋值给头结点后继 if(Q-&gt;rear==p)&#123; //若队头就是队尾，则删除后将rear指向头结点 Q-&gt;rear=Q-&gt;front; &#125; free(p); return 1; &#125; 9 队列的应用 l 汽车加油站 l 模拟打印机缓冲区","categories":[],"tags":[]},{"title":"【数据结构】第二章 线性表","slug":"yuque/【数据结构】第二章 线性表","date":"2020-04-05T00:52:11.000Z","updated":"2020-06-07T13:19:55.674Z","comments":true,"path":"2020/04/05/yuque/【数据结构】第二章 线性表/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【数据结构】第二章 线性表/","excerpt":"","text":"title: 【数据结构】第二章 线性表 date: 2019 年 04 月 08 日 00:27:43categories: DataStructtypora-root-url: ../../typora-copy-images-to: ../../images 1 线性表的概念(1) 定义零个或多个数据元素的有限序列 (2) 属性 有序性：元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继 有限性：线性表元素的个数 n（n≥0）定义为线性表的长度，当 n=0 时，称为空表 同类型 2 线性表的抽象数据类型ADT 线性表(List) 1234567891011DataOperation InitList(*L) 初始化操作，建立一个空的线性表L。 LIstEmpty(L) 若线性表为空，返回true，否则返回false。 ClearList(*L) 将线性表清空。 GetElem(L,i,*e) 在线性表L中的第i个位置元素值返回给e。 LocateElem(L,e) 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中序号表示成功；否则，返回0表示失败。 ListInsert(*L,i,*e) 在线性表L中的第i个位置插入新元素e。 ListDelete(*L,i,*e) 删除线性表L中第i个位置元素，并用e返回其值。 ListLength(L) 返回线性表L的元素个数。endADT 3 线性表的顺序存储结构(1) 定义 是用一段地址连续的存储单元依次存储线性表的数据元素 通过占位的形式，把一定内存空间给占了，然后把相同数据类型的数据元素依次存放在这块空地中。用一维数组来实现顺序存储结构，即把第一个数据元素存到数组下标为 0 的位置中，接着把线性表相邻的元素存储在数组中相邻的位置 为了建立一个线性表，要在内存中找一块地，于是这块地的第一个位置就非常关键，它是存储空间的起始位置 (2) 三个属性 存储空间的起始位置：数组 data，它的存储位置就是存储空间的存储位置 线性表的最大存储容量：数组长度 MaxSize 线性表的当前长度：length 线性表的长度是线性表中数据元素的个数，在任意时刻，线性表的长度 ≤ 数组的长度 (3) 结构代码1234567#define MAXSIZE 20 //存储空间初始分配量typedef int ElemType; //ElementType类型根据实际情况而定，这里假设为inttypedef struct&#123; ElemType data[MAXSIZE]; //数组存储数据元素，最大值是MAXSIZE int length; //线性表当前长度&#125; *SqList; (4) 操作A 初始化顺序结构123456int InitList(SqList *L)&#123; (*L)=(SqList)malloc(sizeof(SqList)); (*L)-&gt;length=0; //空表长度为0 return 1;&#125; B 插入 1234567891011121314151617int ListInsert(SqList L,int i,ElemType e)&#123; int k; if(L-&gt;length==MAXSIZE)&#123; //顺序线性表已满 return 0; &#125; if(i&lt;1 || i&gt;L-&gt;length+1)&#123; //当i不在范围内时 return 0; &#125; if(i&lt;=L-&gt;length)&#123;//若插入数据位置不在表尾 for(k=L-&gt;length-1;k&gt;=i-1;k--)&#123; //将要插入位置后数据元素向后移动一位 L-&gt;data[k+1]=L-&gt;data[k]; &#125; &#125; L-&gt;data[i-1]=e; //新元素插入 L-&gt;length++; //表长+1 return 1;&#125; C 删除 1234567891011121314151617int ListDelete(SqList L,int i,ElemType e)&#123; int k; if(L-&gt;length==0)&#123; //线性表为空 return 0; &#125; if(i&lt;1 || i&gt;L-&gt;length)&#123; //删除位置不正确 return 0; &#125; e=L-&gt;data[i-1]; if(i&lt;L-&gt;length)&#123; //如果删除不是最后位置 for(k=i;k&lt;L-&gt;length;k++)&#123; //将删除位置后继元素前移 L-&gt;data[k-1]=L-&gt;data[k]; &#125; &#125; L-&gt;length--; //表长-1 return 1;&#125; D 获得元素1234567int GetElem(SqList L,int i,ElemType e)&#123; if(L-&gt;length==0 || i&lt;1 || i&gt;L-&gt;length)&#123; return 0; &#125; e=L-&gt;data[i-1]; return 1;&#125; E 打印元素12345678int ListTraverse(SqList L)&#123; int i; for(i=1;i&lt;=L-&gt;length;i++)&#123; printf(\"位置：%d，元素：%d\\n\",i,L-&gt;data[i-1]); &#125; return 1;&#125; (5) 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 20 //存储空间初始分配量typedef int ElemType; //ElementType类型根据实际情况而定，这里假设为inttypedef struct&#123; ElemType data[MAXSIZE]; //数组存储数据元素，最大值是MAXSIZE int length; //线性表当前长度&#125; *SqList; /*初始化顺序结构*/ int InitList(SqList *L) &#123; (*L)=(SqList)malloc(sizeof(SqList)); (*L)-&gt;length=0; //空表长度为0 return 1; &#125; /*插入元素*/ int ListInsert(SqList L,int i,ElemType e)&#123; int k; if(L-&gt;length==MAXSIZE)&#123; //顺序线性表已满 return 0; &#125; if(i&lt;1 || i&gt;L-&gt;length+1)&#123; //当i不在范围内时 return 0; &#125; if(i&lt;=L-&gt;length)&#123;//若插入数据位置不在表尾 for(k=L-&gt;length-1;k&gt;=i-1;k--)&#123; //将要插入位置后数据元素向后移动一位 L-&gt;data[k+1]=L-&gt;data[k]; &#125; &#125; L-&gt;data[i-1]=e; //新元素插入 L-&gt;length++; //表长+1 return 1; &#125; /*删除元素*/ int ListDelete(SqList L,int i)&#123; int k; if(L-&gt;length==0)&#123; //线性表为空 return 0; &#125; if(i&lt;1 || i&gt;L-&gt;length)&#123; //删除位置不正确 return 0; &#125; if(i&lt;L-&gt;length)&#123; //如果删除不是最后位置 for(k=i;k&lt;L-&gt;length;k++)&#123; //将删除位置后继元素前移 L-&gt;data[k-1]=L-&gt;data[k]; &#125; &#125; L-&gt;length--; //表长-1 return 1; &#125; /*获得元素*/ int GetElem(SqList L,int i)&#123; if(L-&gt;length==0 || i&lt;1 || i&gt;L-&gt;length)&#123; return 0; &#125; printf(\"%d\\n\",L-&gt;data[i-1]); return 1; &#125;/*打印顺序结构*/int ListTraverse(SqList L)&#123; int i,len; len=L-&gt;length; for(i=1;i&lt;=len;i++)&#123; printf(\"位置：%d，元素：%d\\n\",i,L-&gt;data[i-1]); &#125; return 1;&#125;int main(void)&#123; SqList L; InitList(&amp;L); ListInsert(L,1,1); ListInsert(L,2,2); ListTraverse(L); GetElem(L,2); ListDelete(L,2); ListTraverse(L); return 0;&#125; 4 线性表的链式存储结构(1) 定义 A 头指针 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针 无论链表是否为空，头指针均不为空 头指针是链表的必要元素 B 头结点 头结点是为了操作的统一和方便而设立的，放在第一元素的结点之前，其数据域一般无意义（也可存放链表的长度） 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其它结点的操作就统一了 头结点不一定是链表必须要素 无头结点访问a：head 有头结点访问`a：head -&gt; next (2) 结构代码123456typedef int ElemType;typedef struct Node&#123; ElemType data; struct Node *next;&#125; Node;typedef struct Node *LinkList; (3) 操作A 初始化链式结构123456int InitList(LinkList *L)&#123; (*L)=(LinkList)malloc(sizeof(Node)); (*L)-&gt;next=NULL; return 1;&#125; B 插入123456789101112131415161718int ListInsert(LinkList L,int i,ElemType e)&#123; int j = 1; LinkList p,s; p=L; while (p &amp;&amp; j&lt;i)&#123; //寻找第i结点 p=p-&gt;next; ++j; &#125; if(!p || j&gt;i)&#123; return 0; //第i个元素不存在 &#125; s=(LinkList)malloc(sizeof(Node)); //生成新结点(C语言标准函数) s-&gt;data=e; //结构体即scanf s-&gt;next=p-&gt;next; //将p的后继结点赋值给s的后继 p-&gt;next=s; //将s赋值给p的后继 return 1;&#125; C 删除123456789101112131415161718int ListDelete(LinkList L,int i,ElemType e)&#123; int j = 1; LinkList p,q; p=L; while(p-&gt;next &amp;&amp; j&lt;i)&#123; //历寻找第i个元素 p=p-&gt;next; ++j; &#125; if (!(p-&gt;next) || j&gt;i)&#123; return 0; //第i个元素不存在 &#125; q=p-&gt;next; p-&gt;next=q-&gt;next; //将q的后继赋值给p的后继 e=q-&gt;data; //将q结点中的数据给e free(q); //让系统回收此结点，释放内存 return 1;&#125; D 获得元素第一部分遍历查找第 i 个结点；第二部分插入和删除结点 1234567891011121314int GetElem(LinkList L,int i,ElemType e)&#123; int j = 2; //j为计数器 LinkList p; //声明一结点p p=L-&gt;next; //让p指向链表L的第一个结点 while(p &amp;&amp; j&lt;i)&#123; //p不为空或者计数器j还没有等于i时，循环继续 p=p-&gt;next; //让p指向下一个结点 ++j; &#125; if(!p || j&gt;i)&#123; return 0; //第i个元素不存在 &#125; e=p-&gt;data; //取第i个元素的数据 return 1;&#125; E 整表删除123456789101112int ClearList(LinkList L)&#123; LinkList p,q; p=L-&gt;next; //p指向第一个结点 while(p)&#123; //没到表尾 q=p-&gt;next; free(p); p=q; &#125; L-&gt;next=NULL; //头结点指针域为空 return 1;&#125; F 打印元素只有初始化的时候函数是带*的 12345678910111213int ListTraverse(LinkList L)&#123; LinkList e; e=L; if(e-&gt;next==NULL)&#123; return 0; &#125; else&#123; while(e-&gt;next!=NULL)&#123; printf(\"%d\",e-&gt;next-&gt;data); e=e-&gt;next; &#125; return 1; &#125;&#125; (4) 实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;/*定义元素类型*/typedef struct&#123; char name[20]; char press[20]; char writer[20]; char date[15]; double money;&#125;Book;typedef Book ElemType;/*定义链表结构*/typedef struct Node&#123; ElemType data; struct Node *next;&#125; Node;typedef struct Node *LinkList;/*初始化链表*/int InitList(LinkList *L)&#123; *L=(LinkList)malloc(sizeof(Node)); (*L)-&gt;next=NULL; return 1;&#125;/*借书*/int ListDelete(LinkList L,char find[])&#123; int j; LinkList p,q; p=L; j=1; int a=0; if(p-&gt;next==NULL)&#123; printf(\"\\n对不起，图书馆暂无图书，请先添加！\\n\"); return 0; &#125; else&#123; while(p!=NULL)&#123; if(strcmp(p-&gt;next-&gt;data.name,find)==0)&#123; q=p-&gt;next; p-&gt;next=q-&gt;next; free(q); printf(\"\\n删除%s成功!\\n\",find); a=1; break; &#125; p=p-&gt;next; &#125; &#125; if(a==0) printf(\"\\n输入的书名有误，删除失败！\\n\");&#125;/*添书、还书*/int ListInsert(LinkList L,int i)&#123; int j; LinkList p,s; p=L; j=1; while (p &amp;&amp; j&lt;i)&#123; //寻找第i结点 p=p-&gt;next; ++j; &#125; if(!p || j&gt;i)&#123; return 0; //第i个元素不存在 &#125; s=(LinkList)malloc(sizeof(Node)); //生成新结点(C语言标准函数) printf(\"\\n请输入书名：\"); scanf(\"%s\",s-&gt;data.name); printf(\"\\n请输入作者：\"); scanf(\"%s\",s-&gt;data.writer); printf(\"\\n请输入出版社：\"); scanf(\"%s\",s-&gt;data.press); printf(\"\\n请输入日期：\"); scanf(\"%s\",s-&gt;data.date); printf(\"\\n请输入价格：\"); scanf(\"%lf\",&amp;s-&gt;data.money); s-&gt;next=p-&gt;next; //将p的后继结点赋值给s的后继 p-&gt;next=s; //将s赋值给p的后继 return 1;&#125;/*查书*/int findbook(LinkList L)&#123; LinkList e; int key; int sign=0; char find[20]; e=L; printf(\"\\n请选择你要查询的关键词种类：1、书名 2、作者 3、出版社 4、日期\\n\"); scanf(\"%d\",&amp;key); switch(key)&#123; case 1: printf(\"\\n请输入您要查询的书名：\"); scanf(\"%s\",find); while(e-&gt;next!=NULL)&#123; if(strcmp(e-&gt;next-&gt;data.name,find)==0)&#123; printf(\"\\n符合条件书的信息：\\n书名：%s 作者：%s 出版社：%s 日期：%s 价格：%.2lf\\n\",e-&gt;next-&gt;data.name,e-&gt;next-&gt;data.writer,e-&gt;next-&gt;data.press,e-&gt;next-&gt;data.date,e-&gt;next-&gt;data.money); sign=1; &#125; e=e-&gt;next; &#125; break; case 2: printf(\"请输入您要查询的作者：\"); scanf(\"%s\",find); while(e-&gt;next!=NULL)&#123; if(strcmp(e-&gt;next-&gt;data.writer,find)==0)&#123; printf(\"\\n符合条件书的信息：\\n书名：%s 作者：%s 出版社：%s 日期：%s 价格：%.2lf\\n\",e-&gt;next-&gt;data.name,e-&gt;next-&gt;data.writer,e-&gt;next-&gt;data.press,e-&gt;next-&gt;data.date,e-&gt;next-&gt;data.money); sign=1; &#125; e=e-&gt;next; &#125; break; case 3: printf(\"\\n请输入您要查询的出版社：\"); scanf(\"%s\",find); while(e-&gt;next!=NULL)&#123; if(strcmp(e-&gt;next-&gt;data.press,find)==0)&#123; printf(\"\\n符合条件书的信息：\\n书名：%s 作者：%s 出版社：%s 日期：%s 价格：%.2lf\\n\",e-&gt;next-&gt;data.name,e-&gt;next-&gt;data.writer,e-&gt;next-&gt;data.press,e-&gt;next-&gt;data.date,e-&gt;next-&gt;data.money); &#125; e=e-&gt;next; &#125; break; case 4: printf(\"\\n请输入您要查询的类日期：\"); scanf(\"%s\",find); while(e-&gt;next!=NULL)&#123; if(strcmp(e-&gt;next-&gt;data.date,find)==0)&#123; printf(\"\\n符合条件书的信息：\\n书名：%s 作者：%s 出版社：%s 日期：%s 价格：%.2lf\\n\",e-&gt;next-&gt;data.name,e-&gt;next-&gt;data.writer,e-&gt;next-&gt;data.press,e-&gt;next-&gt;data.date,e-&gt;next-&gt;data.money); sign=1; &#125; e=e-&gt;next; &#125; break; &#125; return sign;&#125;/*显示*/int ListTraverse(LinkList L)&#123; LinkList e; int i=1; e=L; if(e-&gt;next==NULL)&#123; return 0; &#125; else&#123; while(e-&gt;next!=NULL)&#123; printf(\"\\n第%d本书的信息：\\n书名：%s\\t\\t作者：%s\\t\\t出版社：%s\\t\\t日期：%s\\t\\t价格：%.2lf\\n\\n\",i,e-&gt;next-&gt;data.name,e-&gt;next-&gt;data.writer,e-&gt;next-&gt;data.press,e-&gt;next-&gt;data.date,e-&gt;next-&gt;data.money); e=e-&gt;next; i++; &#125; return 1; &#125;&#125;int main(void)&#123; /*构造线性表 */ LinkList books; InitList(&amp;books); int n,insert,loc,sign; char key[20]; do&#123; printf(\"\\n--------------------------------ZUST图书管理系统欢迎您-----------------------------------\\n\"); printf(\"\\n请选择功能：\\n\\n0、添加图书\\t1、查询图书\\t2、删除图书\\t3、所有图书\\t4、退出\\n\\n请输入您要进行的操作：\"); scanf(\"%d\",&amp;n); printf(\"\\n-----------------------------------------------------------------------------------------\\n\"); switch(n)&#123; case 0: printf(\"\\n请输入您要添加书的位置:\"); scanf(\"%d\",&amp;loc); insert=ListInsert(books,loc); if(insert==0) printf(\"\\n位置输入有误，添加失败！\\n\"); break; case 1: sign=findbook(books); if(sign==0) printf(\"\\n对不起，图书馆暂无此书！\\n\"); break; case 2: printf(\"\\n请输入您要删除的图书书名：\"); scanf(\"%s\",key); ListDelete(books,key); break; case 3 : ListTraverse(books); break; &#125; &#125;while(n!=4); printf(\"\\n图书管理系统已退出！\\n\"); return 0;&#125; 5 循环链表(1) 定义 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，行成头尾相接的单链表 其实循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p-&gt;next是否为空，现在则是p-&gt;next不等于头结点，则循环未结束 (2) 双向链表A 结构代码123456typedef struct DulNode&#123; ElemType data; struct DulNode *prior; struct DulNode *next;&#125; DulNode,*DuLinkList; *B 操作插入1234s-&gt;prior=p; //S的前驱s-&gt;next=p-&gt;next; //S的后继p-&gt;next=prior=s; //后结点的前驱p-&gt;next=s; //后结点的后继 删除123p-&gt;prior-&gt;next=p-&gt;next; //前结点的后继p-&gt;next-&gt;prior=p-&gt;prior; //后结点的前驱free(p); 6 单链表结构与顺序存储结构优缺点 顺序存储结构：频繁查找，很少插入和删除；知道线性表的大致长度 单链表结构：频繁插入和删除，很少查找；当元素个数变化较大或者根本不知道有多大 7 线性表的关系","categories":[],"tags":[]},{"title":"【面经】别人的阿里新零售事业部一面","slug":"yuque/【面经】别人的阿里新零售事业部一面","date":"2020-04-05T00:52:06.000Z","updated":"2020-06-07T13:19:55.710Z","comments":true,"path":"2020/04/05/yuque/【面经】别人的阿里新零售事业部一面/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【面经】别人的阿里新零售事业部一面/","excerpt":"","text":"title: 【面经】别人的阿里新零售事业部一面 date: 2019 年 04 月 08 日 00:27:43categories: Careertypora-root-url: ..typora-copy-images-to: ../images 从项目展开 HTML 单页面应用怎么做 ✅ 是什么 只有一张 Web 页面的应用 在用户操作过程中，浏览器始终不会重载整个页面 公共资源（JS、CSS 等）仅需加载一次 单页面跳转仅刷新局部资源 从 Web 服务器加载的富客户端 目的 减少服务器压力，否则每次都要向服务器发送请求，服务器返回 HTML 文件 增强用户体验，使用起来十分流畅 但是 首次加载数据大，耗时长 不利于 SEO 优化，可用 SSR 优化 导航需要人为处理 如何达成 iframe，目前浏览器都已经对 iframe url 发生修改产生历史记录，但是 iframe 的响应式兼容不好，不过 iframe 与父文档独立，不受父文档影响，所有 QQ 邮箱等还是继续使用 iframe Ajax + div + history，通过 history 提供的 API 实现历史记录的管理，十分方便，Vue-router 默认是 hash，但是可以手动修改成 history 或 abstract 组合 SUI Mobile CSS 布局 ✅ JS 除了 setTimeout 和 setInterval，还有一个适合用于动画的计时器，你知道吗？ ✅ requestAnimationFrame 专门为实现高性能的帧动画而设计的 API，但是不能指定延迟时间，而是根据浏览器的刷新频率而定（帧）。 如果你想做逐帧动画的时候，你应该用这个方法。这就要求你的动画函数执行会先于浏览器重绘动作。 通常来说，被调用的频率是每秒 60 次，但是一般会遵循 W3C 标准规定的频率。 1var requestId = window.requestAnimationFrame(func); Browser 与后台交互除了 Ajax 还有什么异步方式 ✅ web socket WebSocket.send(data) 向服务器发送数据 WebSocket.close([code[, reason]]) 关闭当前链接 123456789101112// Create WebSocket connection.const socket = new WebSocket(\"ws://localhost:8080\");// Connection openedsocket.addEventListener(\"open\", function (event) &#123; socket.send(\"Hello Server!\");&#125;);// Listen for messagessocket.addEventListener(\"message\", function (event) &#123; console.log(\"Message from server \", event.data);&#125;); MVC MVVM 登陆信息怎么保存 ✅ sessionStorage 后台是怎么用 session 保持的，为什么不用 cookie？✅ 每次 cookie 会自动把 sessionID 传到后端，后端通过 sessionID 获取 session 数据 看网上说现在 cookie 一般不建议用于存储，如果没有大量数据存储需求的话可以使用localStorage 或 sessionStorage，不怎么变的数据使用 localStorage，否则可以使用 sessionStorage，cookie 不光存储空间小，它只有 4k，其它的有 5M，而且他还需要和服务端通信，每次都要携带在 header 中，影响请求性能，而且还会涉及到一些安全性的问题，不过可以通过它的几个属性加以限制，value 不能明文，http-only-&gt;XSS，same-site-&gt;CSRF，secure-&gt;HTTPS 才能携带 cookie，localstorage 中有 BUG 有哪些客户端保存方案 cookie localStorage sessionStorage indexedDB Network 知道几种状态码 Career 你是怎么学习的？ 项目驱动式学习 Framework Vue 有了解过吗？双向绑定的底层实现是怎样的？ Project 批注如果 1 篇文章有 10w 字怎么解决？ 分页 懒加载 懒加载 怎么实现？ 文本 图片 滚动监听 怎么监听 怎么判断什么时候加载 滚动距离 3. 项目技术实现 4. 项目管理 for me","categories":[],"tags":[]},{"title":"【面经】阿里巴巴","slug":"yuque/【面经】阿里巴巴","date":"2020-04-05T00:52:01.000Z","updated":"2020-06-07T13:19:55.838Z","comments":true,"path":"2020/04/05/yuque/【面经】阿里巴巴/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【面经】阿里巴巴/","excerpt":"","text":"title: 【面经】阿里巴巴date: 2019年04月08日 00:27:43categories: Careertypora-root-url: ..typora-copy-images-to: ../images 一面（电话+在线编程） 对象是一个嵌套结构的，需要把对象抹平，然后从最深处开始输出。这个题当时给定了一个方法的调用形式，包含了函数参数。然后完成这个flatten函数 思想是递归实现 自我介绍 讲话可以稍微低沉一些，语速可以降低，这样显的自信 不做害羞的动作，例如不自觉的玩手指，不敢与面试官眼神交流，眼睛四眼无神等 抬头挺胸，目光直视hr 轮到自己发言时，眼光顺序：最左-中间-最右-中间，时间大概2-3秒，然后再大声的开始自我介绍。这样子的话全场目光都会聚焦在你身上 大家好，我叫冯天祥，来自浙江科技学院软件工程专业，今天面试的岗位为前端工程师 我曾应邀赴斯里兰卡参加境外国际学术会议并作英文报告，为 IEEE Fellow 的教授们做导游，玩遍斯里兰卡 计划了为期一月的旅游，游遍了大西北 学院我开发的 ISchool 学生事务管理系统完成了全体学生的三轮专业分流工作，一改纸质操作，避免数据录入错误，教务处工作量减少 50%，工作周期从 16 天减少至 7 天 熟练使用 JavaScript（含 ES6） HTML、CSS 开发页面进行前后端完全分离开发 使用过 Bootstrap、Framework7、layui、SUI Mobile 等 UI 框架 了解前端模块化开发及性能优化 掌握 Axure 原型工具的使用 喜欢外出，不做宅男，身体健康，乐意加班 你有做过微信小程序，主要做了些什么事情 你为什么选择前端开发 2009 年，小学四年级的我，报了一个 Frontpage 的网页制作班，在座的所有人中我最小 2010 年，小学毕业的我对平面设计产生了浓厚的兴趣。我参加了一个成人 Photoshop 学习班，坚实的知识加上我四年的水墨画功底，在那里毫不逊色 现在，学校的许多海报，logo 是由我设计制作的 刚进入高中的我接触到了 Dreamweaver 同年我接触到了淘宝客，我和朋友挑选了几个高中生的感兴趣的版块进行推广，在发现了单一营销的低效率之后，凭着自己那三脚猫功夫做出一个丑陋的单页面网站。在那之后我便开始了两个礼拜的 WordPress 学习，并通过国外一个免费的域名和空间提供商，架起了我的第一个淘宝客网站，实现了梦想，也赚得了 500 元的人生第一桶金 刚进入大一，跟着导师做项目，当时也就前端可以搭把手，但第一次接触就爱上了前端，后来自己申报国创新苗项目，也写过一段时间的 php。对于大多数人来说，在一开始做哪个方向是不一定的，只是做着做着成就感出来了，看着自己的作品给大家看见和使用，这才觉得要往这个方向深入做，由于自己的美术功底，对于页面元素及布局也有严格的要求和自己独特的想法，对色彩也有一定的敏感度，发现前端是越学习越喜欢的东西，后面越做就越进去了 前端开发的学习路径 html css Bootstrap js jQuery Vue.js js 引擎，事件循环机制 https://segmentfault.com/a/1190000012806637 JS 是单线程语言 JS 是异步执行的 JS 的事件循环(event loop)是 JS 的执行机制，通过 Event Loop 可以实现单线程并异步执行 首先判断 JS 是同步还是异步,同步就进入主线程,异步就进入 event table 异步任务在 event table 中注册函数,当满足触发条件后,被推入 event queue 同步任务进入主线程后一直执行,直到主线程空闲时,才会去 event queue 中查看是否有可执行的异步任务,如果有就推入主线程中 宏任务 script 代码 setTimeout/setInterval I/O UI 交互 setImmediate(nodejs 环境中) 微任务：一个 EL 中只有一个微任务队列 promise（promise 的 then 和 catch 才是 microtask，本身其内部的代码并不是） MutationObserver process.nextTick(nodejs 环境中) 执行 script 下的宏任务，遇到其它宏任务放置宏任务队列，遇到微任务放置微任务队列 当前宏任务执行完成后，会查看微任务的队列，并将里面全部的微任务依次执行完 执行队列中的宏任务，过程中如果遇到微任务，就将其放到微任务队列里 es6 了解吗，说下箭头函数，和普通函数的区别 https://www.jianshu.com/p/73cbeb6782a0 箭头函数作为匿名函数，是不能作为构造函数的，不能使用 new 箭头函数不绑定 arguments，取而代之用 rest 参数…解决 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值 箭头函数当方法使用的时候没有定义 this 绑定 b 是一个箭头函数，然后它的 this 是指向 window，这是为什么呢，因为箭头函数捕获的是 obj{}这个对象的环境，然后这个环境的 this 指向的是 window，就相当于上一条的例子：在 c 方法里面 return 的那个箭头函数捕获的是 c:function(){}这个环境的 this，而这个环境的 this 是 obj，这样是不是就清晰明了了 使用 call()和 apply()调用 箭头函数没有原型属性 箭头函数不能当做 Generator 函数，不能使用 yield 关键字 箭头函数不能换行 箭头函数的 this 永远指向其上下文的 this，任何方法都改变不了其指向，如 call(), bind(), apply() 普通函数的 this 指向调用它的那个对象（指向其上下文） vue 的数据双向绑定什么意思？ https://blog.csdn.net/zhang5207892/article/details/78389121 单向数据绑定：DOM 操作直接改变 数据模型（Module）和视图（View）之间的双向绑定 用户在视图上的修改会自动同步到数据模型中去，同样的，如果数据模型中的值发生了变化，也会立刻同步到视图中去 双向数据绑定的优点是无需进行和单向数据绑定的那 CRUD（Create，Retrieve，Update，Delete）操作 双向数据绑定最经常的应用场景就是表单了，这样当用户在前端页面完成输入后，不用任何操作，我们就已经拿到了用户的数据存放到数据模型中了 vue 数据双向绑定的原理？ https://juejin.im/entry/5923973da22b9d005893805a vue 数据双向绑定是通过数据劫持结合发布者-订阅者模式的方式来实现的，那么 vue 是如何进行数据劫持的，我们可以先来看一下通过控制台输出一个定义在 vue 初始化数据上的对象是个什么东西 我们可以看到属性 a 有两个相对应的 get 和 set 方法，为什么会多出这两个方法呢？因为 vue 是通过 Object.defineProperty()来实现数据劫持的。 Object.defineProperty( )可以来控制一个对象属性的一些特有操作，比如读写权、是否可以枚举，这里我们主要先来研究下它对应的两个描述属性 get 和 set 1234567891011121314var Book = &#123; name,&#125;;Object.defineProperty(Book, \"name\", &#123; set: function (value) &#123; name = value; console.log(\"你取了一个书名叫做\" + value); &#125;, get: function () &#123; return \"《\" + name + \"》\"; &#125;,&#125;);Book.name = \"冯天祥\";console.log(Book.name); // 《冯天祥》 我们通过 Object.defineProperty( )设置了对象 Book 的 name 属性，对其 get 和 set 进行重写操作 get 就是在读取 name 属性这个值触发的函数，当读取这个属性时，就会输出 “《vue 权威指南》”，因为我们在 get 函数里面对该值做了加工了 set 就是在设置 name 属性这个值触发的函数，所以当执行 Book.name = ‘vue 权威指南’ 这个语句时，控制台会打印出 “你取了一个书名叫做 vue 权威指南” 因为 view 更新 data 其实可以通过事件监听即可，比如 input 标签监听 ‘input’ 事件就可以实现了，关键点在于 data 如何更新 view 数据更新视图的重点是如何知道数据变了，只要知道数据变了，那么接下去的事都好处理。如何知道数据变了，其实上文我们已经给出答案了，就是通过 Object.defineProperty( )对属性设置一个 set 函数，当数据改变了就会来触发这个函数，所以我们只要将一些需要更新的方法放在这里面就可以实现 data 更新 view 了 实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器 Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者 Watcher 看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器 Dep 来专门收集这些订阅者，然后在监听器 Observer 和订阅者 Watcher 之间进行统一管理的。接着，我们还需要有一个指令解析器 Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者 Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者 Watcher 接收到相应属性的变化，就会执行对应的更新函数，从而更新视图 实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者 实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图 实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。 跨域的几种形式 https://www.jianshu.com/p/447fe4d86dd5 jsonp：script 标签不受同源策略的限制，在页面中动态插入了script，script 标签的 src 属性就是后端 api 接口的地址，并且以 get 的方式（不能是 post）将前端回调处理函数名称告诉后端，后端在响应请求时会将回调返还，并且将数据以参数的形式传递回去 CORS(Cross-Origin Resource Sharing)(跨域资源共享)：允许当前域（origin）的资源（比如 html/js/web service）被其他域（origin）的脚本请求访问的机制。当使用 XMLHttpRequest 发送请求时，浏览器如果发现违反了同源策略就会自动加上一个请求头：origin，后端在接受到请求后确定响应后会在 Response Headers 中加入一个属性：Access-Control-Allow-Origin，值就是发起请求的源地址(http://127.0.0.1:8888)，浏览器得到响应会进行判断 Access-Control-Allow-Origin 的值是否和当前的地址相同，只有匹配成功后才进行响应处理，会忽略 cookie 服务器跨域：在前后端分离的项目中可以借助服务器实现跨域，具体做法是：前端向本地服务器发送请求，本地服务器代替前端再向 api 服务器接口发送请求进行服务器间通信，本地服务器其实就是个中转站的角色，再将响应的数据返回给前端，现代浏览器中和移动端都支持 CORS（除了 opera mini），IE 下需要 8+ postmessage：在 HTML5 中新增了 postMessage 方法，postMessage 可以实现跨文档消息传输（Cross Document Messaging），Internet Explorer 8, Firefox 3, Opera 9, Chrome 3 和 Safari 4 都支持 postMessage。该方法可以通过绑定 window 的 message 事件来监听发送跨文档消息传输内容。使用 postMessage 实现跨域的话原理就类似于 jsonp，动态插入 iframe 标签，再从 iframe 里面拿回数据，私认为用作跨页面通信更加适合 闭包的概念？作用？问题？作用域的相关问题 事件冒泡是什么？如何阻止事件冒泡？ 还做过别的相关的吗？用过 react 吗？ css 的 position 有哪几种？默认情况？区别？ 原型链，继承 vue 组件间的通信","categories":[],"tags":[]},{"title":"【面经】2019腾讯前端实习生一面","slug":"yuque/【面经】2019腾讯前端实习生一面","date":"2020-04-05T00:51:56.000Z","updated":"2020-06-07T13:19:55.881Z","comments":true,"path":"2020/04/05/yuque/【面经】2019腾讯前端实习生一面/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【面经】2019腾讯前端实习生一面/","excerpt":"","text":"title: 【面经】2019腾讯前端实习生一面date: 2019年04月08日 00:27:43categories: Careertypora-root-url: ..typora-copy-images-to: ../images JS jQuery 事件绑定的原理 ✔️ 调用 on 函数的时候，将生成一份事件数据，并将该数据加入到元素的缓存中 12345678910&#123; type: type, origType: origType, data: data, handler: handler, guid: guid, selector: selector, needsContext: needsContext, namespace: namespace&#125; jquery 中每个元素都可以有一个缓存（只有有需要的时候才生成） 缓存就是该元素的一个属性 jquery 为每个元素的每种事件都建立一个队列，用来保存事件处理函数，所以可以对一个元素添加多个事件处理函数 123456789101112131415161718192021222324252627282930\"div#box\": &#123; //元素 \"Jquery623873\": &#123; //元素的缓存 \"events\": &#123; \"click\": [ &#123; //元素click事件的事件数据 type: type, origType: origType, data: data, handler: handler, guid: guid, selector: selector, needsContext: needsContext, namespace: namespace &#125; ], \"mousemove\": [ &#123; type: type, origType: origType, data: data, handler: handler, guid: guid, selector: selector, needsContext: needsContext, namespace: namespace &#125; ] &#125; &#125;&#125; 当要解绑事件的时候，如果没指定 fn 参数，jquery 就会从该元素的缓存里拿到要解绑的事件的处理函数队列，从里面拿出 fn 参数,然后调用removeEventListener进行解绑 数组函数是否改变原数组✔️ 用过哪些数组的 API✔️ jQuery 怎么获取 DOM 元素，DOM 怎么获取 jQuery 元素 ✔️ jQuery -&gt; DOM 使用数组索引方式访问 1var dom = $(dom)[0]; 使用函数get()访问，get()函数中的参数为索引号 1var dom = $(dom).get(0); DOM -&gt; jQuery 对于已经是一个 DOM 对象，只需要用$()把 DOM 对象包装起来，就可以获得一个 jQuery 对象了 12var v = document.getElementById(\"v\"); //DOM对象var $v = $(v); //jQuery对象 深浅拷贝 ✔️ 如何判断数据类型？除了使用 typeof instanceof 之外怎么判断？✔️ 123function isArray(arr) &#123; return Object.prototype.toString.call(arr) === \"[Object Array]\";&#125; jQuery 链式操作是怎么实现的？✔️ 1return this; new 一个对象的过程 ✔️ ES6 了解吗？ ✔️ 有没有用过组件？完全没用过 Vue 或 React？ ✔️❓ 作用域和闭包？ES6 有块级作用域！ ✔️ 事件冒泡代理 CSS CSS 动画 CSS 选择器 元素如何在页面中上下居中 知道几种盒模型？怎么计算宽度？ 浏览器 跨域 存储 DOM 增加节点 安全性 安全性问题 算法 判断字符串中是否有重复 计算字符串中重复字符的个数 如何匹配{[( 项目相关 如何实现长按批注？ 印象深刻的前端项目？","categories":[],"tags":[]},{"title":"【技术之瞳】Web前端开发学习小记及部分答案解析","slug":"yuque/【技术之瞳】Web前端开发学习小记及部分答案解析","date":"2020-04-05T00:51:51.000Z","updated":"2020-06-07T13:19:55.946Z","comments":true,"path":"2020/04/05/yuque/【技术之瞳】Web前端开发学习小记及部分答案解析/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【技术之瞳】Web前端开发学习小记及部分答案解析/","excerpt":"","text":"title: 【技术之瞳】Web 前端开发学习小记及部分答案解析 date: 2019 年 04 月 08 日 00:27:43categories: Careertypora-root-url: ..typora-copy-images-to: ../images 基础技术 HTTP HTML CSS JavaScript 编程能力 数据结构和算法 正则表达式 扩展技术 Node.js 前端框架 前端工程 数据可视化 HTTP 协议 与浏览器缓存相关的字段名 P113 习题 4.2 Expires 当客户端第一次访问一个文件资源的时候，服务端在返回资源内容的同时也返回了： Expires: Mon, 1 Aug 2016 22:43:02 GMT 也就是服务端告诉浏览器，先把这个文件缓存起来，在这个过期时间之前，该文件都不会变化了 下一次浏览器又要访问这个资源，并且访问的时间在Mon, 1 Aug 2016 22:43:02 GMT之前，那浏览器就不去服务器那边获取文件了，而是直接从缓存中取文件 Cache-Control 由于 Expires 给定的是绝对时间，而客户端的系统时间可以由用户任意修改，比如 Expires 设定的过期时间是Mon, 1 Aug 2016 22:43:02 GMT，现在用户把系统时间改为Tue, 2 Aug 2016 22:43:02 GMT，则缓存会被判为过期（虽然实际上还没到那个时间） 因此在 HTTP1.1 中引入了 Cache-Control，这就是一个相对时间，比如Cache-Control: max-age=80，那就是说这份缓存的有效期是 80 秒，而没有给定过期的绝对时间 由于 Cache-Control 是 HTTP1.1 中才有的，因此可能会有 Expires 和 Cache-Control 同时出现的情况，这时以 Cache-Control 为准 Last-Modified / If-Modified-Since 现在有另外一个问题，服务端有个文件可能会更新，因此希望客户端时不时过来问一下这个文件是否过期 如果没有过期，服务端不返回数据给浏览器，只返回304状态码，告诉浏览器目前的缓存还没有过期，然后浏览器继续使用已有缓存 这个就叫做条件请求。这里就要用到以下两个头部信息 12Last-Modified (response header)If-Modified-Since (request header) 浏览器第一次请求资源的时候，服务端返回资源内容，同时也返回了Last-Modified: Mon, 01 Aug 2016 13:48:44 GMT，也就是服务端在告诉客户端这个文件在服务器上的最后修改时间 浏览器第二次访问的时候（假设这里没有设置 Expires 或者 Cache-Control）。那么浏览器在访问资源的时候会在请求头上带上If-Modified-Since: Mon, 01 Aug 2016 13:48:44 GMT 服务端收到后对比目前文件的最后修改时间和该请求头的信息，如果没有修改，那就直接返回 304 给浏览器，而不返回实际资源。如果有变化了，就返回 200，并且带上新的资源内容 Etag / If-None-Match 条件请求还有另外一种方法——打标签，也就是使用 Etag 第一次拿到资源的时候，服务器的响应头中包含了 Etag，用来作为时间标签 下一次浏览器再次请求资源的时候会把原来的 Etag 标签带上（在请求头中变成了 If-None-Match）作为校验标准 若这个文件如果发生了改变，则 Etag 也会改变 服务器对比浏览器请求头中的的 If-None-Match 如果相同就返回 304，而不返回实际资源 如果不同，就返回 200 和新的资源 由于 Etag 需要通过服务器计算得出，每次都进行计算需要额外的开销，有时候这也是一种负担 HTTP 协议与 HTTPS 协议，分析两者的相同点与不同点 P114 习题 4.4 https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用 http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议 http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443 http 的连接很简单，是无状态的；HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全 HTML HTML5 新特性 P117 习题 4.8 https://www.cnblogs.com/greatluoluo/p/5714221.html CSS 请用 CSS 实现：在所有新窗口打开的链接右侧添加一个示意图标 P123 习题 4.11 1234a[target=\"_blank\"] &#123; padding-right: 20px; background: url(123png) no-repeat left top;&#125; 123&lt;a href=\"/index.html\"&gt;Homepage&lt;/a&gt;&lt;a href=\"http://www.alibaba.com\" target=\"_blank\"&gt;Alibaba.com&lt;/a&gt;&lt;a href=\"http://www.taobao.com\" target=\"_blank\"&gt;Taobao.com&lt;/a&gt; CSS 中用display: none可以隐藏页面元素，请另外说出 5 种或以上隐藏一个页面元素的方法 P123 习题 4.14 https://www.zcfy.cc/article/457 将 opacity 设为 0 将 visibility 设为 hidden 将 display 设为 none 将 position 设为 absolute，然后将位置设到不可见区域 使用 clip-path 属性裁剪 请阐述 CSS 实现三角形的原理 P123 习题 4.15 http://alvinwp.com/html-css/462 http://www.tashan10.com/zhong-yu-gao-dong-liao-cssshi-xian-san-jiao-xing-tu-biao-de-yuan-li/ 12345678.div3 &#123; margin-top: 20px; width: 0; height: 0; border-top: 40px solid transparent; border-left: 40px solid #ff0000; border-bottom: 40px solid transparent;&#125; border-top + border-bottom = 三角形的底 border-left = 三角形的高 JavaScript 请填入内容，使得数组从小到大排序。 P130 习题 4.17 123&gt; var arr = [6, 2, 10, 5, 9, 5];&gt; arr.sort(_______);&gt; 123456789101112131415- 数组调用sort方法后，会影响本身（而非生成新数组）- `sort()`方法默认是按字符来排序的，所以在对数字型数组排序时，不可想当然的以为会按数字大小排序- 要改变默认的sort行为（即按字符排序），可以自行指定排序规则函数```javascriptvar arr = [6, 2, 10, 5, 9, 5];arr.sort(); // 调用sort方法后，数组本身会被改变，即影响原数组console.log(arr); // 10, 2, 5, 5, 6, 9 默认情况下sort方法是按ASCII字母顺序排序的，而非我们认为是按数字大小排序arr.sort(function (a, b) &#123; return a &gt; b ? 1 : -1 &#125;); // 从小到大排序console.log(arr); // 2, 5, 5, 6, 9, 10arr.sort(function (a, b) &#123; return a &lt; b ? 1 : -1 &#125;);//从大到小排序console.log(arr); // 10, 9, 6, 5, 5, 2 删除给定数组中的第 2 项和第 3 项，并且在得到的新数组中的第 2 项后面添加一个新的值。 123&gt; var arr1 = [\"a\", \"b\", \"c\", \"d\", \"e\"];&gt; var arr2 = arr1.___(___, ___, \"newvalue\");&gt; 12345678```javascriptvar arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;,&apos;e&apos;];var arr2 = arr1.splice (1, 2, &apos;newvalue&apos;);// arr2 = [b, c] 删除的元素// arr1 = [a, newvalue, d, e] 对比 jsonp 和 document.domain+ iframe 做跨域的异同，分别指出其优缺点。 见博文 数据结构与算法正则Node.js前端框架前端工程化数据可视化","categories":[],"tags":[]},{"title":"【技术之瞳】部分错误答案","slug":"yuque/【技术之瞳】部分错误答案","date":"2020-04-05T00:51:46.000Z","updated":"2020-06-07T13:19:55.956Z","comments":true,"path":"2020/04/05/yuque/【技术之瞳】部分错误答案/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/【技术之瞳】部分错误答案/","excerpt":"","text":"title: 【技术之瞳】部分错误答案 date: 2019 年 04 月 08 日 00:27:43categories: Careertypora-root-url: ..typora-copy-images-to: ../images 请填入内容，使得数组从小到大排序。 P130 习题 4.17 123&gt; var arr = [6, 2, 10, 5, 9, 5];&gt; arr.sort(_______);&gt; 12345678910111213141516171819202122232425262728293031323334353637**书中答案**`function(a, b) &#123;return a &gt;= b ? 1 : 0;&#125;`**书中答案测试结果**发现并不生效![](/images/20190404014041658.png#alt=)**个人观点**`function(a, b) &#123;return a &gt;= b ? 1 : -1;&#125;`如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：- 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。- 若 a 等于 b，则返回 0。- 若 a 大于 b，则返回一个大于 0 的值。**个人观点测试结果**生效![](/images/20190404014053447.png#alt=)&gt; 2. 删除给定数组中的第2项和第3项，并且在得到的新数组中的第2项后面添加一个新的值。&gt; ```javascriptvar arr1 = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;,&apos;e&apos;];var arr2 = arr1.___(___, ___, &apos;newvalue&apos;); 书中答案 arr1.splice (1, 2, &#39;newvalue&#39;) 书中答案测试结果 从索引为 1 的元素开始删除 2 个元素即删除 b 和 c，得到的新数组为[a, d, e] 在新数组的第 2 项后添加一个新的值，预期应得到[a, d, newvalue, e] 根据书中答案测试结果显示与答案不符 个人观点 就给出的固定句式中去填空，我暂时想不到能够解决的方案 个人观点测试结果 无","categories":[],"tags":[]},{"title":"《思维力：高效的系统思维》整理","slug":"yuque/《思维力：高效的系统思维》整理","date":"2020-04-05T00:51:41.000Z","updated":"2020-06-07T13:19:55.958Z","comments":true,"path":"2020/04/05/yuque/《思维力：高效的系统思维》整理/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/《思维力：高效的系统思维》整理/","excerpt":"","text":"思维力 image.png 过危桥问题 image.png","categories":[],"tags":[]},{"title":"《如何高效学习》整理","slug":"yuque/《如何高效学习》整理","date":"2020-04-05T00:51:36.000Z","updated":"2020-06-07T13:19:55.960Z","comments":true,"path":"2020/04/05/yuque/《如何高效学习》整理/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/《如何高效学习》整理/","excerpt":"","text":"image.png","categories":[],"tags":[]},{"title":"《华为项目管理法》整理","slug":"yuque/《华为项目管理法》整理","date":"2020-04-05T00:51:31.000Z","updated":"2020-06-07T13:19:55.962Z","comments":true,"path":"2020/04/05/yuque/《华为项目管理法》整理/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/《华为项目管理法》整理/","excerpt":"","text":"image.png","categories":[],"tags":[]},{"title":"《构建之法》整理","slug":"yuque/《构建之法》整理","date":"2020-04-05T00:51:29.000Z","updated":"2020-06-07T13:19:56.004Z","comments":true,"path":"2020/04/05/yuque/《构建之法》整理/","link":"","permalink":"http://fengtx.tk/2020/04/05/yuque/《构建之法》整理/","excerpt":"","text":"第 2 章 个人技术和流程单元测试单元测试回归测试回退操作 效能分析工具先用抽样的方法找到效能瓶颈所在，然后对特定的模块用代码注入的方法进行详细分析 个人开发流程任务清单计划 明确需求和其他相关因素，指明时间成本和依赖关系 开发 分析需求 生成设计文档 设计复审（和同事审核设计文档） 代码规范（为目前的开发定制合适的规范） 具体设计 具体编码 代码复审 测试（包括自测，修改代码，提交修改） 记录用时 报告 测试报告 计算工作量 事后总结 提出过程改进计划 软件设计的原则单一职责原则一个模块（类）应该只有一个导致它变化的原因，一个模块应该完全对某个功能负责 开放-封闭原则 允许拓展。当应用的需求发生改变时，我们可以对模块进行拓展，从而改变模块的功能 不允许修改。对模块行为进行拓展时，不必改变模块的本身 程序的健壮性数据属性拓展 超过 64 位的数字 数量拓展 十万条数据 维度拓展 多维数组 其他属性拓展 需求形象的显示数据处理的过程 维度拓展 数量拓展 增量改进 用户让用户更喜欢这个软件 记住上次的状态 自动展现上次文档最后编辑的地方 多用户 多语言 安全性 软件构建平台的迁移 多语言接口 增量升级部分模块 实践工作的细分基本功能 拓展功能 高级功能 如何保证质量——回归测试保证在加入新功能的过程中，已有的功能可继续工作，我们需要建立起一系列测试文件 第 3 章 软件工程师的成长软件工程师的成长 积累软件开发相关的知识，提升技术技能 积累问题领域的知识和经验 对通用的软件设计思想和软件工程思想的理解 提升职业技能 实际成果 软件工程师的思维思维误区分析麻痹不分主次，想解决所有依赖问题过早优化过早扩大化/泛华画扇面——调侃目标和远景 技能的反面通过不断的练习，把低层次的问题解决，变成不用经过大脑的自动操作，然后才有时间和脑力来解决较高层次的问题 第 4 章 两人合作代码风格规范 4 个空格的缩进 每个{}独占一行 不要把多个变量定义在一行上 一个类型的成员变量用m_name来命名 Pascal：所有的类型/类/函数名 lowerCamel：变量 注释是为了解释程序做什么（What），为什么这么做（Why），以及要特别注意的地方，只用 ASCII 字符，不要用中文 代码设计规范 函数：只做一件事，并且要做好 单一出口 不要在构造函数中做复杂的操作，简单初始化所有的数据成员即可 代码复审看代码是否在代码规范的框架内正确地解决了问题 长远的问题 这么修改之后，有没有别的功能会受影响 项目中还有别的地方需要类似的修改吗 有没有留下足够的说明，让将来维护代码时不会出现问题 对于这样的修改，有没有别的成员需要告知 导致问题的根本原因是什么？我们以后如何能自动避免这样的情况再次出现 代码复审的核查表","categories":[],"tags":[]}]}