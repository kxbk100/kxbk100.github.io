[{"title":"《如何高效学习》","date":"2018-09-02T13:56:41.000Z","path":"2018/09/02/《如何高效学习》/","text":"整体性学习策略什么是整体性学习 机械记忆是一种低效的学习方法 学习就像编织一张大网 整体性学习也只是一种用来解释信息是如何被储存的理论 整体性学习的三种主要观点模型 模型是简化的结构，是结构的快照，是压缩的信息，更为简单和更易储存 一本书的模型就是目录 模型对于开始构建一个结构或是在当前结构上添加内容非常重要 一张图，一个概念，知识的压缩 结构 有关C++语言各种知识及其联系的总和 理解就是结构高度发达完善的结构 建立知识结构的目标就是在各种知识之间建立尽可能多的联系 高速公路 结构与结构之间的联系，用生活经验中的例子来模拟、比喻要学的知识 假如你正在阅读生物学课本，又与学过的商业发展史课程相比较、相联系，这就建立了高速公路 结构是同类知识的联系，高速公路是不同类知识、不同结构之间的联系 整体性学习的顺序获取 简化 容量 速度 理解拓展 不断练习和知道正在创造哪种类型的联系 深度拓展（知识的背景探究） 在知识内部建立联系 横向拓展 在知识周围建立联系，建立模型 纵向拓展 运用比喻法和内在法，在结构间建立高速通道 纠错 纠错的最终途径就是实践 模型纠错法 应用项目学习法 测试信息结构随意信息观点信息过程信息具体信息抽象信息如何使用五种信息类型整体性学习技术","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://kxbk100.github.io/tags/读书笔记/"}]},{"title":"《华为项目管理法》","date":"2018-09-02T06:50:27.000Z","path":"2018/09/02/《华为项目管理法》/","text":"第1章 项目分析 识别最根本的问题或目标需求，是整个项目管理工作第一个需要完成的步骤。 弄清项目任务 记录有关任务的关键信息，偶尔还要记录领导或客户当时的情绪状态，方便对任务的理解 第一时间向领导进行确认，了解项目工作的真正诉求 项目经理在接手一个项目任务以后，首先要弄清楚“我究竟要做什么”“这个项目的具体目标是什么”等问题 了解项目需求 客户关注的是系统如何支持业务流程，让工作效率更高；而项目团队成员关注合理的技术方案，他们重视“工作量”“开发难度”和“系统稳定性”等。 项目管理者应该从客户的角度出发，深究项目背后所隐藏的需求是什么 接受项目任务 服从是行动的第一步，服从也是完成项目工作的一个前提条件 最善于服从的员工，迟早都会成为这个公司中最优活力和地位的精兵 客户是上，得罪客户的事情要尽量少做 从领导者的角度来看，领导在安排工作任务前，大多已经预估了工作时间，并做好了工作计划，而且，领导的心中也有了最佳人选。如果项目经理一口回绝，势必影响管理者对你的看法，也会打乱他原有的工作计划，这对项目经理的发展很不利 服从性：试着接受，并全力寻找最好的执行方案，及时回应对方，让领导感受到自信 主见:客观地将困难表述出来 目标与任务展开 学会把项目目标和任务展开，让复杂的任务简单化 让员工了解工作目标、对策、职权以及遇到问题时的求助者 接受任务以后不要着急去行动，而是要将总目标注意分解。目标分解得越详细，工作任务就越明确，执行起来就越轻松 执行单元细化法 不仅要使工作内容饱满，还要具有可实现性 在执行目标时，考虑时量、数量、质量这3个关键的量化指标。这3个指标既是布置工作的要求，也是衡量工作效果的指标 4小时内完成20 000人的考勤统计，形成考勤表，上报行政主管 能量化的量化，不能量化的质化 不要出现“基本了解”、“控制”等描述 在细化项目目标的过程中，需要根据目标进行具体情况的分析。建议有： 细化目标意味着将总体目标分解成为一个一个具体的小目标。这些小目标应该直指可行动的行为，最好是具有量化的评判标准； 划分的标准可以是任务的阶段性，也可以根据任务量化来进行划分。目标划分不要距离过近或者过远，以适中为宜； 设置可考量任务完成标准，标准越清晰、越客观越好。当阶段性目标实现后，需要根据评价标准与目标实现情况进行比对，总结不足与进步之处，进行反馈改进。 分目标与总目标对接 我们可以将这个最终目标先告知成员们 为了更好地实现总、分目标的完美对接，在实施团队目标分解时，应遵循以下几个原则： 按照整分原则对目标进行分解，把目标落实到不同部门。但各个分目标的综合要能体现总目标，并能保证总目标的实现； 分目标与总目标要保持方向一致，内容上下承接，相互关联； 分解目标时，要考虑各分目标所需要的条件及完成分目标的限制因素，如人、财、物、协作条件和技术保障等； 分目标的表达要简明扼要，有具体目标值和完成实现要求。保证各分目标之间的工作量大小，以及处理时间等各方面的协调、平衡。 列一份工作任务清单 对一件方案，宁可延误其计划之时间以确保日后执行之成功，切勿在毫无适切的轮廓之前即草率考试执行，而最终导致措施方案之目标 整理和记录工作任务时的三个基本原则： 从最上面的一项开始处理，尽可能迅速地完成所有任务，而且不逃避对任何一件任务的处理 一次只处理一件事情，迫使自己集中注意力作出判断 决定开始处理任务时，立刻判定它的实质及处理方法，杜绝二次处理的时间浪费 第2章 项目组队 你不可能懂得一切！大小项目，应该是项目团队所有成员努力的结果。 明确项目团队结构 团队结构是指团队成员的组成成分，是团队协作工作的基础，在队形保持中起着重要的作用 项目团队结构不是一成不变的，它应该根据具体的情况有所变化 项目经理应该有这样的意识，让项目结构适应项目工作的发展 估算项目团队规模 责任分散效应 在共同完成一项任务时，随着群体人数的增多，每个人作出的贡献将减少 项目经理在分配任务时就应该明确各个成员的职责，把责任落实到个人，这样就能极大地提高项目团队执行的效率 学会正确评估自己的工作能力，学会减少责任，确保有足够的时间和精力把事情做好。 个人应知、应会、专业知识、可塑性、背景、反应能力、人机关系、实际工作经验 挑选合适的成员 注重人才搭配而不是专门挑选拔尖人才的项目团队 名牌学校前几名的学生华为不要 跳出印象怪圈择人 兵随将转，无不可用之人 敢用一技之长的人 项目经理在组建项目团队的时候，不能只关注一个人的短处，也要关注一个的长处 挑选尽职尽责的成员 一个人责任心如何，决定着他在工作中的态度，决定着工作的好坏和成败 根据各自的特点进行组合 欲打造出一支高效的工作团队，管理者就要根据员工各自的特点进行组合，将“不同类型的头脑”集合起来，相互学习，相互促进 增进成员之间的了解 在项目成员进入团队之后，策划一些让大家相互熟悉的活动，以增进项目成员之间的了解 进行团队建设，整个过程看似嘻嘻花花，其实也会组员彼此快速熟悉的过程 第3章 项目分工 任务分工看似“小事情”，实际上却有“大门道”。 根据工作能力派发任务 每个人的工作能力都是有局限性的，不同的工作岗位对人才的要求也不尽相同。项目经理要根据他们的工作能力来派发任务，确保他们与从事的具体工作相匹配 擅长什么，就让他干什么 好的项目经理就是要在项目分工的时候，应该让岗位工作既能充分利用人才的能力，又不会给人才造成巨大的压力，以做到人尽其才 责任落实到每个人 “责任分散效应”放到项目管理中，就是对没有分配到位的工作“旁观” 确保每个人都要有事做 一定要明确分工，做到“人人有事干，事事有人干” 如果一项任务应该由一个人完成，项目经理就要让他承担全部的责任 如果一项任务交给多个人一起来完成，项目经理就要明确每个人要承担的责任 由于群体中个体的责任不明确，导致个体出现推诿心理。 明确责任分工，将责任模糊化变为职责清晰化，将匿名制变为实名制 任务分工要均衡 “当你新到一个陌生的企业或团队中时，其实不用问管理者就可以知道哪个员工做‘出色’——那个最忙碌、经常在管理者面前晃来晃去的人。” 依靠一个人独撑大局是绝对不可取的。应该在团队中仔细地挑选各种人才，然后授权给他们去负责，让他们独立作业 帮助下级成功，就是帮助整个公司成功 分工的适度原则，给不同的员工分配合适的任务量，这样既可以保证任务的完成，又兼顾了公平 多设计一些集体性的任务 项目经理在分配工作任务时，也要多设计一些集体性的任务，让项目成员共同来完成项目工作。通过这样的过程，项目成员之间的默契会得到提升，工作效率也能够得到提升 考虑项目成员的想法 项目经理要给项目成员一定的选择空间，这样能够减少项目成员完不成任务的借口 项目经理在制定工作目标和分配工作任务时，都应该给项目成员表达的机会，并且听取他们的建议 你看你想做这件事吗？ 明确岗位说明书 通过岗位说明书，明确项目成员应该做些什么、应该怎么做和在什么样的情况下履行职责 第4章 项目计划 凡事预则立，不预则废。无论做什么项目，按照计划进行总比没有计划效率更高。 让成员为困难做准备项目经理不仅要告诉项目成员做什么，还要告诉他们工作中的难点和重点，让项目成员能够对工作有足够的准备。为此，项目经理应该从两个方面入手。首先，项目经理可以针对项目成员的具体任务，告诉他们工作中的难点。这有两个方面的作用：一是让项目成员有时间考虑自己是否能克服困难，如果员工缺乏克服难点的能力，那么这种工作分配就欠缺合理性。二是当项目成员知晓工作难点之后，也可以提前做好准备，避免面对困难时淬不及防。其次，项目经理应该告知成员工作任务的重要性。当项目成员意识到工作的重要性之后，他才能重视项目经理给自己交代的任务，从而意识到自己责任重大。所以，不要轻视工作可能面临的困难，更不能把真相隐瞒起来不说。聪明的哦项目经理应该坦诚地告知项目成员工作的重点、难点，让他们提前为困难做好准备。 给工作任务排序任何工作都有轻重缓急之分，只有分清哪些是最重要的并将它首先做好，才能将工作做到井井有条、卓有成效。在判断何为要事时，人们却常常将紧急的事情误认为“要事”。外界的压力往往迫使人们不去思考明天的新局面，而力图解决昨天的危机。人们一旦被外界的压力所左右，就可能会忽略那些真正重要的工作。于是，一些要事被放置在急事之后，甚至最终被牺牲掉。 给工作任务设定时间限制每个人内心都有拖延心理，即在从事一项工作时，总觉得自己准备不足，能拖就拖。但在不能拖延的情况下，比如不允许继续准备或到了规定时间，基本上都能完成任务。这种现象在心理学上被称为“最后通牒效应”项目工作拖延的问题，并非是工作方法问题，也不是工作时间不够的问题，而是态度问题。项目经理要意识到：时间是紧缺的资源，每一项任务能够支配的时间都是有限的；只有给任务设定好时间限制，项目工作才有可能在计划内完成。 重要的任务多留一些时间要把握工作的重心，保证能够将时间用于少数重要的事情上，让工作变得有价值。这就是非常著名的80/20法则。成功的关键并不是为日程表上的事物安排先后顺序，而是用具有优先权的事情来安排日程表。 给关键任务安排整块时间大多数时候，因为我们在执行任务的过程中很少被别人打扰，总是有一整块时间，因而工作效率就会很大；如果我们在同一件事情上的时间是零散的，工作效率肯定会受影响。因此，我们要试图把时间就集中起来利用，特别是那些关键的任务，更应该安排一整块的时间，这样确保在规定的时间内完成任务。 完成任务所需资源的配置一位知识工作者如果能够凭借其职位和知识承担其对组织作出贡献的责任，并且做到实质性提升了该组织的经营能力以及创造了成果，那么他就是一位管理者。项目经理不能把自己定位成工作者，而是管理者，树立资源管理意识。在项目经理的带动下，项目团队对人，事物等资源进行合理统筹之后，才能让项目工作按照正常的工作计划向前推进。 制定风险防范计划在识别风险方面需要遵守的3条原则：（1）不拘泥于眼前事物，用长远的眼光看问题。（2）不局限于某一方面，全方位多角度地看问题。（3）不拘泥于枝节问题，要看事物的本质。风险响应计划一般从4个方面考虑：（1）规避。改变项目计划，以排除风险或条件，是项目不收影响。（2）转移。将风险的后果连通应对的责任转移到第三方。（3）减轻。把不利的风险事件概率或后果降低到一个可以接受的临界值。（4）接受。响应计划可以是主动或被动的方式。 制定沟通计划为了确保信息沟通工作的顺利进行，项目经理有必要提前制定沟通计划，明确信息沟通的信息沟通形式、信息发放时间和发放方式等内容，并制定出详细的信息发放日程表。不对在此之前，项目经理首先明确沟通的两个层面，一是针对项目组内部的沟通；二是针对与高层和顾客的沟通。紧接着，应该明确的几个问题：（1）与谁沟通？为什么要沟通？（2）他们需要怎样的信息？频度如何？（3）沟通的目标是什么？（4）用什么方式完成沟通？ 第5章 项目作业流程 项目工作的效率取决于精确的业务设计和畅通的操作流程。简化了流程，就等于提高了效率。 界定项目作业流程提前界定项目作业的流程是非常有必要的，它能减少在项目推进过程中因为失误而造成的返工，自然也能够节约时间。更重要的是，项目经理可以按照作业流程设置作业监控点，对项目任务进行把关。所以，要想项目任务高效、高质量的完成，项目经理有必要给项目团队建设一套完善的作业流程，让业务顺畅地流动起来。 去掉多余的流程无论是从员工“人性化”管理的角度来讲，还是从提供工作效率的交付来讲，项目经理都应该尽量简化组织的工作流程，化复杂为简单。事实上，流程优化并不需要奇迹或是天才，你只要把每个程序都拿来，尽你所能地把它分解成许多详细的步骤，绘成图表，然后质疑每个步骤：你能剔除它、简化它，合并两个或更多的步骤，还是可以调整作业步骤的顺序，以保证程序更有效率。 重新设计作业流程如何使用5why分析法找出流程中不合理的地方呢？5why分析法的实施主要有3个部分。首先是把握现状。即在弄清异常出现的原因之前，分析者需要问到下面的一些问题：（1）识别问题：我知道什么？（2）澄清问题：实际发生了什么？应该发生什么？（3）分解问题：关于这个问题我还知道什么？（4）查找原因要点：我需要去哪里？我需要看什么？谁可能掌握更多信息？（5）把握问题的倾向：谁负责这个环节？什么时间发生的？频率多高？其实是确认异常现象的直接原因。对新流程设计的要求是必须遵守3个步骤：第一个步骤就是要深层次地理解现有流程。虽然不必了解所有细节，但是必须找出所有核心流程。第二个步骤是员工对新流程进行设计。第三个步骤是新流程设计完成后，员工通过局部试点的方式进行检验。新流程设计完成了，并不代表流程优化结束。项目经理需要在项目执行过程中进一步完善作业流程，确保新流程的运作更加协调。只有个环节始终保持协调运作，才能达到工作流程重新设计的最初目的。 确定流程的工作标准项目经理要强化员工的执行意识，就要制定相应的规则或标准，以便能够更好地以标准化引导规范的行为，让管理这种行为变得简单而有效。SOP（Standard Operation Procedure），即标准作业程序，也就是用统一的格式来描述某一事件的标准的操作步骤和要求，以更好地指导和规范日常工作。SOP的要点是对某一个程序中起到关键作用的控制点进行量化和细化，即使是技术不熟练的工作人员，也可以根据标准作业程序快速、准确地完成工作。为作业流程确定工作标准，可以避免员工对细节操作的不知所措，也避免了不同的员工对同一项岗位作业程序存在不同的理解。自然，在这种标准的引导下，项目成员做事的效率和完成工作的质量也得以提升。 每个步骤都要走到位项目作业流程要精确到每一个细微的环节，细节是决定成败的一个关键。忽视了细节，很可能“因小失大”，功亏一篑。工作中的每一步流程、每一个执行环节连接起来成就了一个项目或一项工作，如果其中某个环节出了问题，就有可能毁掉整个项目。 负责的标准简单化项目作业流程有各种各样的工作标准，如果标准的要求过于复杂，项目成员就要花较多的时间去理解，工作效率就会受到影响。假如将复杂的标准变得简单易懂，那么执行将会变得更简单、更有效。为项目作业流程制定工作标准，并非机械地规定“走路要先迈左脚，后迈右脚”，而是要让标准更加简单易懂，且具有实用性。如果误读了细节的要求而没有根据任务的实际情况进行规范，就会落入又一个教条的陷阱当中。那样的话，只会诞生大量脱离实际的“操作手册”，对组织工作的执行效果毫无益处。 创造有序的工作环境简介有序的工作环境不是与我们争抢时间的敌人，而是帮助我们节省查找时间、带来灵感与高效率的好帮手。项目经理和项目成员都应该有这样的共识：在有序的工作环节下，人们的工作效率会更高；在脏乱的工作环境下，工作中出错的概率就会极大地增加。","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://kxbk100.github.io/tags/读书笔记/"}]},{"title":"jQuery学习小记","date":"2018-09-02T06:35:05.000Z","path":"2018/09/02/jQuery学习小记/","text":"基本选择器 $(&quot;#id&quot;)：id选择器，返回单个元素 $(&quot;.class&quot;)：class选择器，返回集合元素 $(&quot;element&quot;)：选定指定的元素名匹配的元素，返回集合元素 $(&quot;*&quot;)：通配符选择器，选择所有元素，返回集合元素 $(&quot;selector1,selector2&quot;)：选择所有选择器匹配的元素，返回集合元素 层次选择器 $(&quot;div span&quot;)：选择&lt;div&gt;里的的所有&lt;span&gt;后代元素，返回集合元素 $(&quot;div&gt;span&quot;)：选择&lt;div&gt;下的&lt;span&gt;子元素，只寻找一级，&lt;span&gt;中的&lt;span&gt;不会找到，而上述则全部找到 &lt;div&gt; &lt;span id=\"span1\"&gt;&lt;/span&gt; &lt;span id=\"span2\"&gt; &lt;span id=\"span3\"&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;!-- div span 选取的结果是&#123;span1,span2,span3&#125; --&gt;&lt;!-- div &gt; span 选取的结果是&#123;span1,span2&#125; --&gt; $(&quot;#one+div&quot;)：获取紧接在one后面的一个同辈div元素，等同于$(#one).next(&quot;div&quot;) $(#one).prev(&quot;div&quot;)获取紧接在one前面的一个同辈div元素 $(&quot;#one~div&quot;)：获取one后面的所有同辈div元素，等同于$(#one).nextAll(&quot;div&quot;) $(#one).siblings(&quot;div&quot;)：获取one的元素的所有div同辈元素（不管前后）所以 获取元素范围大小顺序依次为： $(#one).siblings(&quot;div&quot;)&gt;$(&quot;#one~div&quot;)&gt;$(&quot;#one +div&quot;) $(#one).siblings(&quot;div&quot;)&gt;$(#one).nextAll(&quot;div&quot;)&gt;$(#one).next(&quot;div&quot;) 基本过滤选择器 :first：选取第一个元素，返回单个元素 :last：选取最后一个元素，返回单个元素 :not(selector)：去除所有给定选择器所匹配的元素，返回集合元素 :even：选取索引为偶数的所有元素，索引号从0开始，返回集合元素 :odd：选取索引为奇数的所有元素，索引号从0开始，返回集合元素 :eq(index)：选取索引等于index的元素，index从0开始返回单个元素 :gt(index)：选取索引号大于index的所有元素,返回集合元素 :lt(index)：选取索引小于index的所有元素，返回集合元素 :header：选取所有的标题元素，返回集合元素 :animated：选取正在执行动画的元素，返回集合元素 :focus：选取当前获取焦点的元素，返回集合元素 内容过滤选择器 :contains(text)：选取含有文本内容为text的元素，返回集合元素 :empty：选取没有子节点或者文本的空元素，返回集合元素 :has(selector)：选取含有选择器所匹配的元素的元素，返回集合元素 :parent：选取含有子节点或者文本的元素，返回集合元素 可见性过滤选择器 :hidden：选取所有不可见的元素，返回集合元素 :visible：选取所有可见的元素，返回集合元素 属性过滤选择器 [attribute]：选取含有此属性的元素，返回集合元素 :[attribute=value]：选取属性的值为value的元素，返回集合元素 :[attribute!=value]：选取属性的值不为value的元素，返回集合元素 :[attribute^=value]：选取属性的值以value开始的元素，返回集合元素 :[attribute$=value]：选取属性的值以value结尾的元素，返回集合元素 :[attribute*=value]：选取属性的值含有value的元素，返回集合元素 :[attribute|=value]：选取属性的值等于value或者是以value为前缀（即value-，value后面跟一个连字符）的元素，返回集合元素 :[attribute~=value]：选取属性的值以空格分隔的值中含有value的元素，返回集合元素 :[attribute1][attribute1]...[attributeN1]：用多个属性选择器合并成一个复合属性选择器，返回集合元素 子元素过滤选择器 :nth-child(index/even/odd)：选取父元素下的第index个子元素，index值从1开始，或者选取奇偶子元素,返回集合元素 :first-child：选取父元素下的第一个元素，返回集合元素 :last-child：选取父元素下的最后一个子元素，返回集合元素 :only-child：如果元素是父元素的唯一的元素，则选择，否则，不选择，返回集合元素 :nth-child()还可以通过数学表达式选取一组特定的元素，如::nth-child(3n)：选取父元素下所有3的倍数的子元素（n从1开始，即选取第3，6，9，...个元素） 表单选择器 :input：选取所有的input、textarea、select、button元素，返回集合元素 :text：选取所有单行文本框，返回集合元素 :password：选取所有的密码框，返回集合元素 :radio：选取所有的单选框，返回集合元素 :checkbox：选取所有的多选框，返回集合元素 :submit：选取所有提交按钮，返回集合元素 :image：选取所有的图像按钮，返回集合元素 :reset：选取所有的重置按钮，返回集合元素 :button：选取所有的按钮，返回集合元素 :file：选取所有的上传域，返回集合元素 表单对象属性过滤选择器 :enabled：选取所有可用元素，返回集合元素 :disabled：选取所有不可用元素，返回集合元素 :checked：选取所有被选中的元素（单选框和多选框），返回集合元素 :selected：选取所有被选中的元素（下拉列表），返回集合元素 查找、设置、删除属性 attr()方法：接受一个或两个参数，一个参数是获取属性值，两个参数是设置属性,需要设置多个属性时，attr方法的参数可以是一个由属性和属性值组成的json数据格式 $(\"div\").attr(\"background\");//获取属性值$(\"div\").attr(\"background\",\"blue\");//设置属性值$(\"div\").attr(&#123;\"background\":\"blue\",\"height\":\"200px\"&#125;);//设置多个属性值 css()方法：接受一个或两个参数，当一个参数是属性名时，获取属性值，当两个参数时，设置属性第一个参数为属性名，第二个参数为属性值，需要设置多个属性时，css方法的参数可以是一个由属性和属性值组成的json数据格式 $(\"div\").css(\"background\");//获取属性值$(\"div\").css(\"background\",\"blue\");//设置属性值$(\"div\").css(&#123;\"background\":\"blue\",\"height\":\"200px\"&#125;);//设置多个属性值 另外width()方法和height()方法可以直接获取宽度和高度 addClass()：为元素添加class值，可批量添加属性与值 $(\"div\").addClass(\"myclass\"); removeAttr()：删除指定的属性 $(\"div\").removeAttr(\"background\"); removeClass()：有参数时，删除指定的class值，没有参数时，删除全部的class值 $(\"div\").removeClass(\"myclass\");$(\"div\").removeClass(); hasClass()：判断匹配的元素是否有某个class值，有则返回true，没有则返回false $(\"div\").hasClass(\"myclass\"); 创建元素、文本、属性节点 均可以直接将元素、文本、属性添加到$()方法中，如：var p=$(\"&lt;p title='mytitle'&gt;假装是标题&lt;/p&gt;\") 插入节点 append()：向元素内部添加节点，如：&lt;p&gt;我是内容&lt;/p&gt; $(\"p\").append(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果：&lt;p&gt;我是内容&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;/p&gt; appendTo()：将元素添加到指定元素内部，即将append方法中的链式操作的成员互换位置&lt;p&gt;我是内容&lt;/p&gt; $(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").appendTo(\"p\"); 结果：&lt;p&gt;我是内容&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;/p&gt; prepend()：向元素内部前置内容&lt;p&gt;我是内容&lt;/p&gt; $(\"p\").prepend(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果：&lt;p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt;我是内容&lt;/p&gt; prependTo()：将节点前置到指定元素中，即将prepend方法中的链式操作中的成员互换位置&lt;p&gt;我是内容&lt;/p&gt; $(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").prependTo(\"p\"); 结果：&lt;p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt;我是内容&lt;/p&gt; after()：在每个元素节点后添加节点&lt;p&gt;我是内容&lt;/p&gt; $(\"p\").after(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果：&lt;p&gt;我是内容&lt;/p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt; insertAfter()：讲节点插入到指定节点之后，即将after方法中的链式操作中的成员互换位置&lt;p&gt;我是内容&lt;/p&gt; $(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").insertAfter(\"p\"); 结果：&lt;p&gt;我是内容&lt;/p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt; before()：再节点前面插入节点&lt;p&gt;我是内容&lt;/p&gt; $(\"p\").before(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果：&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;p&gt;我是内容&lt;/p&gt; insertBefore()：将节点插入到指定元素前面&lt;p&gt;我是内容&lt;/p&gt; $(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").insertBefore(\"p\"); 结果：&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;p&gt;我是内容&lt;/p&gt; 删除节点 remove()：从DOM中删除所有匹配的元素，同时该节点所包含的所有后代节点将同时被删除，因为返回值是删除节点的引用，因此可以在以后继续使用这些元素，但是此时这些节点所绑定的事件也会删除，如： var $li=$(\"ul li:eq(1)\").remove();//删除节点$li.appendTo(\"ul\");//将节点添加回去 detach()：和remove()几乎一样，不同的是detach方法不会删除节点所绑定的事件和附加的数据 empty()：清空所匹配的节点 $(\"ul li:eq(1)\").empty();//此时第一个li标签内无任何内容及节点了 复制节点 clone()：复制节点，可以有参数true，当有true参数时，将同时复制节点所绑定的事件，如：$(\"ul li:eq(1)\").clone(true).apppendTo(\"ul\"); 替换节点 replaceWith()：将匹配的节点替换成指定的节点 $(\"p\").replaceWith(\"&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;\"); replaceAll()：用指定的节点替换相应节点，即将replaceWith方法中的链式操作中的成员互换位置 $(\"&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;\").replaceAll(\"p\"); 包裹节点 wrap()：将匹配的节点用指定的节点单独包裹起来&lt;p&gt;我是内容&lt;/p&gt;&lt;p&gt;我是另一个内容&lt;/p&gt; $(\"p\").wrap(\"&lt;span&gt;&lt;/span&gt;\"); 结果：&lt;span&gt;&lt;p&gt;我是内容&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;p&gt;我是另一个内容&lt;/p&gt;&lt;/span&gt; wrapAll()：将匹配的节点用指定的节点全部包裹起来&lt;p&gt;我是内容&lt;/p&gt;&lt;p&gt;我是另一个内容&lt;/p&gt; $(\"&lt;span&gt;&lt;/span&gt;\").wrapAll(\"p\"); 结果：&lt;span&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;p&gt;我是另一个内容&lt;/p&gt;&lt;/span&gt; wrapInner()：将匹配的节点内部的节点或者文本内容用指定的节点包裹起来&lt;p&gt;我是内容&lt;/p&gt; $(\"p\").wrapInner(\"&lt;span&gt;&lt;/span&gt;\"); 结果：&lt;p&gt;&lt;span&gt;我是内容&lt;/span&gt;&lt;/p&gt; 设置、获取文本、HTML和值 html()：类似于原生JavaScript中的innerHTML属性，不含参数时是获取，包含元素节点和文本节点，当内有字符串参数时，是重新设置节点内容和文本内容 $(\"p\").html(); text()：类似于原生JavaScript中的innerText属性，不含参数时是获取文本节点，当内有字符串参数时，是重新设置文本内容 $(\"p\").text(\"我是内容\"); val()：类似于原生JavaScript中的value属性，可以用来获取和设置元素的值，无论是元素或者文本框，下拉列表或者单选框，如果元素是多选，则返回一个包含所有选择的值的数组 遍历节点 children()：获取所有的子元素集合，返回一个数组，只考虑直接子元素，不考虑其他后代元素&lt;div&gt; &lt;p&gt;我是内容 &lt;span&gt;我是内嵌的内容&lt;/span&gt; &lt;/p&gt; &lt;p&gt;我是另一个内容&lt;/p&gt;&lt;/div&gt; var $div = $(\"div\").children();$div.length;//返回2，不是3，只包含直接子元素，不包含span next()：获取匹配元素后面紧邻的一个同辈元素，效果类似于$(&quot;prev+next&quot;)&lt;div&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;h1&gt;我是另一个内容&lt;/h1&gt;&lt;/div&gt; var $h1=$(\"p\").next();//返回h1元素节点 prev()：获取匹配元素前面紧邻的一个同辈元素&lt;div&gt; &lt;h1&gt;我是另一个内容&lt;/h1&gt; &lt;p&gt;我是内容&lt;/p&gt;&lt;/div&gt; var $h1=$(\"p\").prev();//返回h1元素节点 siblings()：获取匹配元素的前后所有的同辈元素&lt;div&gt; &lt;h1&gt;我是另一个内容&lt;/h1&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;ul&gt;我是列表&lt;/ul&gt;&lt;/div&gt; var $h1=$(\"p\").next();//返回h1和ul元素节点集合 closest()：获取最近的符合匹配的一个父元素&lt;div&gt; &lt;div class=\"div2\"&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; var $div=$(\"p\").closest();//返回class为div2的div元素 parent()：获取一个父元素&lt;div&gt; &lt;div class=\"div2\"&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; var $div=$(\"p\").parent();//返回class为div2的div元素 parents()：获取所有匹配的一个祖先元素&lt;div&gt; &lt;div class=\"div2\"&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; var $div=$(\"p\").parents();//返回两个div元素组成的数组 元素定位 offset()：获取元素在当前视窗的相对偏移，返回一个对象，对象包含top和left两个属性&lt;div&gt;我是内容&lt;/div&gt; var $offset=$(\"div\").offset();var left=$offset.left;var top=$offset.top; position()：获取元素相对于最近的一个position样式属性设置为relative或者absolute的祖父节点的相对偏移，返回一个对象，对象包含top和left两个属性&lt;div style=\"position:relative\"&gt; &lt;div&gt;&lt;p&gt;我是内容&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; var $position=$(\"p\").position();var left=$position.left;var top=$position.top; scrollTop()：获取元素的滚动条距离顶端的距离 scrollLeft()：获取元素的滚动条距离左侧的距离 加载DOM $(document).ready()：和原生的JavaScript的window.onload()方法有类似的功能，window.onload()方法是在网页中所有的元素（包括元素的所有关联文件）完全加载到浏览器后才执行，而$(docuemnt).ready()在DOM完全就绪时就可以被调用，此时并不意味着这些关联文件都已经下载完毕；另外，$(document).ready()可多次使用，而window.onload()只能用一次，多次使用时会出现覆盖的现象，另外其可以简写成$().ready(); 事件绑定 bind()：可以有三个参数，第一个参数是事件类型，第二个参数可选，作为event.data属性值传给事件对象的额外数据对象，第三个参数是处理函数 bind(type data fn); on()函数来绑定事件 常见的事件类型：blur、focus、load、resize、scroll、unload、click、dbclick、mousedown、mouseup、mouseover、mousemove、mouseout、mouseenter、mouseleave、change、select、submit、keydown、keyup、error另外，像click、mouseover、mouseout这类常用的事件，可以简写，如下： $(function()&#123; $(\"h1\").mouseover(function()&#123; $(this).next().show() &#125;).mouseout(function()&#123; $(this).next().hide() &#125;)&#125;) 合成事件jQuery中有两个合成事件——hover()和toggle()方法 hover()：用于模拟光标悬停事件，当光标移动到元素时，会触发第一个函数，离开时触发第二个函数，语法 hover(enter,leave); toggle()：用于模拟鼠标连续点击事件，语法 toggle(fn1,fn2,...,fn); 阻止事件之外的额外问题 停止事件冒泡：用stopPropagation()方法来停止事件冒泡，如： $(\"span\").bind(\"click\",function(event)&#123; //事件处理程序 event.stopPropagation()&#125;) 阻止默认行为：用preventDafault()方法来阻止默认行为，当然也可以用原生JavaScript中的return false，如： $(\"a\").bind(\"click\",function(event)&#123; //事件处理程序 event.preventDafault(); //或者return false;&#125;) 事件捕获：事件捕获与事件冒泡是刚好两个相反的过程，jQuery不支持事件捕获。 事件对象 添加事件对象非常简单，只需要为函数添加一个参数，一般会用event $(\"a\").bind(\"click\",function(event)&#123; //事件处理程序&#125;) event.type：获取事件的类型 $(\"a\").bind(\"click\",function(event)&#123; alert(event.type);&#125;) event.target：获取触发事件的对象元素 $(\"a\").bind(\"click\",function(event)&#123; alert(event.target.href);&#125;) event.pageX和event.pageY：获取光标相对于页面的x坐标和y坐标 $(\"a\").bind(\"click\",function(event)&#123; alert(event.pageX); alert(event.pageY);&#125;) event.which：在鼠标单击时获取到鼠标的左、中、右键；在键盘事件中获取到键盘的按键 $(\"a\").mousedown(function(event)&#123; alert(event.which);&#125;)$(\"a\").keyup(function(event)&#123; alert(event.which);&#125;) event.metaKey：在键盘事件中获取ctrl按键 移除事件 unbind()：没有参数时，删除所有的绑定事件，可以有两个参数，第一个参数是事件类型，第二个参数是将要移除的函数，提供了事件类型，则只删除该事件类型，提供了事件处理函数，则只有这个事件处理函数会被删除，语法结构如下 unbind(type,data)$(\"a\").click(function()&#123; $(\"#btn\").unbind(\"click\",fn1);&#125; 另外，对于只需要触发一次随后就立即解除绑定的情况，jQuery提供了one()方法，这个方法可以为元素绑定处理函数，当函数触发一次后，立即被删除 事件的其他用法 模拟操作：trigger()：此方法可以模拟操作，例如$(\"#btn\").triggle(\"click\")； 这段代码可以触发id为btn的按钮的click事件，trigger()方法会触发浏览器的默认事件，如果不想执行浏览器的默认操作，可以使用jQuery中的另一个方法triggerHandler()方法 绑定多个事件类型：bind可以为元素绑定多个事件类型$(function()&#123; $(\"div\").bind(\"mouseover mouseout\",function()&#123; $(this).toggleClass(\"over\"); &#125;);&#125;) 这段代码效果和下方代码一样$(function()&#123; $(\"div\").bind(\"mouseover\",function()&#123; $(this).toggleClass(\"over\"); &#125;).bind(\"mouseout\",function()&#123; $(this).toggleClass(\"over\")； &#125;);&#125;) 动画 show()和hide()：这两个是jQuery中的最基本的动画，当这两个方法不含参数时，效果类似于直接将元素的display属性分别改为block和none，这两个方法当有参数时，可以使元素慢慢显示出来，速度关键字有slow、normal、fast，此外，还可以直接指定一个数字作为显示的时间参数，单位为毫秒，其中slow的显示时间为600毫秒，normal的显示时间为400毫秒，fast的显示时间为200毫秒，这两个方法是同时改变元素的高度、宽度和不透明度 $(\"p\").toggle(function()&#123; $(this).next().hide(600);&#125;,function()&#123; $(this).next().show(600);&#125;) fadeIn()和fadeOut()：这两个函数只改变元素的不透明度，同样可以有以上的速度参数 $(\"p\").toggle(function()&#123; $(this).next().fadeOut();&#125;,function()&#123; $(this).next().fadeIn(600);&#125;) slideUp()和slideDown()：这两个方法只改变元素的高度，slideDown()方法使元素由上到下延伸展示，而slideUp()方法使元素从下到上缩短隐藏，同样有上述的时间参数 $(\"p\").toggle(function()&#123; $(this).next().slideUp();&#125;,function()&#123; $(this).next().slideDown(600);&#125;) toggle()：切换元素的可见状态，如果元素可见，则切换为隐藏，如果元素隐藏，则切换为可见 toggle(speed,callback);$(this).next().toggle(); 效果和hide()和show()方法类似 slideToggle()：通过高度来切换元素的可见性 slideToggle(speed,easing,callback); fadeTo()：把元素的不透明度以渐进的方式调整到指定的值，这个动画只调整元素的不透明度 fadeTo(speed,opacity,callback)$(this).fadeTo(100,0.3); fadeToggle()：通过不透明度来切换元素的可见性 fadeToggle(speed,easing,callback); animate()：自定义动画 animate(params,speed,callback);params：一个包含样式属性及值的映射，如：&#123;left:\"400px\",height:\"500px\"&#125;speed：速度参数，可选callback：在动画完成后执行的函数，可选 animate可以添加累加与累减动画，如： $(function()&#123; $(\"p\").click(function()&#123; $(this).animate(&#123;left:\"+=500px\"&#125;,300) &#125;);&#125;); 利用animate中的第一个参数很容易实现同时执行多个动画的效果，而需要按顺序执行动画，只需要顺序写animate动画即可，另外也可以使用链式操作 $(this).animate(&#123;left:\"500px\"&#125;,300);$(this).animate(&#123;height:\"500px\"&#125;,300); 等效于$(this).animate(&#123;left:\"500px\"&#125;,300).animate(&#123;height:\"500px\"&#125;,300); 判断元素是否处于动画状态if(!$(\"p\").is(\":animated\"))&#123; //没有处于动画状态时执行的程序&#125; 延迟动画 延迟动画利用delay()方法$(this).animate(&#123;left:\"500px\"&#125;,200).delay(1000);","tags":[{"name":"前端","slug":"前端","permalink":"https://kxbk100.github.io/tags/前端/"}]},{"title":"Vue学习小记","date":"2018-09-02T06:35:05.000Z","path":"2018/09/02/Vue学习小记/","text":"Vue的安装及语法 解析 页面中的数据与内存中的数据双向绑定 v-mdodel v-show：暂时隐藏 v-if：直接从dom中删除 v-for指令v-bind指令（v-bind:可简写为:） 绑定数据和元素属性：src、href&lt;style&gt; .active &#123; background: #a10; &#125;&lt;/style&gt;&lt;a :class=\"&#123;active: isActive&#125;\" :href=\"url\"&gt; 点我&lt;/a&gt; var app = new Vue(&#123; el: '#app', data: &#123; url: 'http://baidu.com', img: 'https://dummyimage.com/100x100/ffcc00/ffffff', klass: 'btn btn-default', isActive: true, &#125;&#125;); v-on指令（v-on:可简写为@，v-on=不可简写） v-on=”{事件:函数, 事件:函数}” v-on:事件=”函数()” 一定要都写在div#app中 更多事件参考：https://cn.vuejs.org/v2/guide/events.html v-model指令及其修饰符 适用于：input、textarea、select v-model对变量进行绑定并操作，输出变量 v-model.lazy 失焦更新 v-model.trim 删去空格 v-model.number 字符串转为number v-model在其他元素及类型上的用法控制流指令 v-if v-else-if v-else 计算属性 和method的区别：缓存数据，提高了性能computed: &#123; sum: function () &#123; return parseFloat(this.math) + parseFloat(this.physics) + parseFloat(this.english); &#125;, average: function () &#123; return Math.round(this.sum / 3); &#125; &#125;,&#125;); &lt;tr&gt; &lt;td&gt;总分&lt;/td&gt; &lt;td&gt;&#123;&#123;sum&#125;&#125;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;平均分&lt;/td&gt; &lt;td&gt;&#123;&#123;average&#125;&#125;&lt;/td&gt;&lt;/tr&gt; 组件 - 全局及局部组件 全局组件 Vue.component('like', &#123; template: ''&#125;) 局部组件 var alert_component = &#123; template: '&lt;button @click=\"on_click\"&gt;弹弹弹&lt;/button&gt;', methods: &#123; on_click: function () &#123; alert('Yo.'); &#125; &#125;&#125;;new Vue(&#123; el: '#seg1', components: &#123; alert: alert_component &#125;&#125;); 组件 - 配置组件 template必须放在el外面Vue.component('like', &#123; template: '#like-component-tpl', data: function () &#123; return &#123; like_count: 10, liked: false, &#125; &#125;, methods: &#123; toggle_like: function () &#123; if (!this.liked) this.like_count++; else this.like_count--; this.liked = !this.liked; &#125; &#125;&#125;) &lt;div id=\"app\"&gt; &lt;like&gt;&lt;/like&gt;&lt;/div&gt;&lt;template id=\"like-component-tpl\"&gt; &lt;button :class=\"&#123;liked: liked&#125;\" @click=\"toggle_like()\"&gt; 👍👍 &#123;&#123;like_count&#125;&#125; &lt;/button&gt;&lt;/template&gt; 组件 - 父子通信 自定义传参Vue.component('user', &#123; template: '&lt;a :href=\"\\'/user/\\' + username\"&gt;&#123;&#123;username&#125;&#125;&lt;/a&gt;', props: ['username'], methods: &#123;&#125;&#125;) &lt;div id=\"app\"&gt; &lt;user username=\"biaoyansu\"&gt;&lt;/user&gt;&lt;/div&gt; 组件 - 子父通信Vue.component('balance', &#123; template: ` &lt;div&gt; &lt;show @show-balance=\"show_balance\"&gt;&lt;/show&gt; //监听事件 &lt;div v-if=\"show\"&gt; 您的余额：￥98逸 &lt;/div&gt; &lt;/div&gt; `, methods: &#123; show_balance: function(data) &#123; this.show = true; console.log('data:', data); &#125; &#125;, data: function() &#123; return &#123; show: false, &#125; &#125;&#125;);Vue.component('show', &#123; template: '&lt;button @click=\"on_click()\"&gt;显示余额&lt;/button&gt;', methods: &#123; on_click() &#123; this.$emit('show-balance', &#123;a: 1, b: 2&#125;); //$emit向父级元素传递事件，触发一个事件 &#125; &#125;&#125;);new Vue(&#123; el: '#app',&#125;) 组件 - 任意及平行组件间通信 模板必须有最外层根元素div等var Event = new Vue(); //调度器Vue.component('huahua', &#123; template: ` &lt;div&gt; 我说：&lt;input @keyup=\"on_change\" v-model=\"i_said\"/&gt; &lt;/div&gt;`, methods: &#123; on_change: function () &#123; Event.$emit('huahua-said-something', this.i_said); //$emit触发器返回函数名和函数值 &#125; &#125;, data: function () &#123; return &#123; i_said: '', &#125; &#125;&#125;)Vue.component('shuandan', &#123; template: `&lt;div&gt;花花说：&#123;&#123;huahua_said&#125;&#125;&lt;/div&gt;`, data: function () &#123; return &#123; huahua_said: '', &#125;; &#125;, mounted: function () &#123; //钩子，生命周期完成后，成熟后触发事件 var me = this; Event.$on('huahua-said-something', function(data) &#123; me.huahua_said = data; &#125;); &#125;&#125;)new Vue(&#123; el: '#app',&#125;) 过滤器 filter和计算属性类似，简单的用filter，复杂的用计算属性，计算属性有缓存Vue.filter('meter', function (val, unit) &#123; val = val || 0; //无val默认值为0 unit = unit || 'm'; //无unit默认值为m return (val / 1000).toFixed(2) + unit;&#125;);Vue.filter('currency', function (val, unit) &#123; val = val || 0; unit = unit || '元'; return val + unit;&#125;);new Vue(&#123; el: '#app', data: &#123; price: 10, length: 10, &#125;&#125;) &lt;div&gt; &lt;input v-model=\"length\"&gt; mm &lt;br&gt; &#123;&#123;length | meter&#125;&#125;&lt;/div&gt;&lt;hr&gt;&lt;div&gt; &lt;input v-model=\"price\"&gt; &lt;br&gt; &#123;&#123; price | currency('USD') &#125;&#125;&lt;/div&gt; 自定义指令 - 基础配置Vue.directive('pin', function (el, binding) &#123; var pinned = binding.value; //默认为false console.log(pinned) if (pinned) &#123; el.style.position = 'fixed'; el.style.top = '10px'; el.style.left = '10px'; &#125; else &#123; el.style.position = 'static'; &#125;&#125;)new Vue(&#123; el: '#app', data: &#123; card1: &#123; pinned: false, &#125;, card2: &#123; pinned: false, &#125;, &#125;&#125;) &lt;div v-pin=\"card1.pinned\" class=\"card\"&gt; &lt;button @click=\"card1.pinned = !card1.pinned\"&gt;钉住/取消&lt;/button&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt;&lt;div v-pin=\"card2.pinned\" class=\"card\"&gt; &lt;a @click=\"card2.pinned = !card2.pinned\" href=\"#\"&gt;pin it&lt;/a&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt; 自定义指令 - 配置传参及修饰符Vue.directive('pin', function (el, binding) &#123; var pinned = binding.value; //modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 &#123; foo: true, bar: true &#125;。 var position = binding.modifiers; var warning = binding.arg; //arg紧跟: if (pinned) &#123; el.style.position = 'fixed'; for (var key in position) &#123; if (position[key]) &#123; el.style[key] = '10px'; &#125; &#125; if (warning === 'true') &#123; el.style.background = 'yellow'; &#125; &#125; else &#123; el.style.position = 'static'; &#125;&#125;)new Vue(&#123; el: '#app', data: &#123; card1: &#123; pinned: false, &#125;, card2: &#123; pinned: false, &#125;, &#125;&#125;) &lt;div v-pin:true.bottom.left=\"card1.pinned\" class=\"card\"&gt; &lt;button @click=\"card1.pinned = !card1.pinned\"&gt;钉住/取消&lt;/button&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt;&lt;div v-pin=\"card2.pinned\" class=\"card\"&gt; &lt;a @click=\"card2.pinned = !card2.pinned\" href=\"#\"&gt;pin it&lt;/a&gt; Lorem ipsum dolor sit amet, consectetur&lt;/div&gt; ###混合 mixins component中代码复用var base = &#123; methods: &#123; show: function () &#123; this.visible = true; &#125;, hide: function () &#123; this.visible = false; &#125;, toggle: function () &#123; this.visible = !this.visible; &#125; &#125;, data: function () &#123; return &#123; visible: false, &#125; &#125;&#125;;Vue.component('tooltip', &#123; template: ` &lt;div&gt; &lt;span @mouseenter=\"show\" @mouseleave=\"hide\"&gt;bys&lt;/span&gt; &lt;div v-if=\"visible\"&gt; 白岩松 &lt;/div&gt; &lt;/div&gt; `, mixins: [base], data: function () &#123; return &#123; visible: true, &#125; &#125;&#125;);Vue.component('popup', &#123; template: ` &lt;div&gt; &lt;button @click=\"toggle\"&gt;Popup&lt;/button&gt; &lt;div v-if=\"visible\"&gt; &lt;span @click=\"hide\"&gt;X&lt;/span&gt; &lt;h4&gt;title&lt;/h4&gt; Lorem ipsum dolor sit amet, consectetur adipisicing elit. Amet dolorum, iusto non nostrum porro ratione. Dolor dolorem id impedit. Dolore excepturi exercitationem incidunt iste magnam odio quas temporibus. Assumenda, magni. &lt;/div&gt; &lt;/div&gt; `, mixins: [base]&#125;);new Vue(&#123; el: '#app', data: &#123;&#125;&#125;) &lt;div id=\"app\"&gt; &lt;tooltip&gt;&lt;/tooltip&gt; &lt;popup&gt;&lt;/popup&gt;&lt;/div&gt; 插槽 slots 相当于component中的变量&lt;div id=\"app\"&gt; &lt;panel&gt; &lt;div slot=\"title\"&gt; Yo. &lt;/div&gt; &lt;div slot=\"content\"&gt; Yo Yo Yo &lt;/div&gt; &lt;/panel&gt;&lt;/div&gt;&lt;template id=\"panel-tpl\"&gt; &lt;div class=\"panel\"&gt; &lt;div class=\"title\"&gt; &lt;slot name=\"title\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;slot name=\"content\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;slot name=\"footer\"&gt; 更多信息 &lt;/slot&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; vue-router是什么和怎么用 无整页刷新，表单数据点回来仍保留 安装和基本配置var routes = [ &#123; path: '/', component: &#123; template: ` &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;, &#123; path: '/about', component: &#123; template: ` &lt;div&gt; &lt;h1&gt;关于我们&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;);new Vue(&#123; el: '#app', router: router,&#125;); &lt;div id=\"app\"&gt; &lt;div&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于我们&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 传参及获取传参path: '/user/:name',component: &#123; template: ` &lt;div&gt; &lt;div&gt;我叫：&#123;&#123;$route.params.name&#125;&#125;&lt;/div&gt; &lt;div&gt;我今年：&#123;&#123;$route.query.age&#125;&#125;岁了&lt;/div&gt; &lt;/div&gt; `,&#125;, &lt;div id=\"app\"&gt; &lt;div&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于我们&lt;/router-link&gt; &lt;router-link to=\"/user/王花花\"&gt;王花花&lt;/router-link&gt; &lt;router-link to=\"/user/李拴蛋\"&gt;李拴蛋&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 子路由var routes = [ &#123; path: '/', component: &#123; template: ` &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;, &#123; path: '/about', component: &#123; template: ` &lt;div&gt; &lt;h1&gt;关于我们&lt;/h1&gt; &lt;/div&gt; `, &#125;, &#125;, &#123; path: '/user/:name', component: &#123; template: ` &lt;div&gt; &lt;div&gt;我叫：&#123;&#123;$route.params.name&#125;&#125;&lt;/div&gt; &lt;router-link to=\"more\" append&gt;更多信息&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `, &#125;, children: [ &#123; path: 'more', component: &#123; template: ` &lt;div&gt; 用户&#123;&#123;$route.params.name&#125;&#125;的详细信息 Lorem ipsum dolor sit amet, consectetur adipisicing elit. Adipisci cum deleniti doloribus expedita inventore natus officiis quod quos similique voluptate! Distinctio nisi sequi tenetur voluptatum? Debitis iste neque pariatur voluptatibus? &lt;/div&gt; ` &#125; &#125; ] &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;); &lt;div id=\"app\"&gt; &lt;div&gt; &lt;router-link to=\"/\"&gt;首页&lt;/router-link&gt; &lt;router-link to=\"/about\"&gt;关于我们&lt;/router-link&gt; &lt;router-link to=\"/user/王花花\"&gt;王花花&lt;/router-link&gt; &lt;router-link to=\"/user/李拴蛋\"&gt;李拴蛋&lt;/router-link&gt; &lt;/div&gt; &lt;div&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/div&gt; 手动访问和传参命名视图var routes = [ &#123; path: '/', component: &#123; template: ` &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;/div&gt; `, &#125; &#125;, &#123; path: '/user', components: &#123; sidebar: &#123; template: ` &lt;div&gt; &lt;ul&gt; &lt;li&gt;用户列表&lt;/li&gt; &lt;li&gt;权限管理&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ` &#125;, content: &#123; template: ` &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Deleniti in, laborum molestias necessitatibus optio perferendis quaerat quas qui quisquam sapiente. Architecto corporis eos eum libero optio, perspiciatis quo rem vel!&lt;/div&gt; ` &#125; &#125; &#125;, &#123; path: '/post', components: &#123; sidebar: &#123; template: ` &lt;div&gt; &lt;ul&gt; &lt;li&gt;帖子列表&lt;/li&gt; &lt;li&gt;标签管理&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ` &#125;, content: &#123; template: ` &lt;div&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit. Deleniti in, laborum molestias necessitatibus optio perferendis quaerat quas qui quisquam sapiente. Architecto corporis eos eum libero optio, perspiciatis quo rem vel!&lt;/div&gt; ` &#125; &#125; &#125;]; 导航钩子 访问限制，中间件，组件的生命周期var routes = [ &#123; path: '/', component: &#123; template: `&lt;h1&gt;首页&lt;/h1&gt;` &#125; &#125;, &#123; path: '/login', component: &#123; template: `&lt;h1&gt;登录&lt;/h1&gt;` &#125; &#125;, &#123; path: '/post', component: &#123; template: `&lt;h1&gt;帖子管理&lt;/h1&gt;` &#125; &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;);router.beforeEach(function (to, from, next) &#123; var logged_in = true; if (!logged_in &amp;&amp; to.path == '/post') next('/login'); else next();&#125;);router.afterEach(function (to, from) &#123;&#125;); 元数据及路由匹配 使用meta元数据进行访问限制var routes = [ &#123; path: '/', component: &#123; template: `&lt;h1&gt;首页&lt;/h1&gt;` &#125; &#125;, &#123; path: '/a', meta: &#123; login_required: true, &#125;, component: &#123; template: `&lt;h1&gt;A&lt;/h1&gt;` &#125; &#125;, &#123; path: '/login', component: &#123; template: `&lt;h1&gt;登录&lt;/h1&gt;` &#125; &#125;, &#123; path: '/post', meta: &#123; login_required: true &#125;, component: &#123; template: `&lt;div&gt; &lt;h1&gt;帖子管理&lt;/h1&gt; &lt;router-link to=\"rain\" append&gt;后座&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;`, &#125;, children: [ &#123; path: 'rain', component: &#123; template: `&lt;h2&gt;雨天asdf后座&lt;/h2&gt;` &#125; &#125; ] &#125;,];var router = new VueRouter(&#123; routes: routes,&#125;);router.beforeEach(function (to, from, next) &#123; var logged_in = true; if (!logged_in &amp;&amp; to.matched.some(function (item) &#123; return item.meta.login_required; &#125;)) next('/login'); else next();&#125;);","tags":[{"name":"前端","slug":"前端","permalink":"https://kxbk100.github.io/tags/前端/"}]},{"title":"Bootstrap","date":"2018-09-02T06:34:22.000Z","path":"2018/09/02/Bootstrap/","text":"Bootstrap引入&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;贴吧后台管理页面&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"../css/bootstrap.min.css\"&gt; &lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"../js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 页眉 --&gt; &lt;header&gt; &lt;!-- 导航条部分 --&gt; &lt;nav&gt; ... &lt;/nav&gt; &lt;/header&gt; &lt;!-- 主要内容 --&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;!-- 左侧目录 --&gt; &lt;div class=\"col-xs-12 col-sm-2 col-md-2 col-lg-2\"&gt; ... &lt;/div&gt; &lt;!-- 右侧主要内容 --&gt; &lt;div class=\"col-xs-12 col-sm-10 col-md-10 col-lg-10\"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页尾 --&gt; &lt;footer&gt; ... &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 制作一个页面的流程 引入框架 实现页面布局代码 构建导航的整体架构 设计标题和导航链接 设计搜索框和通知系统 设置管理员登录系统 设计响应式导航 左侧边栏设计 页面主体设计 span1/2/3/4ul.unstyledul.inline响应式导航条Glyphicons &lt;span&gt;或者&lt;a&gt;动态模态对话框滚动监听工具提示框弹出框状态按钮 加载中… 折叠幻灯视频响应式&lt;div class=\"embed-responsive embed-responsive-16by9\"&gt; &lt;iframe class=\"embed-responsive-item\" src=\"iqiyi.catilog2015/24551221.swf\"&gt;&lt;/iframe&gt;&lt;/div&gt; 扁平化风格页面各种风格的按钮jQuery插件DataTables响应式表格 支持及时分页、搜索、排序 Json、数组、Ajax 可视化图表EChartsjQuery UI Bootstrap工具","tags":[{"name":"前端","slug":"前端","permalink":"https://kxbk100.github.io/tags/前端/"}]},{"title":"备忘录","date":"2018-09-01T17:57:25.000Z","path":"2018/09/02/备忘录/","text":"电子书：做注释，同步 教材：划出重点，手写分栏整理 课外纸质书：划出重点，建markdown 橱窗次序 X修改 15的考研情况 潘中祥 论文数量 岑岳峰 发布文章的web（教师、学生），发布时进行敏感词检查，发送成功，我的 + 我发布的文章 首页搜索功能 定位：所有学生，班级（中学），群组（大学） 群组文章列表 群组id列表、班级id列表 批注类型的名字修改：下划线、高亮等 剪视频 文章的来源：教师+普通用户 文章的类别：20个左右，文章的内容不限，数据集路透社的研究 如何创建群组，如何加入群组；如何创建班级，如何加入班级暂时静态化 E-mail: susanf@cinnamonhotels.com Dear Ms. Susan Fernando,I am a participant of The 13th International Conference on Computer Science &amp; Education (ICCSE 2018) from China. And there will be three people attend the conference totally. I want to book a double-bed room and a single room starting from 7th August,2018 up to 10th August,2018 and including the night of 7th August,2018 and 10th August,2018. Please inform me the discount and price details. Thank you!Best regardsFeng Tianxiang Dear Ms. Susan Fernando,As for accommodation, our organization has a ceiling of $110 per person per day. Will you give me more discount for the single room? Thank you!Best regardsFeng Tianxiang Dear Ms. Susan Fernando,However, ICCSE 2018 will be held during August 8-11, 2018. I’ve seen there’s special discounted rate for ICCSE 2018, but the price you gave to me before is exactly the price in the official website. In other words, I haven’t got the discount which you’ve promised for the ICCSE 2018 participants. How can we get the discount? Thank you!Best regardsFeng Tianxiang Dear Ms. Susan Fernando,I am a participant of ICCSE 2018 from China. And there will be three people attend the conference totally. Please reserve for me a double-bed room and a single room starting from 7th August,2018 up to 10th August,2018 and including the night of 7th August,2018 and 10th August,2018, a total of 4 nights. Please confirm this reservation as soon as possible.Note:Single room: US$ 125/- Nett per single room on BB basis per night.Double-bed room: US$ 135/- Nett per room per night on BB basis.Best regardsFeng Tianxiang 前端学习路线 本人热爱社会主义祖国，热爱教育事业，实事求是，自觉陶冶人生观、价值观、世界观，作风正派，廉洁从教，为人师表，有强烈的事业心和高度的责任感。本人热爱学校，关心学生，服从学校工作安排，与同事团结协作，工作尽心尽责，态度端正，努力完成学校交给的各项工作任务。本人政治立场端正，未参与法轮功等非法组织，无不良记录及处分。 该生在校期间在各方面表现积极，勇于进取。在学习上，该生学习成绩优秀，名列前茅。该生善于理论联系实际，常常参加老师的科研项目。在学生工作上，热爱学校，立场端正，关心集体，工作认真负责，做好学生的表率，努力完成学校交给的各项任务，被评为校“十佳团支部书记”。在生活上，该生勤俭节约，乐于助人，与同学关系较好，乐于帮助同学。该生政治立场端正，未参与法轮功等非法组织，无违法乱纪和处分等不良记录。故同意该生出国参加会议。 Dear Ms. Susan Fernando, I am a participant of ICCSE 2018 from China. And there will be three people attend the conference totally. Please confirm this reservation as soon as possible. Prof. CEN Gang : Aug.7-Aug.11 (4 nights) Premium Room with breakfastBS. FENG Tianxiang: Aug.7-Aug.11 (4 nights) Superior Room with double beds and breakfastBS. XU Zengwei: Aug.7-Aug.11 (4 nights) Room with FENG Tianxiang and with breakfast Best regards Feng Tianxiang https://my.freenom.com/clientarea.php 不能支持https","tags":[{"name":"备忘录","slug":"备忘录","permalink":"https://kxbk100.github.io/tags/备忘录/"}]},{"title":"前端开发笔记","date":"2018-09-01T15:18:43.000Z","path":"2018/09/01/前端开发笔记/","text":"aria-expanded=&quot;false&quot; aria-expanded表示展开状态。默认为undefined, 表示当前展开状态未知。其它可选值：true表示元素是展开的；false表示元素不是展开的 aria-hidden字符串 可选值为true和false，true表示元素隐藏(不可见)，false表示元素可见 快捷键 Ctrl + Enter 光标不在末尾回车 Ctrl + Backspace 删除一个词 Ctrl + -&gt; 以词为单位后移 col-xs-n中放图片不生效img &#123; display: block; max-width: 100%;&#125; display block 默认，此元素将显示为块级元素，此元素前后会带有换行符 inline 此元素会被显示为内联元素，元素前后没有换行符 inline-block 行内块元素 使用col就要在母元素上清除浮动，因为col栅格也是浮动的使用flag覆盖叠加新的属性 css中使用.side-bar-card.flag {}来调用 html中用&lt;div class=&quot;side-bar-card flag clearfix&quot;&gt; a标签链接不带下划线，并列换行写a,a:hover,a:visited,a:link,a:active &#123; text-decoration: none;&#125; line-heigh不要写px表格居中&lt;table align=\"center\"&gt; bootstrap响应式表格&lt;div class=\"table-responsive\"&gt; 表格内容水平垂直居中&lt;!-- 水平居中 --&gt;&lt;th style='text-align: center;'&gt;host&lt;/th&gt;&lt;!-- 垂直居中 --&gt;&lt;td rowspan=$row_host1 style='vertical-align: middle;'&gt;host1&lt;/td&gt;&lt;!-- 既水平又垂直居中 --&gt;&lt;td rowspan=$rowspan style='vertical-align: middle;text-align: center;'&gt;hello&lt;/td&gt; 图片撑满background-size: cover; input/select/textarea/... + .form-control.form-group 单独的表单控件会被自动赋予一些全局样式。所有设置了.form-control类的&lt;input&gt;、&lt;textarea&gt;和&lt;select&gt;元素都将被默认设置宽度属性为width: 100%;。将label元素和前面提到的控件包裹在.form-group中可以获得最好的排列 响应式表格 将任何.table元素包裹在&lt;div class=&quot;table-responsive&quot;&gt;元素内 垂直方向的内容截断 响应式表格使用了overflow-y: hidden属性，这样就能将超出表格底部和顶部的内容截断。特别是，也可以截断下拉菜单和其他第三方组件 .form-inline 输入框和单选/多选框控件默认被设置为width: 100%;。在内联表单，我们将这些元素的宽度设置为width: auto;，因此，多个控件可以排列在同一行。根据布局需求，手动设置宽度 一定要添加label标签，对于内联表单，可以通过为label设置.sr-only类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如aria-label、aria-labelledby或title属性 .form-horizontal 无需再添加.row了 margin对span无效display: block;line-height: 1.5; button后退&lt;button class=\"btn btn-danger ycx\" onclick=\"javascript :history.back(-1);\"&gt;返回&lt;/button&gt; 居中 文本内容居中：text-center 图片居中：center-block 其他类型元素居中：col-md-offset-X 在form标签上加novalidate属性，可以禁用h5默认的表单验证效果div置顶的方法position: relative;z-index: 99999; margin:auto实现绝对定位元素的居中.element &#123; width: 600px; height: 400px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;&#125; ajax中dataType为预期服务器返回的数据类型，不写有默认值，开发过程中不要写ajax表单序列化传输$(\"#submit\").on('touchstart', function () &#123; var form = $(\"#handouts\").serialize(); $.ajax(&#123; url: 'http://192.168.1.111:8686/EAnnotation/addPassage', type: \"post\", data: form, cache: false, success: function (data) &#123; window.location.href = \"course.html\" &#125;, error: function (e) &#123; &#125; &#125;) return false; &#125;); ajax表单传递键值对$(\"#submit\").on('touchstart', function () &#123; var form = new FormData($('#homework')[0]); $.ajax(&#123; url: 'https://bitcandy.one/EAnnotation/addPassage', type: 'POST', cache: false, data: form, processData: false, contentType: false, success: function (data) &#123; window.location.href = \"classteacher.html\" console.log(form); &#125;, error: function (e) &#123; &#125; &#125;) return false;&#125;); ajax拿到json后如何使用$.ajax(&#123; url: 'http://192.168.1.111:8686/EAnnotation/getAllPassages', type: \"post\", cache: false, success: function (data) &#123; console.log(data); $.each(data, function (i, item) &#123; var time = getDateDiff(item.releaseTime); if (item.photo) &#123; &#125; else &#123; $(\"ul[class=index]\").append( `&lt;div class=\"card\"&gt; &lt;div class=\"card-header\"&gt;` + item.title + `&lt;/div&gt; &lt;div class=\"card-content card-content-padding\"&gt; &lt;p class=\"date index\"&gt;` + item.theme + `·` + time + `&lt;/p&gt; &lt;a href=\"www.baidu.com\" class=\"link\" style=\"color: black\"&gt;&lt;p style=\"margin-top: 0; margin-bottom: 0;\"&gt;` + getcontent(item.content).substring(0, 70) + ` ...&lt;/p&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"card-footer\"&gt; &lt;a href=\"#\" class=\"link\" style=\"color\"&gt; &lt;i class=\"f7-icons size-18\"&gt;heart_fill&lt;/i&gt;` + 1 + `喜欢&lt;/a&gt; &lt;a href=\"#\" class=\"link\"&gt; ` + 22 + `人批注过，共计` + 44 + `条批注 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;` ) &#125; &#125;) &#125;, error: function (e) &#123; &#125; &#125;) 多行文字限制字数显示....text_overflow&#123; /* width:27rem; */ display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;&#125; 单行文字限制字数显示....text_overflow&#123; width:27em; white-space:nowrap; text-overflow:ellipsis; -o-text-overflow:ellipsis; overflow:hidden;&#125; 从html代码中获取纯文本函数function getcontent(text) &#123; var html = text; return html.replace(/&lt;[^&gt;]*&gt;|/g, \"\");&#125; 时间戳转化函数// 2014-05-08 00:22:11function getDateDiff(dateTimeStamp) &#123; var dateTimeStamp = new Date(Date.parse(dateTimeStamp.replace(/-/g, \"/\"))); dateTimeStamp = dateTimeStamp.getTime(); var result; var minute = 1000 * 60; var hour = minute * 60; var day = hour * 24; var halfamonth = day * 15; var month = day * 30; var now = new Date().getTime(); var diffValue = now - dateTimeStamp; if (diffValue &lt; 0) &#123; return; &#125; var monthC = diffValue / month; var weekC = diffValue / (7 * day); var dayC = diffValue / day; var hourC = diffValue / hour; var minC = diffValue / minute; if (monthC &gt;= 1) &#123; if (monthC &lt;= 12) result = \"\" + parseInt(monthC) + \"个月前\"; else &#123; result = \"\" + parseInt(monthC / 12) + \"年前\"; &#125; &#125; else if (weekC &gt;= 1) &#123; result = \"\" + parseInt(weekC) + \"周前\"; &#125; else if (dayC &gt;= 1) &#123; result = \"\" + parseInt(dayC) + \"天前\"; &#125; else if (hourC &gt;= 1) &#123; result = \"\" + parseInt(hourC) + \"小时前\"; &#125; else if (minC &gt;= 1) &#123; result = \"\" + parseInt(minC) + \"分钟前\"; &#125; else &#123; result = \"刚刚\"; &#125; return result;&#125;; js变量生命周期 全局变量 var n=999;function f1()&#123; alert(n);&#125;f1(); // 输出999,说明全局变量n在函数内部被读取 函数中的全局变量：在函数内部声明变量没有使用var，实际上是声明了一个全局变量，前提是需要先调用函数 var func1 = function()&#123; a1 = 1; console.log(a1); //输出:1 function func2() &#123;//func2()是一个闭包 a2 = 2; console.log(a2); &#125; func2()；//闭包函数中的变量在调用函数之后，变量也是全局变量 console.log(a2);//输出2&#125;;func1();//调用函数，才会使变量生效console.log(a1);//输出1console.log(a2);//输出2，说明闭包中没有用var声明的变量也是全局变量。 局部变量：在函数内部声明的变量。函数内部的变量，外部无法读取。 function f1()&#123; var n=999;&#125;alert(n); // 没有定义，说明函数内部的变量，外部无法读取。 JavaScript解释器在执行脚本时，是按块来执行的。通俗地说，就是浏览器在解析HTML文档流时，如果遇到一个&lt;script&gt;标签，则JavaScript解释器会等到这个代码块都加载完后，先对代码块进行预编译，然后再执行。执行完毕后，浏览器会继续解析下面的HTML文档流，同时JavaScript解释器也准备好处理下一个代码块。由于JavaScript是按块执行的，所以如果在一个JavaScript块中调用后面块中声明的变量或函数就会提示语法错误。虽然说，JavaScript是按块执行的，但是不同块都属于同一个全局作用域，也就是说，块之间的变量和函数是可以共享的。 jquery获取radio被选中的值 三种方法都可以$('input:radio:checked').val()；$(\"input[type='radio']:checked\").val();$(\"input[name='rd']:checked\").val(); jquery获取select被选中的值 获取选中项的value值 $('select#sel option:selected').val();或者$('select#sel').find('option:selected').val(); 获取选中项的text值 $('select#seloption:selected').text();或者$('select#sel').find('option:selected').text(); 获取当前选中项的索引值 $('select#sel').get(0).selectedIndex; jquery获取checkbox被选中的值 获取单个checkbox选中项 $(\"input:checkbox:checked\").val() 或者 $(\"input:[type='checkbox']:checked\").val(); 或者 $(\"input:[name='ck']:checked\").val(); 获取多个checkbox选中项 $(\"input[name='favour']:checked\").each(function () &#123; alert($(this).val());&#125;); jquery获取span和input的值$(\"span\").html();$(\"input\").val(); jquery数组对象获取value值 需将数组对象再次封装为jquery对象// 错误$(\"input[name='jQueryArray']\")[0].val();// 正确$($(\"input[name='jQueryArray']\")[0]).val();0 this必须用$包装成JQuery对象才能使用用let和const的声明可以产生块级作用域，解决闭包循环事件绑定for (var i = 0; i &lt; 2; i++) &#123; let ii = i; //const也可以，块级作用域 var bt = document.getElementById('bt'+ii); bt.onclick = function()&#123; console.log(ii); &#125;; &#125; JavaScript中有5种简单数据类型（也称为基本数据类型）： Undefined、Null、Boolean、Number和String 。还有1种复杂数据类型—— Object ，Object本质上是由一组无序的名值对组成的。backgroundColor要加.style属性设置元素的背景颜色；bgcolor不用加.stylejson中key也是个字符串，要加引号，key和value之间是用:号来表示的CSS样式表和选择器CSS和HTML结合的三种方式：行内样式表、内嵌样式表、外部样式表CSS四种基本选择器：标签选择器、类选择器、ID选择器、通用选择器CSS几种扩展选择器：后代选择器、交集选择器、并集选择器、伪类选择器","tags":[{"name":"前端","slug":"前端","permalink":"https://kxbk100.github.io/tags/前端/"}]},{"title":"后端开发笔记","date":"2018-09-01T15:18:43.000Z","path":"2018/09/01/后端开发笔记/","text":"python缩进必须使用4个空格SQL中带有有IN谓词的子查询 IN后面为集合，找字段在子集中是否存在，一个一个比对过去是否相等，返回true或false如果有则输出前面要SELCECT的部分 =后面的集合中只能有一条记录，除非是条件a.xx = b.xx，不等关系后面的集合可以有多条记录 左连接、右连接 左连接：左边的表中的记录有空值仍列出 右连接：右边的表中的记录有空值仍列出 第三方java项目 删除target文件夹 将java文件夹mark as source root Servlet简介 servlet为服务端的小应用程序，用于处理请求响应 不用new 给Servlet提供（映射）一个可供客户端访问的URI Servlet的生命周期实例化 -&gt; 初始化 -&gt; 服务 -&gt; 销毁 出生：（实例化 -&gt; 初始化）第一次访问就出生（默认情况下） 活着：（服务）应用活着，servlet就活着 死亡：（销毁）应用卸载了servlet就销毁","tags":[{"name":"后端","slug":"后端","permalink":"https://kxbk100.github.io/tags/后端/"}]},{"title":"Axure使用心得","date":"2018-01-14T12:30:33.000Z","path":"2018/01/14/Axure使用心得/","text":"按住Ctrl时，可以旋转 按住Ctrl时，拖动曲线 右键转换曲线的类型","tags":[{"name":"备忘录","slug":"备忘录","permalink":"https://kxbk100.github.io/tags/备忘录/"}]},{"title":"《构建之法》","date":"2017-12-07T14:44:01.000Z","path":"2017/12/07/《构建之法》/","text":"第2章 个人技术和流程单元测试单元测试回归测试回退操作 效能分析工具先用抽样的方法找到效能瓶颈所在，然后对特定的模块用代码注入的方法进行详细分析 个人开发流程任务清单计划 明确需求和其他相关因素，指明时间成本和依赖关系 开发 分析需求 生成设计文档 设计复审（和同事审核设计文档） 代码规范（为目前的开发定制合适的规范） 具体设计 具体编码 代码复审 测试（包括自测，修改代码，提交修改） 记录用时 报告 测试报告 计算工作量 事后总结 提出过程改进计划 软件设计的原则单一职责原则一个模块（类）应该只有一个导致它变化的原因，一个模块应该完全对某个功能负责 开放-封闭原则 允许拓展。当应用的需求发生改变时，我们可以对模块进行拓展，从而改变模块的功能 不允许修改。对模块行为进行拓展时，不必改变模块的本身 程序的健壮性数据属性拓展 超过64位的数字 数量拓展 十万条数据 维度拓展 多维数组 其他属性拓展 需求形象的显示数据处理的过程 维度拓展 数量拓展 增量改进 用户让用户更喜欢这个软件 记住上次的状态 自动展现上次文档最后编辑的地方 多用户 多语言 安全性 软件构建平台的迁移 多语言接口 增量升级部分模块 实践工作的细分基本功能拓展功能高级功能 如何保证质量——回归测试保证在加入新功能的过程中，已有的功能可继续工作，我们需要建立起一系列测试文件 第3章 软件工程师的成长软件工程师的成长 积累软件开发相关的知识，提升技术技能 积累问题领域的知识和经验 对通用的软件设计思想和软件工程思想的理解 提升职业技能 实际成果 软件工程师的思维思维误区分析麻痹不分主次，想解决所有依赖问题过早优化过早扩大化/泛华画扇面——调侃目标和远景 技能的反面通过不断的练习，把低层次的问题解决，变成不用经过大脑的自动操作，然后才有时间和脑力来解决较高层次的问题 第4章 两人合作代码风格规范 4个空格的缩进 每个{}独占一行 不要把多个变量定义在一行上 一个类型的成员变量用m_name来命名 Pascal：所有的类型/类/函数名 lowerCamel：变量 注释是为了解释程序做什么（What），为什么这么做（Why），以及要特别注意的地方，只用ASCII字符，不要用中文 代码设计规范 函数：只做一件事，并且要做好 单一出口 不要在构造函数中做复杂的操作，简单初始化所有的数据成员即可 代码复审看代码是否在代码规范的框架内正确地解决了问题长远的问题 这么修改之后，有没有别的功能会受影响 项目中还有别的地方需要类似的修改吗 有没有留下足够的说明，让将来维护代码时不会出现问题 对于这样的修改，有没有别的成员需要告知 导致问题的根本原因是什么？我们以后如何能自动避免这样的情况再次出现 代码复审的核查表","tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://kxbk100.github.io/tags/读书笔记/"}]},{"title":"Hexo使用心得","date":"2017-11-27T17:31:00.000Z","path":"2017/11/28/Hexo使用心得/","text":"新建文章hexo new &quot;Hexo使用心得&quot; 上传图片到github并使用 将_config.yml中有的post_asset_folder设置为true 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save 完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹 使用![test](Hexo使用心得/test.jpg)就可以插入图片。其中[]里面不写文字则没有图片标题 Hexo-admin本地的文章编辑器，不支持在线/admin访问，github.io都是静态界面 更新文章hexo d -g","tags":[{"name":"备忘录","slug":"备忘录","permalink":"https://kxbk100.github.io/tags/备忘录/"}]},{"title":"Java学习小记","date":"2017-11-25T03:50:20.000Z","path":"2017/11/25/Java学习小记/","text":"ScannerScanner s = new Scanner(System.in);// 使用hasNextXxx()方法进行验证，再使用nextXxx()来读取// next()// next() 不能得到带有空格的字符串import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 //next方式接收字符串 System.out.println(\"next方式接收：\"); // 判断是否还有输入 if(scan.hasNext())&#123; String str1 = scan.next(); System.out.println(\"输入的数据为：\"+str1); &#125; &#125; &#125;// nextLine()// 以Enter为结束符，可以获得空白import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 //nextLine方式接收字符串 System.out.println(\"nextLine方式接收：\"); // 判断是否还有输入 if(scan.hasNextLine())&#123; String str2 = scan.nextLine(); System.out.println(\"输入的数据为：\"+str2); &#125; &#125; &#125;scanner.close(); 数组大小用size()students.size(); 数组访问用get()temp = students.get(i); 数组修改用set()students.set(i, stu); for的遍历// 打印所有学生的信息public void displayAllStudent() &#123; if (students.size() &gt; 0) &#123; for (Student stu : students) &#123; System.out.println(\"学号: \" + stu.getSno() + \"\\t姓名: \" + stu.getSname() + \"\\t系部: \" + stu.getSdept()); &#125; &#125;else &#123; System.out.println(\"数据库中无学生记录!\"); &#125;&#125; 读取文件// 读取文件获得原始数据private void getData() &#123; try &#123; FileReader in_ = new FileReader(\"StudentDAO.txt\"); BufferedReader in = new BufferedReader(in_); String line; String reg1 = \"\\\\s+\"; String str[] = new String[3]; while ((line = in.readLine()) != null) &#123; Student temp = new Student(); str = line.split(reg1); temp.setSno(str[0]); temp.setSname(str[1]); temp.setSdept(str[2]); students.add(temp); &#125; in.close(); &#125; catch (IOException e) &#123; System.out.println(e); &#125;&#125; 写入文件//更新数据库,把数据输入文件private void updateData() &#123; try &#123; FileWriter out_ = new FileWriter(\"StudentDAO.txt\"); BufferedWriter out = new BufferedWriter(out_); Student temp = new Student(); for (int i = 0; i &lt; students.size(); i++) &#123; temp = students.get(i); out.write(temp.getSno() + \" \" + temp.getSname() + \" \" + temp.getSdept() + \"\\r\\n\"); &#125; out.close(); &#125; catch (IOException e) &#123; System.out.println(e); &#125;&#125; BufferedReaderdo &#123; // 从输入流读取一个字符并把该字符作为整数值返回， 当流结束的时候返回 -1 c = (char)br.read(); System.out.println(c);&#125; while (c != 'q');do &#123; str = br.readLine(); System.out.println(str);&#125; while(!str.equals(\"end\")); FileInputStream（从文件读取数据）InputStream f = new FileInputStream(\"C:/java/hello\");File f = new File(\"C:/java/hello\");InputStream out = new FileInputStream(f); FileOutputStream（向文件中写数据）OutputStream f = new FileOutputStream(\"C:/java/hello\")File f = new File(\"C:/java/hello\");OutputStream f = new FileOutputStream(f); 读取写入流最后都要close();读写一定要用bytebyte bWrite[] = &#123; 11, 21, 3, 40, 5 &#125;;byte bWrite[] = \"zhouzhiwenishandsome\".getBytes();","tags":[{"name":"后端","slug":"后端","permalink":"https://kxbk100.github.io/tags/后端/"}]},{"title":"ThinkPHP学习小记","date":"2017-11-25T03:50:20.000Z","path":"2017/11/25/ThinkPHP学习小记/","text":"ID不从1开始truncate table 你的表名 无法访问可能保存了带bom的utf编码 部署到iis服务器将runtime设定到支持写入的目录 数据不为空显示&lt;!-- 不等于 --&gt;&lt;if condition=\"$result[0]['jiyao_id'] neq null\"&gt; &lt;tr&gt; &lt;td style=\"vertical-align: middle;text-align:center;width: 20%\"&gt; &lt;span&gt;&lt;b&gt;机要编号&lt;/b&gt;&lt;/span&gt; &lt;/td&gt; &lt;td class=\"description\"&gt;&#123;$result[0]['jiyao_id']&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/if&gt; 1 0转换&lt;!-- 字符串用'' --&gt;&lt;if condition=\"$student.is_searched eq 1\"&gt;已查询&lt;else/&gt;未查询&lt;/if&gt;&lt;/td&gt;","tags":[{"name":"后端","slug":"后端","permalink":"https://kxbk100.github.io/tags/后端/"}]},{"title":"Android学习小记","date":"2017-11-25T02:31:20.000Z","path":"2017/11/25/Android学习小记/","text":"禁止Android不跟随屏幕密度加载不同文件夹的资源在AndroidManifest.xml文件中添加android:anyDensity=”false”字段 高分辨率，一般我们把图片丢这里mipmap-hdpi调试时默认生成的apk在：app/build/outputs/apk目录下Android Studio 打包时 Signature Version V1 V2 同时勾选V1和V2则所有机型都没问题 生成目录 E:\\wamp64\\www\\EAider\\app\\release 发布apk做代码混淆 爱加密match_parent和fill_parent fill_parent = match_parent（一般用match_parent） wrap_content设置一个视图的尺寸为wrap_content将强制性地使视图扩展以显示全部内容。以TextView和ImageView控件为例，设置为wrap_content将完整显示其内部的文本和图像。布局元素将根据内容更改大小。设置一个视图的尺寸为wrap_content大体等同于设置Windows控件的Autosize属性为True。 layout_gravity和gravity android:gravity属性是对该view中内容的限定，比如一个button上面的text，你可以设置该text相对于view的靠左，靠右等位置 android:layout_gravity是用来设置该view相对与父view的位置，比如一个button在linearlayout里，你想把该button放在linearlayout里靠左、靠右等位置就可以通过该属性设置 android:gravity用于设置View中内容相对于View组件的对齐方式 android:layout_gravity用于设置View组件相对于Container的对齐方式 线性布局 权重用途很大 当android:orientation=&quot;vertical&quot;时，只有水平方向的设置才起作用，垂直方向的设置不起作用。即：left,right,center_horizontal是生效的 当android:orientation=&quot;horizontal&quot;时，只有垂直方向的设置才起作用，水平方向的设置不起作用。即：top,bottom,center_vertical是生效的 分隔线&lt;View android:layout_width=\"match_parent\" android:layout_height=\"1px\" android:background=\"#000000\"/&gt; 布局使用RelativeLayout+LinearLayout的weight属性搭配使用相对布局广告弹出框Demo&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/RelativeLayout1\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#00CCCCFF\"&gt; &lt;ImageView android:id=\"@+id/img1\" android:background=\"#000\" android:layout_centerInParent=\"true\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" /&gt; &lt;ImageView android:id=\"@+id/imgCancle\" android:layout_alignRight=\"@id/img1\" android:layout_alignTop=\"@id/img1\" android:background=\"#5555\" android:layout_marginTop=\"-15dp\" android:layout_marginRight=\"-10dp\" android:layout_width=\"28dp\" android:layout_height=\"28dp\" /&gt;&lt;/RelativeLayout&gt; 表格布局帧布局FrameLayout android:foreground:设置改帧布局容器的前景图像 android:foregroundGravity:设置前景图像显示的位置 网格布局GridLayout 默认每个组件都是占一行一列 通过android:layout_rowSpan与android:layout_columnSpan设置了组件横跨多行或者多列的话，如果你要让组件填满横越过的行或列的话，需要添加android:layout_gravity = &quot;fill&quot; 低版本sdk如何使用GridLayout&lt;android.support.v7.widget.GridLayout&gt;，v7包一般在sdk下的sdk\\extras\\android\\support\\v7\\gridlayout目录下 几个单位 dp(dip): device independent pixels(设备独立像素)，不同设备有不同的显示效果，这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA推荐使用这个，不依赖像素 px: pixels(像素)，不同设备显示效果相同，一般我们HVGA代表320x480像素，这个用的比较多 pt: point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业，非常简单易用 sp: scaled pixels(放大像素)，主要用于字体显示best for textsize 布局层次越少，性能越好设置的drawable并不能自行设置大小，在XML是无法直接设置的，所以需要在Java代码中来进行修改","tags":[{"name":"Android","slug":"Android","permalink":"https://kxbk100.github.io/tags/Android/"}]}]