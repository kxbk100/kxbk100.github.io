[{"title":"前端开发笔记","date":"2018-09-01T15:18:43.000Z","path":"2018/09/01/前端开发笔记/","text":"Boostrap部分Bootstrap引入&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;贴吧后台管理页面&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"../css/bootstrap.min.css\"&gt; &lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"../js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 页眉 --&gt; &lt;header&gt; &lt;!-- 导航条部分 --&gt; &lt;nav&gt; ... &lt;/nav&gt; &lt;/header&gt; &lt;!-- 主要内容 --&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;!-- 左侧目录 --&gt; &lt;div class=\"col-xs-12 col-sm-2 col-md-2 col-lg-2\"&gt; ... &lt;/div&gt; &lt;!-- 右侧主要内容 --&gt; &lt;div class=\"col-xs-12 col-sm-10 col-md-10 col-lg-10\"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页尾 --&gt; &lt;footer&gt; ... &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 制作一个页面的流程 引入框架 实现页面布局代码 构建导航的整体架构 设计标题和导航链接 设计搜索框和通知系统 设置管理员登录系统 设计响应式导航 左侧边栏设计 页面主体设计 span1/2/3/4ul.unstyledul.inline响应式导航条##Glyphicons &lt;span&gt;或者&lt;a&gt; 动态模态对话框滚动监听工具提示框弹出框状态按钮 加载中… 折叠幻灯视频响应式&lt;div class=\"embed-responsive embed-responsive-16by9\"&gt; &lt;iframe class=\"embed-responsive-item\" src=\"iqiyi.catilog2015/24551221.swf\"&gt;&lt;/iframe&gt;&lt;/div&gt; 扁平化风格页面各种风格的按钮jQuery插件DataTables响应式表格 支持及时分页、搜索、排序 Json、数组、Ajax 可视化图表EChartsjQuery UI Bootstrap工具 jQuery基本选择器 $(&quot;#id&quot;)：id选择器，返回单个元素 $(&quot;.class&quot;)：class选择器，返回集合元素 $(&quot;element&quot;)：选定指定的元素名匹配的元素，返回集合元素 $(&quot;*&quot;)：通配符选择器，选择所有元素，返回集合元素 $(&quot;selector1,selector2&quot;)：选择所有选择器匹配的元素，返回集合元素 层次选择器 $(&quot;div span&quot;)：选择&lt;div&gt;里的的所有&lt;span&gt;后代元素，返回集合元素 $(&quot;div&gt;span&quot;)：选择&lt;div&gt;下的&lt;span&gt;子元素，只寻找一级，&lt;span&gt;中的&lt;span&gt;不会找到，而上述则全部找到 &lt;div&gt; &lt;span id=\"span1\"&gt;&lt;/span&gt; &lt;span id=\"span2\"&gt; &lt;span id=\"span3\"&gt;&lt;/span&gt; &lt;/span&gt;&lt;/div&gt;&lt;!-- div span 选取的结果是&#123;span1,span2,span3&#125; --&gt;&lt;!-- div &gt; span 选取的结果是&#123;span1,span2&#125; --&gt; $(&quot;#one+div&quot;)：获取紧接在one后面的一个同辈div元素，等同于$(#one).next(&quot;div&quot;) $(#one).prev(&quot;div&quot;)获取紧接在one前面的一个同辈div元素 $(&quot;#one~div&quot;)：获取one后面的所有同辈div元素，等同于$(#one).nextAll(&quot;div&quot;) $(#one).siblings(&quot;div&quot;)：获取one的元素的所有div同辈元素（不管前后）所以 获取元素范围大小顺序依次为： $(#one).siblings(&quot;div&quot;)&gt;$(&quot;#one~div&quot;)&gt;$(&quot;#one +div&quot;) $(#one).siblings(&quot;div&quot;)&gt;$(#one).nextAll(&quot;div&quot;)&gt;$(#one).next(&quot;div&quot;) 基本过滤选择器 :first：选取第一个元素，返回单个元素 :last：选取最后一个元素，返回单个元素 :not(selector)：去除所有给定选择器所匹配的元素，返回集合元素 :even：选取索引为偶数的所有元素，索引号从0开始，返回集合元素 :odd：选取索引为奇数的所有元素，索引号从0开始，返回集合元素 :eq(index)：选取索引等于index的元素，index从0开始返回单个元素 :gt(index)：选取索引号大于index的所有元素,返回集合元素 :lt(index)：选取索引小于index的所有元素，返回集合元素 :header：选取所有的标题元素，返回集合元素 :animated：选取正在执行动画的元素，返回集合元素 :focus：选取当前获取焦点的元素，返回集合元素 内容过滤选择器 :contains(text)：选取含有文本内容为text的元素，返回集合元素 :empty：选取没有子节点或者文本的空元素，返回集合元素 :has(selector)：选取含有选择器所匹配的元素的元素，返回集合元素 :parent：选取含有子节点或者文本的元素，返回集合元素 可见性过滤选择器 :hidden：选取所有不可见的元素，返回集合元素 :visible：选取所有可见的元素，返回集合元素 属性过滤选择器 [attribute]：选取含有此属性的元素，返回集合元素 :[attribute=value]：选取属性的值为value的元素，返回集合元素 :[attribute!=value]：选取属性的值不为value的元素，返回集合元素 :[attribute^=value]：选取属性的值以value开始的元素，返回集合元素 :[attribute$=value]：选取属性的值以value结尾的元素，返回集合元素 :[attribute*=value]：选取属性的值含有value的元素，返回集合元素 :[attribute|=value]：选取属性的值等于value或者是以value为前缀（即value-，value后面跟一个连字符）的元素，返回集合元素 :[attribute~=value]：选取属性的值以空格分隔的值中含有value的元素，返回集合元素 :[attribute1][attribute1]...[attributeN1]：用多个属性选择器合并成一个复合属性选择器，返回集合元素 子元素过滤选择器 :nth-child(index/even/odd)：选取父元素下的第index个子元素，index值从1开始，或者选取奇偶子元素,返回集合元素 :first-child：选取父元素下的第一个元素，返回集合元素 :last-child：选取父元素下的最后一个子元素，返回集合元素 :only-child：如果元素是父元素的唯一的元素，则选择，否则，不选择，返回集合元素 :nth-child()还可以通过数学表达式选取一组特定的元素，如::nth-child(3n)：选取父元素下所有3的倍数的子元素（n从1开始，即选取第3，6，9，...个元素） 表单选择器 :input：选取所有的input、textarea、select、button元素，返回集合元素 :text：选取所有单行文本框，返回集合元素 :password：选取所有的密码框，返回集合元素 :radio：选取所有的单选框，返回集合元素 :checkbox：选取所有的多选框，返回集合元素 :submit：选取所有提交按钮，返回集合元素 :image：选取所有的图像按钮，返回集合元素 :reset：选取所有的重置按钮，返回集合元素 :button：选取所有的按钮，返回集合元素 :file：选取所有的上传域，返回集合元素 表单对象属性过滤选择器 :enabled：选取所有可用元素，返回集合元素 :disabled：选取所有不可用元素，返回集合元素 :checked：选取所有被选中的元素（单选框和多选框），返回集合元素 :selected：选取所有被选中的元素（下拉列表），返回集合元素 查找、设置、删除属性 attr()方法：接受一个或两个参数，一个参数是获取属性值，两个参数是设置属性,需要设置多个属性时，attr方法的参数可以是一个由属性和属性值组成的json数据格式 $(\"div\").attr(\"background\");//获取属性值$(\"div\").attr(\"background\",\"blue\");//设置属性值$(\"div\").attr(&#123;\"background\":\"blue\",\"height\":\"200px\"&#125;);//设置多个属性值 css()方法：接受一个或两个参数，当一个参数是属性名时，获取属性值，当两个参数时，设置属性第一个参数为属性名，第二个参数为属性值，需要设置多个属性时，css方法的参数可以是一个由属性和属性值组成的json数据格式 $(\"div\").css(\"background\");//获取属性值$(\"div\").css(\"background\",\"blue\");//设置属性值$(\"div\").css(&#123;\"background\":\"blue\",\"height\":\"200px\"&#125;);//设置多个属性值 另外width()方法和height()方法可以直接获取宽度和高度 addClass()：为元素添加class值，可批量添加属性与值 $(\"div\").addClass(\"myclass\"); removeAttr()：删除指定的属性 $(\"div\").removeAttr(\"background\"); removeClass()：有参数时，删除指定的class值，没有参数时，删除全部的class值 $(\"div\").removeClass(\"myclass\");$(\"div\").removeClass(); hasClass()：判断匹配的元素是否有某个class值，有则返回true，没有则返回false $(\"div\").hasClass(\"myclass\"); 创建元素、文本、属性节点 均可以直接将元素、文本、属性添加到$()方法中，如：var p=$(\"&lt;p title='mytitle'&gt;假装是标题&lt;/p&gt;\") 插入节点 append()：向元素内部添加节点，如：&lt;p&gt;我是内容&lt;/p&gt; $(\"p\").append(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果：&lt;p&gt;我是内容&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;/p&gt; appendTo()：将元素添加到指定元素内部，即将append方法中的链式操作的成员互换位置&lt;p&gt;我是内容&lt;/p&gt; $(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").appendTo(\"p\"); 结果：&lt;p&gt;我是内容&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;/p&gt; prepend()：向元素内部前置内容&lt;p&gt;我是内容&lt;/p&gt; $(\"p\").prepend(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果：&lt;p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt;我是内容&lt;/p&gt; prependTo()：将节点前置到指定元素中，即将prepend方法中的链式操作中的成员互换位置&lt;p&gt;我是内容&lt;/p&gt; $(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").prependTo(\"p\"); 结果：&lt;p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt;我是内容&lt;/p&gt; after()：在每个元素节点后添加节点&lt;p&gt;我是内容&lt;/p&gt; $(\"p\").after(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果：&lt;p&gt;我是内容&lt;/p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt; insertAfter()：讲节点插入到指定节点之后，即将after方法中的链式操作中的成员互换位置&lt;p&gt;我是内容&lt;/p&gt; $(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").insertAfter(\"p\"); 结果：&lt;p&gt;我是内容&lt;/p&gt;&lt;span&gt;我是追加的内容&lt;/span&gt; before()：再节点前面插入节点&lt;p&gt;我是内容&lt;/p&gt; $(\"p\").before(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\"); 结果：&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;p&gt;我是内容&lt;/p&gt; insertBefore()：将节点插入到指定元素前面&lt;p&gt;我是内容&lt;/p&gt; $(\"&lt;span&gt;我是追加的内容&lt;/span&gt;\").insertBefore(\"p\"); 结果：&lt;span&gt;我是追加的内容&lt;/span&gt;&lt;p&gt;我是内容&lt;/p&gt; 删除节点 remove()：从DOM中删除所有匹配的元素，同时该节点所包含的所有后代节点将同时被删除，因为返回值是删除节点的引用，因此可以在以后继续使用这些元素，但是此时这些节点所绑定的事件也会删除，如： var $li=$(\"ul li:eq(1)\").remove();//删除节点$li.appendTo(\"ul\");//将节点添加回去 detach()：和remove()几乎一样，不同的是detach方法不会删除节点所绑定的事件和附加的数据 empty()：清空所匹配的节点 $(\"ul li:eq(1)\").empty();//此时第一个li标签内无任何内容及节点了 复制节点 clone()：复制节点，可以有参数true，当有true参数时，将同时复制节点所绑定的事件，如：$(\"ul li:eq(1)\").clone(true).apppendTo(\"ul\"); 替换节点 replaceWith()：将匹配的节点替换成指定的节点 $(\"p\").replaceWith(\"&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;\"); replaceAll()：用指定的节点替换相应节点，即将replaceWith方法中的链式操作中的成员互换位置 $(\"&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;\").replaceAll(\"p\"); 包裹节点 wrap()：将匹配的节点用指定的节点单独包裹起来&lt;p&gt;我是内容&lt;/p&gt;&lt;p&gt;我是另一个内容&lt;/p&gt; $(\"p\").wrap(\"&lt;span&gt;&lt;/span&gt;\"); 结果：&lt;span&gt;&lt;p&gt;我是内容&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;p&gt;我是另一个内容&lt;/p&gt;&lt;/span&gt; wrapAll()：将匹配的节点用指定的节点全部包裹起来&lt;p&gt;我是内容&lt;/p&gt;&lt;p&gt;我是另一个内容&lt;/p&gt; $(\"&lt;span&gt;&lt;/span&gt;\").wrapAll(\"p\"); 结果：&lt;span&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;p&gt;我是另一个内容&lt;/p&gt;&lt;/span&gt; wrapInner()：将匹配的节点内部的节点或者文本内容用指定的节点包裹起来&lt;p&gt;我是内容&lt;/p&gt; $(\"p\").wrapInner(\"&lt;span&gt;&lt;/span&gt;\"); 结果：&lt;p&gt;&lt;span&gt;我是内容&lt;/span&gt;&lt;/p&gt; 设置、获取文本、HTML和值 html()：类似于原生JavaScript中的innerHTML属性，不含参数时是获取，包含元素节点和文本节点，当内有字符串参数时，是重新设置节点内容和文本内容 $(\"p\").html(); text()：类似于原生JavaScript中的innerText属性，不含参数时是获取文本节点，当内有字符串参数时，是重新设置文本内容 $(\"p\").text(\"我是内容\"); val()：类似于原生JavaScript中的value属性，可以用来获取和设置元素的值，无论是元素或者文本框，下拉列表或者单选框，如果元素是多选，则返回一个包含所有选择的值的数组 遍历节点 children()：获取所有的子元素集合，返回一个数组，只考虑直接子元素，不考虑其他后代元素&lt;div&gt; &lt;p&gt;我是内容 &lt;span&gt;我是内嵌的内容&lt;/span&gt; &lt;/p&gt; &lt;p&gt;我是另一个内容&lt;/p&gt;&lt;/div&gt; var $div = $(\"div\").children();$div.length;//返回2，不是3，只包含直接子元素，不包含span next()：获取匹配元素后面紧邻的一个同辈元素，效果类似于$(&quot;prev+next&quot;)&lt;div&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;h1&gt;我是另一个内容&lt;/h1&gt;&lt;/div&gt; var $h1=$(\"p\").next();//返回h1元素节点 prev()：获取匹配元素前面紧邻的一个同辈元素&lt;div&gt; &lt;h1&gt;我是另一个内容&lt;/h1&gt; &lt;p&gt;我是内容&lt;/p&gt;&lt;/div&gt; var $h1=$(\"p\").prev();//返回h1元素节点 siblings()：获取匹配元素的前后所有的同辈元素&lt;div&gt; &lt;h1&gt;我是另一个内容&lt;/h1&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;ul&gt;我是列表&lt;/ul&gt;&lt;/div&gt; var $h1=$(\"p\").next();//返回h1和ul元素节点集合 closest()：获取最近的符合匹配的一个父元素&lt;div&gt; &lt;div class=\"div2\"&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; var $div=$(\"p\").closest();//返回class为div2的div元素 parent()：获取一个父元素&lt;div&gt; &lt;div class=\"div2\"&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; var $div=$(\"p\").parent();//返回class为div2的div元素 parents()：获取所有匹配的一个祖先元素&lt;div&gt; &lt;div class=\"div2\"&gt; &lt;p&gt;我是内容&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; var $div=$(\"p\").parents();//返回两个div元素组成的数组 元素定位 offset()：获取元素在当前视窗的相对偏移，返回一个对象，对象包含top和left两个属性&lt;div&gt;我是内容&lt;/div&gt; var $offset=$(\"div\").offset();var left=$offset.left;var top=$offset.top; position()：获取元素相对于最近的一个position样式属性设置为relative或者absolute的祖父节点的相对偏移，返回一个对象，对象包含top和left两个属性&lt;div style=\"position:relative\"&gt; &lt;div&gt;&lt;p&gt;我是内容&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; var $position=$(\"p\").position();var left=$position.left;var top=$position.top; scrollTop()：获取元素的滚动条距离顶端的距离 scrollLeft()：获取元素的滚动条距离左侧的距离 加载DOM $(document).ready()：和原生的JavaScript的window.onload()方法有类似的功能，window.onload()方法是在网页中所有的元素（包括元素的所有关联文件）完全加载到浏览器后才执行，而$(docuemnt).ready()在DOM完全就绪时就可以被调用，此时并不意味着这些关联文件都已经下载完毕；另外，$(document).ready()可多次使用，而window.onload()只能用一次，多次使用时会出现覆盖的现象，另外其可以简写成$().ready(); 事件绑定 bind()：可以有三个参数，第一个参数是事件类型，第二个参数可选，作为event.data属性值传给事件对象的额外数据对象，第三个参数是处理函数 bind(type data fn); on()函数来绑定事件 常见的事件类型：blur、focus、load、resize、scroll、unload、click、dbclick、mousedown、mouseup、mouseover、mousemove、mouseout、mouseenter、mouseleave、change、select、submit、keydown、keyup、error另外，像click、mouseover、mouseout这类常用的事件，可以简写，如下： $(function()&#123; $(\"h1\").mouseover(function()&#123; $(this).next().show() &#125;).mouseout(function()&#123; $(this).next().hide() &#125;)&#125;) 合成事件jQuery中有两个合成事件——hover()和toggle()方法 hover()：用于模拟光标悬停事件，当光标移动到元素时，会触发第一个函数，离开时触发第二个函数，语法 hover(enter,leave); toggle()：用于模拟鼠标连续点击事件，语法 toggle(fn1,fn2,...,fn); 阻止事件之外的额外问题 停止事件冒泡：用stopPropagation()方法来停止事件冒泡，如： $(\"span\").bind(\"click\",function(event)&#123; //事件处理程序 event.stopPropagation()&#125;) 阻止默认行为：用preventDafault()方法来阻止默认行为，当然也可以用原生JavaScript中的return false，如： $(\"a\").bind(\"click\",function(event)&#123; //事件处理程序 event.preventDafault(); //或者return false;&#125;) 事件捕获：事件捕获与事件冒泡是刚好两个相反的过程，jQuery不支持事件捕获。 事件对象 添加事件对象非常简单，只需要为函数添加一个参数，一般会用event $(\"a\").bind(\"click\",function(event)&#123; //事件处理程序&#125;) event.type：获取事件的类型 $(\"a\").bind(\"click\",function(event)&#123; alert(event.type);&#125;) event.target：获取触发事件的对象元素 $(\"a\").bind(\"click\",function(event)&#123; alert(event.target.href);&#125;) event.pageX和event.pageY：获取光标相对于页面的x坐标和y坐标 $(\"a\").bind(\"click\",function(event)&#123; alert(event.pageX); alert(event.pageY);&#125;) event.which：在鼠标单击时获取到鼠标的左、中、右键；在键盘事件中获取到键盘的按键 $(\"a\").mousedown(function(event)&#123; alert(event.which);&#125;)$(\"a\").keyup(function(event)&#123; alert(event.which);&#125;) event.metaKey：在键盘事件中获取ctrl按键 移除事件 unbind()：没有参数时，删除所有的绑定事件，可以有两个参数，第一个参数是事件类型，第二个参数是将要移除的函数，提供了事件类型，则只删除该事件类型，提供了事件处理函数，则只有这个事件处理函数会被删除，语法结构如下 unbind(type,data)$(\"a\").click(function()&#123; $(\"#btn\").unbind(\"click\",fn1);&#125; 另外，对于只需要触发一次随后就立即解除绑定的情况，jQuery提供了one()方法，这个方法可以为元素绑定处理函数，当函数触发一次后，立即被删除 事件的其他用法 模拟操作：trigger()：此方法可以模拟操作，例如$(\"#btn\").triggle(\"click\")； 这段代码可以触发id为btn的按钮的click事件，trigger()方法会触发浏览器的默认事件，如果不想执行浏览器的默认操作，可以使用jQuery中的另一个方法triggerHandler()方法 绑定多个事件类型：bind可以为元素绑定多个事件类型$(function()&#123; $(\"div\").bind(\"mouseover mouseout\",function()&#123; $(this).toggleClass(\"over\"); &#125;);&#125;) 这段代码效果和下方代码一样$(function()&#123; $(\"div\").bind(\"mouseover\",function()&#123; $(this).toggleClass(\"over\"); &#125;).bind(\"mouseout\",function()&#123; $(this).toggleClass(\"over\")； &#125;);&#125;) 动画 show()和hide()：这两个是jQuery中的最基本的动画，当这两个方法不含参数时，效果类似于直接将元素的display属性分别改为block和none，这两个方法当有参数时，可以使元素慢慢显示出来，速度关键字有slow、normal、fast，此外，还可以直接指定一个数字作为显示的时间参数，单位为毫秒，其中slow的显示时间为600毫秒，normal的显示时间为400毫秒，fast的显示时间为200毫秒，这两个方法是同时改变元素的高度、宽度和不透明度 $(\"p\").toggle(function()&#123; $(this).next().hide(600);&#125;,function()&#123; $(this).next().show(600);&#125;) fadeIn()和fadeOut()：这两个函数只改变元素的不透明度，同样可以有以上的速度参数 $(\"p\").toggle(function()&#123; $(this).next().fadeOut();&#125;,function()&#123; $(this).next().fadeIn(600);&#125;) slideUp()和slideDown()：这两个方法只改变元素的高度，slideDown()方法使元素由上到下延伸展示，而slideUp()方法使元素从下到上缩短隐藏，同样有上述的时间参数 $(\"p\").toggle(function()&#123; $(this).next().slideUp();&#125;,function()&#123; $(this).next().slideDown(600);&#125;) toggle()：切换元素的可见状态，如果元素可见，则切换为隐藏，如果元素隐藏，则切换为可见 toggle(speed,callback);$(this).next().toggle(); 效果和hide()和show()方法类似 slideToggle()：通过高度来切换元素的可见性 slideToggle(speed,easing,callback); fadeTo()：把元素的不透明度以渐进的方式调整到指定的值，这个动画只调整元素的不透明度 fadeTo(speed,opacity,callback)$(this).fadeTo(100,0.3); fadeToggle()：通过不透明度来切换元素的可见性 fadeToggle(speed,easing,callback); animate()：自定义动画 animate(params,speed,callback);params：一个包含样式属性及值的映射，如：&#123;left:\"400px\",height:\"500px\"&#125;speed：速度参数，可选callback：在动画完成后执行的函数，可选 animate可以添加累加与累减动画，如： $(function()&#123; $(\"p\").click(function()&#123; $(this).animate(&#123;left:\"+=500px\"&#125;,300) &#125;);&#125;); 利用animate中的第一个参数很容易实现同时执行多个动画的效果，而需要按顺序执行动画，只需要顺序写animate动画即可，另外也可以使用链式操作 $(this).animate(&#123;left:\"500px\"&#125;,300);$(this).animate(&#123;height:\"500px\"&#125;,300); 等效于$(this).animate(&#123;left:\"500px\"&#125;,300).animate(&#123;height:\"500px\"&#125;,300); 判断元素是否处于动画状态if(!$(\"p\").is(\":animated\"))&#123; //没有处于动画状态时执行的程序&#125; 延迟动画 延迟动画利用delay()方法$(this).animate(&#123;left:\"500px\"&#125;,200).delay(1000); Tipsaria-expanded=&quot;false&quot; aria-expanded表示展开状态。默认为undefined, 表示当前展开状态未知。其它可选值：true表示元素是展开的；false表示元素不是展开的 aria-hidden字符串 可选值为true和false，true表示元素隐藏(不可见)，false表示元素可见 快捷键 Ctrl + Enter 光标不在末尾回车 Ctrl + Backspace 删除一个词 Ctrl + -&gt; 以词为单位后移 col-xs-n中放图片不生效img &#123; display: block; max-width: 100%;&#125; display block 默认，此元素将显示为块级元素，此元素前后会带有换行符 inline 此元素会被显示为内联元素，元素前后没有换行符 inline-block 行内块元素 使用col就要在母元素上清除浮动，因为col栅格也是浮动的使用flag覆盖叠加新的属性 css中使用.side-bar-card.flag {}来调用 html中用&lt;div class=&quot;side-bar-card flag clearfix&quot;&gt; a标签链接不带下划线，并列换行写a,a:hover,a:visited,a:link,a:active &#123; text-decoration: none;&#125; line-heigh不要写px表格居中&lt;table align=\"center\"&gt; bootstrap响应式表格&lt;div class=\"table-responsive\"&gt; 表格内容水平垂直居中&lt;!-- 水平居中 --&gt;&lt;th style='text-align: center;'&gt;host&lt;/th&gt;&lt;!-- 垂直居中 --&gt;&lt;td rowspan=$row_host1 style='vertical-align: middle;'&gt;host1&lt;/td&gt;&lt;!-- 既水平又垂直居中 --&gt;&lt;td rowspan=$rowspan style='vertical-align: middle;text-align: center;'&gt;hello&lt;/td&gt; 图片撑满background-size: cover; input/select/textarea/... + .form-control.form-group 单独的表单控件会被自动赋予一些全局样式。所有设置了.form-control类的&lt;input&gt;、&lt;textarea&gt;和&lt;select&gt;元素都将被默认设置宽度属性为width: 100%;。将label元素和前面提到的控件包裹在.form-group中可以获得最好的排列 响应式表格 将任何.table元素包裹在&lt;div class=&quot;table-responsive&quot;&gt;元素内 垂直方向的内容截断 响应式表格使用了overflow-y: hidden属性，这样就能将超出表格底部和顶部的内容截断。特别是，也可以截断下拉菜单和其他第三方组件 .form-inline 输入框和单选/多选框控件默认被设置为width: 100%;。在内联表单，我们将这些元素的宽度设置为width: auto;，因此，多个控件可以排列在同一行。根据布局需求，手动设置宽度 一定要添加label标签，对于内联表单，可以通过为label设置.sr-only类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如aria-label、aria-labelledby或title属性 .form-horizontal 无需再添加.row了 margin对span无效display: block;line-height: 1.5; button后退&lt;button class=\"btn btn-danger ycx\" onclick=\"javascript :history.back(-1);\"&gt;返回&lt;/button&gt; 居中 文本内容居中：text-center 图片居中：center-block 其他类型元素居中：col-md-offset-X 在form标签上加novalidate属性，可以禁用h5默认的表单验证效果div置顶的方法position: relative;z-index: 99999; margin:auto实现绝对定位元素的居中.element &#123; width: 600px; height: 400px; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;&#125; ajax中dataType为预期服务器返回的数据类型，不写有默认值，开发过程中不要写ajax表单序列化传输$(\"#submit\").on('touchstart', function () &#123; var form = $(\"#handouts\").serialize(); $.ajax(&#123; url: 'http://192.168.1.111:8686/EAnnotation/addPassage', type: \"post\", data: form, cache: false, success: function (data) &#123; window.location.href = \"course.html\" &#125;, error: function (e) &#123; &#125; &#125;) return false; &#125;); ajax表单传递键值对$(\"#submit\").on('touchstart', function () &#123; var form = new FormData($('#homework')[0]); $.ajax(&#123; url: 'https://bitcandy.one/EAnnotation/addPassage', type: 'POST', cache: false, data: form, processData: false, contentType: false, success: function (data) &#123; window.location.href = \"classteacher.html\" console.log(form); &#125;, error: function (e) &#123; &#125; &#125;) return false;&#125;); ajax拿到json后如何使用$.ajax(&#123; url: 'http://192.168.1.111:8686/EAnnotation/getAllPassages', type: \"post\", cache: false, success: function (data) &#123; console.log(data); $.each(data, function (i, item) &#123; var time = getDateDiff(item.releaseTime); if (item.photo) &#123; &#125; else &#123; $(\"ul[class=index]\").append( `&lt;div class=\"card\"&gt; &lt;div class=\"card-header\"&gt;` + item.title + `&lt;/div&gt; &lt;div class=\"card-content card-content-padding\"&gt; &lt;p class=\"date index\"&gt;` + item.theme + `·` + time + `&lt;/p&gt; &lt;a href=\"www.baidu.com\" class=\"link\" style=\"color: black\"&gt;&lt;p style=\"margin-top: 0; margin-bottom: 0;\"&gt;` + getcontent(item.content).substring(0, 70) + ` ...&lt;/p&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class=\"card-footer\"&gt; &lt;a href=\"#\" class=\"link\" style=\"color\"&gt; &lt;i class=\"f7-icons size-18\"&gt;heart_fill&lt;/i&gt;` + 1 + `喜欢&lt;/a&gt; &lt;a href=\"#\" class=\"link\"&gt; ` + 22 + `人批注过，共计` + 44 + `条批注 &lt;/a&gt; &lt;/div&gt; &lt;/div&gt;` ) &#125; &#125;) &#125;, error: function (e) &#123; &#125; &#125;) 多行文字限制字数显示....text_overflow&#123; /* width:27rem; */ display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; overflow: hidden;&#125; 单行文字限制字数显示....text_overflow&#123; width:27em; white-space:nowrap; text-overflow:ellipsis; -o-text-overflow:ellipsis; overflow:hidden;&#125; 从html代码中获取纯文本函数function getcontent(text) &#123; var html = text; return html.replace(/&lt;[^&gt;]*&gt;|/g, \"\");&#125; 时间戳转化函数// 2014-05-08 00:22:11function getDateDiff(dateTimeStamp) &#123; var dateTimeStamp = new Date(Date.parse(dateTimeStamp.replace(/-/g, \"/\"))); dateTimeStamp = dateTimeStamp.getTime(); var result; var minute = 1000 * 60; var hour = minute * 60; var day = hour * 24; var halfamonth = day * 15; var month = day * 30; var now = new Date().getTime(); var diffValue = now - dateTimeStamp; if (diffValue &lt; 0) &#123; return; &#125; var monthC = diffValue / month; var weekC = diffValue / (7 * day); var dayC = diffValue / day; var hourC = diffValue / hour; var minC = diffValue / minute; if (monthC &gt;= 1) &#123; if (monthC &lt;= 12) result = \"\" + parseInt(monthC) + \"个月前\"; else &#123; result = \"\" + parseInt(monthC / 12) + \"年前\"; &#125; &#125; else if (weekC &gt;= 1) &#123; result = \"\" + parseInt(weekC) + \"周前\"; &#125; else if (dayC &gt;= 1) &#123; result = \"\" + parseInt(dayC) + \"天前\"; &#125; else if (hourC &gt;= 1) &#123; result = \"\" + parseInt(hourC) + \"小时前\"; &#125; else if (minC &gt;= 1) &#123; result = \"\" + parseInt(minC) + \"分钟前\"; &#125; else &#123; result = \"刚刚\"; &#125; return result;&#125;; js变量生命周期 全局变量 var n=999;function f1()&#123; alert(n);&#125;f1(); // 输出999,说明全局变量n在函数内部被读取 函数中的全局变量：在函数内部声明变量没有使用var，实际上是声明了一个全局变量，前提是需要先调用函数 var func1 = function()&#123; a1 = 1; console.log(a1); //输出:1 function func2() &#123;//func2()是一个闭包 a2 = 2; console.log(a2); &#125; func2()；//闭包函数中的变量在调用函数之后，变量也是全局变量 console.log(a2);//输出2&#125;;func1();//调用函数，才会使变量生效console.log(a1);//输出1console.log(a2);//输出2，说明闭包中没有用var声明的变量也是全局变量。 局部变量：在函数内部声明的变量。函数内部的变量，外部无法读取。 function f1()&#123; var n=999;&#125;alert(n); // 没有定义，说明函数内部的变量，外部无法读取。 JavaScript解释器在执行脚本时，是按块来执行的。通俗地说，就是浏览器在解析HTML文档流时，如果遇到一个&lt;script&gt;标签，则JavaScript解释器会等到这个代码块都加载完后，先对代码块进行预编译，然后再执行。执行完毕后，浏览器会继续解析下面的HTML文档流，同时JavaScript解释器也准备好处理下一个代码块。由于JavaScript是按块执行的，所以如果在一个JavaScript块中调用后面块中声明的变量或函数就会提示语法错误。虽然说，JavaScript是按块执行的，但是不同块都属于同一个全局作用域，也就是说，块之间的变量和函数是可以共享的。 jquery获取radio被选中的值 三种方法都可以$('input:radio:checked').val()；$(\"input[type='radio']:checked\").val();$(\"input[name='rd']:checked\").val(); jquery获取select被选中的值 获取选中项的value值 $('select#sel option:selected').val();或者$('select#sel').find('option:selected').val(); 获取选中项的text值 $('select#seloption:selected').text();或者$('select#sel').find('option:selected').text(); 获取当前选中项的索引值 $('select#sel').get(0).selectedIndex; jquery获取checkbox被选中的值 获取单个checkbox选中项 $(\"input:checkbox:checked\").val() 或者 $(\"input:[type='checkbox']:checked\").val(); 或者 $(\"input:[name='ck']:checked\").val(); 获取多个checkbox选中项 $(\"input[name='favour']:checked\").each(function () &#123; alert($(this).val());&#125;); jquery获取span和input的值$(\"span\").html();$(\"input\").val(); jquery数组对象获取value值 需将数组对象再次封装为jquery对象// 错误$(\"input[name='jQueryArray']\")[0].val();// 正确$($(\"input[name='jQueryArray']\")[0]).val();0 this必须用$包装成JQuery对象才能使用用let和const的声明可以产生块级作用域，解决闭包循环事件绑定for (var i = 0; i &lt; 2; i++) &#123; let ii = i; //const也可以，块级作用域 var bt = document.getElementById('bt'+ii); bt.onclick = function()&#123; console.log(ii); &#125;; &#125; JavaScript中有5种简单数据类型（也称为基本数据类型）： Undefined、Null、Boolean、Number和String 。还有1种复杂数据类型—— Object ，Object本质上是由一组无序的名值对组成的。https://www.cnblogs.com/signheart/p/3ca2afaca43d2dc69ce72c862a3ae81c.html https://www.nowcoder.com/questionTerminal/9d9d07ca445a461cbee95fc091d8751a?orderByHotValue=2&amp;page=1&amp;onlyReference=false https://www.cnblogs.com/jf-67/p/6476967.html https://blog.csdn.net/chenpeng19910926/article/details/50826099 https://blog.csdn.net/lyliyangzi/article/details/76167377 https://www.cnblogs.com/jiaozhuo/p/5751002.html backgroundColor,，要加.style，属性设置元素的背景颜色。bgcolor不用加.style json中key也是个字符串，要加引号。key和value之间是用：号来表示的 CSS样式表和选择器CSS和HTML结合的三种方式：行内样式表、内嵌样式表、外部样式表CSS四种基本选择器：标签选择器、类选择器、ID选择器、通用选择器CSS几种扩展选择器：后代选择器、交集选择器、并集选择器、伪类选择器","tags":[{"name":"前端","slug":"前端","permalink":"https://kxbk100.github.io/tags/前端/"}]},{"title":"","date":"2018-06-29T02:42:22.004Z","path":"2018/06/29/note/","text":"Note 电子书：做注释，同步 教材：划出重点，手写分栏整理 课外纸质书：划出重点，建markdown 橱窗次序 X修改 15的考研情况 潘中祥 论文数量 岑岳峰 发布文章的web（教师、学生），发布时进行敏感词检查，发送成功，我的 + 我发布的文章 首页搜索功能 定位：所有学生，班级（中学），群组（大学） 群组文章列表 群组id列表、班级id列表 批注类型的名字修改：下划线、高亮等 剪视频 文章的来源：教师+普通用户 文章的类别：20个左右，文章的内容不限，数据集路透社的研究 如何创建群组，如何加入群组；如何创建班级，如何加入班级暂时静态化 E-mail: susanf@cinnamonhotels.com Dear Ms. Susan Fernando,I am a participant of The 13th International Conference on Computer Science &amp; Education (ICCSE 2018) from China. And there will be three people attend the conference totally. I want to book a double-bed room and a single room starting from 7th August,2018 up to 10th August,2018 and including the night of 7th August,2018 and 10th August,2018. Please inform me the discount and price details. Thank you!Best regardsFeng Tianxiang Dear Ms. Susan Fernando,As for accommodation, our organization has a ceiling of $110 per person per day. Will you give me more discount for the single room? Thank you!Best regardsFeng Tianxiang Dear Ms. Susan Fernando,However, ICCSE 2018 will be held during August 8-11, 2018. I’ve seen there’s special discounted rate for ICCSE 2018, but the price you gave to me before is exactly the price in the official website. In other words, I haven’t got the discount which you’ve promised for the ICCSE 2018 participants. How can we get the discount? Thank you!Best regardsFeng Tianxiang Dear Ms. Susan Fernando,I am a participant of ICCSE 2018 from China. And there will be three people attend the conference totally. Please reserve for me a double-bed room and a single room starting from 7th August,2018 up to 10th August,2018 and including the night of 7th August,2018 and 10th August,2018, a total of 4 nights. Please confirm this reservation as soon as possible.Note:Single room: US$ 125/- Nett per single room on BB basis per night.Double-bed room: US$ 135/- Nett per room per night on BB basis.Best regardsFeng Tianxiang 前端学习路线 Sass NPM 本人热爱社会主义祖国，热爱教育事业，实事求是，自觉陶冶人生观、价值观、世界观，作风正派，廉洁从教，为人师表，有强烈的事业心和高度的责任感。本人热爱学校，关心学生，服从学校工作安排，与同事团结协作，工作尽心尽责，态度端正，努力完成学校交给的各项工作任务。本人政治立场端正，未参与法轮功等非法组织，无不良记录及处分。 该生在校期间在各方面表现积极，勇于进取。在学习上，该生学习成绩优秀，名列前茅。该生善于理论联系实际，常常参加老师的科研项目。在学生工作上，热爱学校，立场端正，关心集体，工作认真负责，做好学生的表率，努力完成学校交给的各项任务，被评为校“十佳团支部书记”。在生活上，该生勤俭节约，乐于助人，与同学关系较好，乐于帮助同学。该生政治立场端正，未参与法轮功等非法组织，无违法乱纪和处分等不良记录。故同意该生出国参加会议。 Dear Ms. Susan Fernando, I am a participant of ICCSE 2018 from China. And there will be three people attend the conference totally. Please confirm this reservation as soon as possible. Prof. CEN Gang : Aug.7-Aug.11 (4 nights) Premium Room with breakfastBS. FENG Tianxiang: Aug.7-Aug.11 (4 nights) Superior Room with double beds and breakfastBS. XU Zengwei: Aug.7-Aug.11 (4 nights) Room with FENG Tianxiang and with breakfast Best regards Feng Tianxiang","tags":[]},{"title":"Axure学习小记","date":"2018-01-14T12:30:33.000Z","path":"2018/01/14/Axure学习小记/","text":"按住Ctrl时，可以旋转按住Ctrl时，拖动曲线右键转换曲线的类型","tags":[{"name":"Axure","slug":"Axure","permalink":"https://kxbk100.github.io/tags/Axure/"}]},{"title":"【构建之法】 第4章 两人合作","date":"2017-12-11T16:46:29.000Z","path":"2017/12/12/【构建之法】-第4章-两人合作/","text":"代码风格规范 4个空格的缩进 每个{}独占一行 不要把多个变量定义在一行上 一个类型的成员变量用m_name来命名 Pascal：所有的类型/类/函数名 lowerCamel：变量 注释是为了解释程序做什么（What），为什么这么做（Why），以及要特别注意的地方，只用ASCII字符，不要用中文 代码设计规范 函数：只做一件事，并且要做好 单一出口 不要在构造函数中做复杂的操作，简单初始化所有的数据成员即可 代码复审 看代码是否在代码规范的框架内正确地解决了问题 长远的问题 这么修改之后，有没有别的功能会受影响 项目中还有别的地方需要类似的修改吗 有没有留下足够的说明，让将来维护代码时不会出现问题 对于这样的修改，有没有别的成员需要告知 导致问题的根本原因是什么？我们以后如何能自动避免这样的情况再次出现 代码复审的核查表","tags":[{"name":"构建之法","slug":"构建之法","permalink":"https://kxbk100.github.io/tags/构建之法/"}]},{"title":"【构建之法】 第3章 软件工程师的成长","date":"2017-12-07T16:10:38.000Z","path":"2017/12/08/【构建之法】-第3章-软件工程师的成长/","text":"软件工程师的成长 积累软件开发相关的知识，提升技术技能 积累问题领域的知识和经验 对通用的软件设计思想和软件工程思想的理解 提升职业技能 实际成果 软件工程师的思维思维误区分析麻痹不分主次，想解决所有依赖问题过早优化过早扩大化/泛华 画扇面——调侃目标和远景 技能的反面 通过不断的练习，把低层次的问题解决，变成不用经过大脑的自动操作，然后才有时间和脑力来解决较高层次的问题","tags":[{"name":"构建之法","slug":"构建之法","permalink":"https://kxbk100.github.io/tags/构建之法/"}]},{"title":"【构建之法】 第2章 个人技术和流程","date":"2017-12-07T14:44:01.000Z","path":"2017/12/07/【构建之法】-第2章-个人技术和流程/","text":"单元测试单元测试回归测试 回退操作 效能分析工具 先用抽样的方法找到效能瓶颈所在，然后对特定的模块用代码注入的方法进行详细分析 个人开发流程任务清单 计划 明确需求和其他相关因素，指明时间成本和依赖关系 开发 分析需求 生成设计文档 设计复审（和同事审核设计文档） 代码规范（为目前的开发定制合适的规范） 具体设计 具体编码 代码复审 测试（包括自测，修改代码，提交修改） 记录用时 报告 测试报告 计算工作量 事后总结 提出过程改进计划 软件设计的原则单一职责原则 一个模块（类）应该只有一个导致它变化的原因，一个模块应该完全对某个功能负责 开放-封闭原则 允许拓展。当应用的需求发生改变时，我们可以对模块进行拓展，从而改变模块的功能 不允许修改。对模块行为进行拓展时，不必改变模块的本身 程序的健壮性数据 属性拓展 超过64位的数字 数量拓展 十万条数据 维度拓展 多维数组 其他属性拓展 需求 形象的显示数据处理的过程 维度拓展 数量拓展 增量改进 用户 让用户更喜欢这个软件 记住上次的状态 自动展现上次文档最后编辑的地方 多用户 多语言 安全性 软件构建 平台的迁移 多语言接口 增量升级部分模块 实践工作的细分 基本功能 拓展功能 高级功能 如何保证质量——回归测试 保证在加入新功能的过程中，已有的功能可继续工作，我们需要建立起一系列测试文件","tags":[{"name":"构建之法","slug":"构建之法","permalink":"https://kxbk100.github.io/tags/构建之法/"}]},{"title":"ThinkPHP学习小记","date":"2017-11-28T08:32:00.000Z","path":"2017/11/28/ThinkPHP学习小记/","text":"ID不从1开始 truncate table 你的表名 无法访问 可能保存了带bom的utf编码 部署到iis服务器 将runtime设定到支持写入的目录 数据不为空显示&lt;!-- 不等于 --&gt;&lt;if condition=\"$result[0]['jiyao_id'] neq null\"&gt; &lt;tr&gt; &lt;td style=\"vertical-align: middle;text-align:center;width: 20%\"&gt; &lt;span&gt;&lt;b&gt;机要编号&lt;/b&gt;&lt;/span&gt; &lt;/td&gt; &lt;td class=\"description\"&gt;&#123;$result[0]['jiyao_id']&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/if&gt; 1 0转换&lt;!-- 字符串用'' --&gt;&lt;if condition=\"$student.is_searched eq 1\"&gt;已查询&lt;else/&gt;未查询&lt;/if&gt;&lt;/td&gt;","tags":[{"name":"PHP","slug":"PHP","permalink":"https://kxbk100.github.io/tags/PHP/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"https://kxbk100.github.io/tags/ThinkPHP/"},{"name":"MySQL","slug":"MySQL","permalink":"https://kxbk100.github.io/tags/MySQL/"}]},{"title":"Hexo使用心得","date":"2017-11-27T17:31:00.000Z","path":"2017/11/28/Hexo使用心得/","text":"新建文章 hexo new &quot;Hexo使用心得&quot; 上传图片到github并使用 将_config.yml中有的post_asset_folder设置为true 在hexo的目录下执行npm install https://github.com/CodeFalling/hexo-asset-image --save 完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹 使用![test](Hexo使用心得/test.jpg)就可以插入图片。其中[]里面不写文字则没有图片标题 Hexo-admin 本地的文章编辑器，不支持在线/admin访问，github.io都是静态界面 更新文章 hexo d -g","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://kxbk100.github.io/tags/Hexo/"}]},{"title":"Java学习小记","date":"2017-11-25T03:50:20.000Z","path":"2017/11/25/Java学习小记/","text":"ScannerScanner s = new Scanner(System.in);// 使用hasNextXxx()方法进行验证，再使用nextXxx()来读取// next()// next() 不能得到带有空格的字符串import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 //next方式接收字符串 System.out.println(\"next方式接收：\"); // 判断是否还有输入 if(scan.hasNext())&#123; String str1 = scan.next(); System.out.println(\"输入的数据为：\"+str1); &#125; &#125; &#125;// nextLine()// 以Enter为结束符，可以获得空白import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 //nextLine方式接收字符串 System.out.println(\"nextLine方式接收：\"); // 判断是否还有输入 if(scan.hasNextLine())&#123; String str2 = scan.nextLine(); System.out.println(\"输入的数据为：\"+str2); &#125; &#125; &#125;scanner.close(); 数组大小用size()students.size(); 数组访问用get()temp = students.get(i); 数组修改用set()students.set(i, stu); for的遍历// 打印所有学生的信息public void displayAllStudent() &#123; if (students.size() &gt; 0) &#123; for (Student stu : students) &#123; System.out.println(\"学号: \" + stu.getSno() + \"\\t姓名: \" + stu.getSname() + \"\\t系部: \" + stu.getSdept()); &#125; &#125;else &#123; System.out.println(\"数据库中无学生记录!\"); &#125;&#125; 读取文件// 读取文件获得原始数据private void getData() &#123; try &#123; FileReader in_ = new FileReader(\"StudentDAO.txt\"); BufferedReader in = new BufferedReader(in_); String line; String reg1 = \"\\\\s+\"; String str[] = new String[3]; while ((line = in.readLine()) != null) &#123; Student temp = new Student(); str = line.split(reg1); temp.setSno(str[0]); temp.setSname(str[1]); temp.setSdept(str[2]); students.add(temp); &#125; in.close(); &#125; catch (IOException e) &#123; System.out.println(e); &#125;&#125; 写入文件//更新数据库,把数据输入文件private void updateData() &#123; try &#123; FileWriter out_ = new FileWriter(\"StudentDAO.txt\"); BufferedWriter out = new BufferedWriter(out_); Student temp = new Student(); for (int i = 0; i &lt; students.size(); i++) &#123; temp = students.get(i); out.write(temp.getSno() + \" \" + temp.getSname() + \" \" + temp.getSdept() + \"\\r\\n\"); &#125; out.close(); &#125; catch (IOException e) &#123; System.out.println(e); &#125;&#125; BufferedReaderdo &#123; // 从输入流读取一个字符并把该字符作为整数值返回， 当流结束的时候返回 -1 c = (char)br.read(); System.out.println(c);&#125; while (c != 'q');do &#123; str = br.readLine(); System.out.println(str);&#125; while(!str.equals(\"end\")); FileInputStream（从文件读取数据）InputStream f = new FileInputStream(\"C:/java/hello\");File f = new File(\"C:/java/hello\");InputStream out = new FileInputStream(f); FileOutputStream（向文件中写数据）OutputStream f = new FileOutputStream(\"C:/java/hello\")File f = new File(\"C:/java/hello\");OutputStream f = new FileOutputStream(f); 读取写入流最后都要close();读写一定要用bytebyte bWrite[] = &#123; 11, 21, 3, 40, 5 &#125;;byte bWrite[] = \"zhouzhiwenishandsome\".getBytes();","tags":[{"name":"Java","slug":"Java","permalink":"https://kxbk100.github.io/tags/Java/"}]},{"title":"JavaScript学习小记","date":"2017-11-25T03:50:00.000Z","path":"2017/11/25/JavaScript学习小记/","text":"二级联动&lt;!DOCTYPE&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;二级联动&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form&gt; &lt;select name=\"province \" id=\"province \" onchange=\"getCity() \"&gt; &lt;option value=\"0 \"&gt;请选择所在省份&lt;/option&gt; &lt;option value=\"直辖市 \"&gt;直辖市&lt;/option&gt; &lt;option value=\"江苏省 \"&gt;江苏省&lt;/option&gt; &lt;option value=\"福建省 \"&gt;福建省&lt;/option&gt; &lt;option value=\"广东省 \"&gt;广东省&lt;/option&gt; &lt;option value=\"甘肃省 \"&gt;甘肃省&lt;/option&gt; &lt;/select&gt; &lt;select id=\"city \" name=\"city \"&gt; &lt;option value=\"0 \"&gt;请选择所在城市&lt;/option&gt; &lt;/select&gt; &lt;/form&gt; &lt;script&gt; //定义城市数据 var city = [ [\"北京\", \"天津\", \"上海\", \"重庆\"], [\"南京\", \"苏州\", \"南通\", \"常州\"], [\"福州\", \"福安\", \"龙岩\", \"南平\"], [\"广州\", \"潮阳\", \"潮州\", \"澄海\"], [\"兰州\", \"白银\", \"定西\", \"敦煌\"] ]; var value = [ [\"Beijing\",\"Tianjing\",\"Shanghai\",\"Chongqing\"], [\"Nanjing\",\"Suzhou\",\"Nantong\",\"Changzhou\"], [\"Fuzhou\",\"Fuan\",\"Longyan\",\"Nanping\"], [\"Guangzhou\",\"Chaoyang\",\"Chaozhou\",\"Chenghai\"], [\"Lanzhou\",\"Baiyin\",\"Dingxi\",\"Dunhuang\"] ]; //选择省下拉框改变时触发 function getCity() &#123; //得到省下拉框dom var sltProvince = document.getElementById(\"province\"); //得到市下拉框dom var sltCity = document.getElementById(\"city\"); //得到指定市的数据通过选择的省的index（index-1是为了排除，请选择省的option） var provinceCity = city[sltProvince.selectedIndex - 1]; var provinceValue = value[sltProvince.selectedIndex - 1]; //要调试才知道什么意思 sltCity.length = 1; //动态给城市下拉框加数据(加&lt;option value='测试'&gt;测试&lt;option/&gt;) for (var i = 0; i &lt; provinceCity.length; i++) &#123; sltCity[i + 1] = new Option(provinceCity[i], provinceValue[i]); &#125; &#125; // 修改的时候既传值又联动，函数后面不需要括号 window.onload = getCity; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://kxbk100.github.io/tags/JavaScript/"}]},{"title":"HTML+CSS学习小记","date":"2017-11-25T03:42:20.000Z","path":"2017/11/25/HTML+CSS学习小记/","text":"Bootstrap引入&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-CN\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;贴吧后台管理页面&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"../css/bootstrap.min.css\"&gt; &lt;script src=\"../js/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"../js/bootstrap.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 页眉 --&gt; &lt;header&gt; &lt;!-- 导航条部分 --&gt; &lt;nav&gt; ... &lt;/nav&gt; &lt;/header&gt; &lt;!-- 主要内容 --&gt; &lt;div class=\"container\"&gt; &lt;div class=\"row\"&gt; &lt;!-- 左侧目录 --&gt; &lt;div class=\"col-xs-12 col-sm-2 col-md-2 col-lg-2\"&gt; ... &lt;/div&gt; &lt;!-- 右侧主要内容 --&gt; &lt;div class=\"col-xs-12 col-sm-10 col-md-10 col-lg-10\"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 页尾 --&gt; &lt;footer&gt; ... &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt; 制作一个页面的流程 引入框架 实现页面布局代码 构建导航的整体架构 设计标题和导航链接 设计搜索框和通知系统 设置管理员登录系统 设计响应式导航 左侧边栏设计 页面主体设计 span1/2/3/4ul.unstyledul.inline描述 &lt;dl&gt; &gt; &lt;dt&gt; &gt; &lt;dd&gt;响应式导航条Glyphicons &lt;span&gt;或者&lt;a&gt;动态模态对话框滚动监听工具提示框弹出框状态按钮 加载中… 折叠幻灯视频响应式&lt;div class=\"embed-responsive embed-responsive-16by9\"&gt; &lt;iframe class=\"embed-responsive-item\" src=\"iqiyi.catilog2015/24551221.swf\"&gt;&lt;/iframe&gt;&lt;/div&gt; 扁平化风格页面各种风格的按钮jQuery插件 DataTables响应式表格 支持及时分页、搜索、排序 Json、数组、Ajax 可视化图表EChartsjQuery UI Bootstrap工具aria-expanded=”false” aria-expanded表示展开状态。默认为undefined, 表示当前展开状态未知。其它可选值：true表示元素是展开的；false表示元素不是展开的。 aria-hidden字符串 可选值为true和false,true表示元素隐藏(不可见)，false表示元素可见。 快捷键 Ctrl+Shift+Enter 在上一行另起一行 Ctrl+Enter 光标不在末尾回车 Ctrl+Backspace 删除一个词 col-xs-n中放图片不生效img &#123; display: block; max-width: 100%;&#125; display block 此元素将显示为块级元素，此元素前后会带有换行符 inline 默认。此元素会被显示为内联元素，元素前后没有换行符| inline-block 行内块元素。（CSS2.1 新增的值） 使用col就要在母元素上清除浮动，因为col栅格也是浮动的使用flag覆盖叠加新的属性 css中使用.side-bar-card.flag {}来调用 html中用&lt;div class=&quot;side-bar-card flag clearfix&quot;&gt; a标签链接不带下划线，并列换行写a,a:hover,a:visited,a:link,a:active &#123; text-decoration: none;&#125; line-heigh不要写px表格居中&lt;table align=\"center\"&gt; bootstrap响应式表格&lt;div class=\"table-responsive\"&gt; 表格内容水平垂直居中&lt;th style='text-align: center;'&gt;host&lt;/th&gt; 水平居中&lt;td rowspan=$row_host1 style='vertical-align: middle;'&gt;host1&lt;/td&gt; 垂直居中&lt;td rowspan=$rowspan style='vertical-align: middle;text-align: center;'&gt;hello&lt;/td&gt; 既水平又垂直居中 图片撑满background-size: cover; input/select/textarea/… + .form-control.form-group 单独的表单控件会被自动赋予一些全局样式。所有设置了.form-control类的&lt;input&gt;、&lt;textarea&gt;和&lt;select&gt;元素都将被默认设置宽度属性为width: 100%;。将label元素和前面提到的控件包裹在.form-group中可以获得最好的排列 响应式表格 将任何.table元素包裹在&lt;div class=&quot;table-responsive&quot;&gt;元素内 垂直方向的内容截断 响应式表格使用了overflow-y: hidden属性，这样就能将超出表格底部和顶部的内容截断。特别是，也可以截断下拉菜单和其他第三方组件 .form-inline 输入框和单选/多选框控件默认被设置为 width: 100%; 宽度。在内联表单，我们将这些元素的宽度设置为 width: auto;，因此，多个控件可以排列在同一行。根据布局需求，手动设置宽度 一定要添加label标签，对于内联表单，可以通过为label设置.sr-only类将其隐藏。还有一些辅助技术提供label标签的替代方案，比如aria-label、aria-labelledby或title属性 .form-horizontal 无需再添加.row了 margin对span无效 display:block; line-height button后退&lt;button class=\"btn btn-danger ycx\" onclick=\"javascript :history.back(-1);\"&gt;返回&lt;/button&gt; 居中 文本内容居中：text-center 图片居中：center-block 其他类型元素居中：col-md-offset-X","tags":[{"name":"HTML","slug":"HTML","permalink":"https://kxbk100.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://kxbk100.github.io/tags/CSS/"}]},{"title":"Android学习小记","date":"2017-11-25T02:31:20.000Z","path":"2017/11/25/Android学习小记/","text":"禁止Android不跟随屏幕密度加载不同文件夹的资源 在AndroidManifest.xml文件中添加android:anyDensity=”false”字段 高分辨率，一般我们把图片丢这里mipmap-hdpi调试时默认生成的apk在：app/build/outputs/apk目录下Android Studio 打包时 Signature Version V1 V2 同时勾选V1和V2则所有机型都没问题 生成目录 E:\\wamp64\\www\\EAider\\app\\release 发布apk做代码混淆 爱加密match_parent和fill_parent fill_parent = match_parent（一般用match_parent） wrap_content设置一个视图的尺寸为wrap_content将强制性地使视图扩展以显示全部内容。以TextView和ImageView控件为例，设置为wrap_content将完整显示其内部的文本和图像。布局元素将根据内容更改大小。设置一个视图的尺寸为wrap_content大体等同于设置Windows控件的Autosize属性为True。 layout_gravity和gravity android:gravity属性是对该view中内容的限定，比如一个button上面的text，你可以设置该text相对于view的靠左，靠右等位置 android:layout_gravity是用来设置该view相对与父view的位置，比如一个button在linearlayout里，你想把该button放在linearlayout里靠左、靠右等位置就可以通过该属性设置 android:gravity用于设置View中内容相对于View组件的对齐方式 android:layout_gravity用于设置View组件相对于Container的对齐方式 线性布局 权重用途很大 当android:orientation=&quot;vertical&quot;时，只有水平方向的设置才起作用，垂直方向的设置不起作用。即：left,right,center_horizontal是生效的 当android:orientation=&quot;horizontal&quot;时，只有垂直方向的设置才起作用，水平方向的设置不起作用。即：top,bottom,center_vertical是生效的 分隔线&lt;View android:layout_width=\"match_parent\" android:layout_height=\"1px\" android:background=\"#000000\"/&gt; 布局使用RelativeLayout+LinearLayout的weight属性搭配使用相对布局广告弹出框Demo&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/RelativeLayout1\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:background=\"#00CCCCFF\"&gt; &lt;ImageView android:id=\"@+id/img1\" android:background=\"#000\" android:layout_centerInParent=\"true\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" /&gt; &lt;ImageView android:id=\"@+id/imgCancle\" android:layout_alignRight=\"@id/img1\" android:layout_alignTop=\"@id/img1\" android:background=\"#5555\" android:layout_marginTop=\"-15dp\" android:layout_marginRight=\"-10dp\" android:layout_width=\"28dp\" android:layout_height=\"28dp\" /&gt;&lt;/RelativeLayout&gt; 表格布局帧布局FrameLayout android:foreground:设置改帧布局容器的前景图像 android:foregroundGravity:设置前景图像显示的位置 网格布局GridLayout 默认每个组件都是占一行一列 通过android:layout_rowSpan与android:layout_columnSpan设置了组件横跨多行或者多列的话，如果你要让组件填满横越过的行或列的话，需要添加android:layout_gravity = &quot;fill&quot; 低版本sdk如何使用GridLayout &lt;android.support.v7.widget.GridLayout&gt;，v7包一般在sdk下的sdk\\extras\\android\\support\\v7\\gridlayout目录下 几个单位 dp(dip): device independent pixels(设备独立像素)，不同设备有不同的显示效果，这个和设备硬件有关，一般我们为了支持WVGA、HVGA和QVGA推荐使用这个，不依赖像素 px: pixels(像素)，不同设备显示效果相同，一般我们HVGA代表320x480像素，这个用的比较多 pt: point，是一个标准的长度单位，1pt＝1/72英寸，用于印刷业，非常简单易用 sp: scaled pixels(放大像素)，主要用于字体显示best for textsize 布局层次越少，性能越好设置的drawable并不能自行设置大小，在XML是无法直接设置的，所以需要在Java代码中来进行修改###","tags":[{"name":"Android","slug":"Android","permalink":"https://kxbk100.github.io/tags/Android/"}]}]