<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    

    

    



    <meta charset="utf-8">
    <meta name="referrer" content="no-referrer">
    
    
    
    
    <title>【JavaScript】JS 异步编程及常考面试题 | 冯天祥 | 前端小白的技术博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content>
    <meta name="description" content="title: 【JavaScript】JS 异步编程及常考面试题 date: 2019 年 04 月 08 日 00:27:43categories:typora-root-url: ..typora-copy-images-to: ../images JS 异步编程及常考面试题在上一章节中我们了解了常见 ES6 语法的一些知识点。这一章节我们将会学习异步编程这一块的内容，鉴于异步编程是 JS">
<meta name="keywords" content="前端,技术,冯天祥,fengtx">
<meta property="og:type" content="article">
<meta property="og:title" content="【JavaScript】JS 异步编程及常考面试题">
<meta property="og:url" content="http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/index.html">
<meta property="og:site_name" content="冯天祥">
<meta property="og:description" content="title: 【JavaScript】JS 异步编程及常考面试题 date: 2019 年 04 月 08 日 00:27:43categories:typora-root-url: ..typora-copy-images-to: ../images JS 异步编程及常考面试题在上一章节中我们了解了常见 ES6 语法的一些知识点。这一章节我们将会学习异步编程这一块的内容，鉴于异步编程是 JS">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-10-15T15:44:28.649Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【JavaScript】JS 异步编程及常考面试题">
<meta name="twitter:description" content="title: 【JavaScript】JS 异步编程及常考面试题 date: 2019 年 04 月 08 日 00:27:43categories:typora-root-url: ..typora-copy-images-to: ../images JS 异步编程及常考面试题在上一章节中我们了解了常见 ES6 语法的一些知识点。这一章节我们将会学习异步编程这一块的内容，鉴于异步编程是 JS">
    
        <link rel="alternate" type="application/atom+xml" title="冯天祥" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide">
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">冯天祥</h5>
          <a href="mailto:im.txfeng@gmail.com" title="im.txfeng@gmail.com" class="mail">im.txfeng@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/">
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories">
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives">
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/kxbk100" target="_blank">
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">【JavaScript】JS 异步编程及常考面试题</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">【JavaScript】JS 异步编程及常考面试题</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-04-05T00:55:41.000Z" itemprop="datePublished" class="page-time">
  2020-04-05
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#title-【JavaScript】JS-异步编程及常考面试题-date-2019-年-04-月-08-日-00-27-43"><span class="post-toc-number">1.</span> <span class="post-toc-text">title: 【JavaScript】JS 异步编程及常考面试题 date: 2019 年 04 月 08 日 00:27:43</span></a></li></ol><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#JS-异步编程及常考面试题"><span class="post-toc-number"></span> <span class="post-toc-text">JS 异步编程及常考面试题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#并发（concurrency）和并行（parallelism）区别"><span class="post-toc-number">1.</span> <span class="post-toc-text">并发（concurrency）和并行（parallelism）区别</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#回调函数（Callback）"><span class="post-toc-number">2.</span> <span class="post-toc-text">回调函数（Callback）</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Generator"><span class="post-toc-number">3.</span> <span class="post-toc-text">Generator</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Promise"><span class="post-toc-number">4.</span> <span class="post-toc-text">Promise</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#async-及-await"><span class="post-toc-number">5.</span> <span class="post-toc-text">async 及 await</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#常用定时器函数"><span class="post-toc-number">6.</span> <span class="post-toc-text">常用定时器函数</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#小结"><span class="post-toc-number">7.</span> <span class="post-toc-text">小结</span></a></li></ol>
        </li></nav>
    </aside>


<article id="post-yuque/【JavaScript】JS 异步编程及常考面试题" class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">【JavaScript】JS 异步编程及常考面试题</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-04-05 08:55:41" datetime="2020-04-05T00:55:41.000Z" itemprop="datePublished">2020-04-05</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style="display:none">
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <hr>
<h2 id="title-【JavaScript】JS-异步编程及常考面试题-date-2019-年-04-月-08-日-00-27-43"><a href="#title-【JavaScript】JS-异步编程及常考面试题-date-2019-年-04-月-08-日-00-27-43" class="headerlink" title="title: 【JavaScript】JS 异步编程及常考面试题 date: 2019 年 04 月 08 日 00:27:43"></a>title: 【JavaScript】JS 异步编程及常考面试题 date: 2019 年 04 月 08 日 00:27:43</h2><p>categories:<br>typora-root-url: ..<br>typora-copy-images-to: ../images</p>
<h1 id="JS-异步编程及常考面试题"><a href="#JS-异步编程及常考面试题" class="headerlink" title="JS 异步编程及常考面试题"></a>JS 异步编程及常考面试题</h1><p>在上一章节中我们了解了常见 ES6 语法的一些知识点。这一章节我们将会学习异步编程这一块的内容，鉴于异步编程是 JS 中至关重要的内容，所以我们将会用三个章节来学习异步编程涉及到的重点和难点，同时这一块内容也是面试常考范围，希望大家认真学习。</p>
<h2 id="并发（concurrency）和并行（parallelism）区别"><a href="#并发（concurrency）和并行（parallelism）区别" class="headerlink" title="并发（concurrency）和并行（parallelism）区别"></a>并发（concurrency）和并行（parallelism）区别</h2><blockquote>
<p>涉及面试题：并发与并行的区别？</p>
</blockquote>
<p>异步和这小节的知识点其实并不是一个概念，但是这两个名词确实是很多人都常会混淆的知识点。其实混淆的原因可能只是两个名词在中文上的相似，在英文上来说完全是不同的单词。</p>
<p>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</p>
<p>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</p>
<h2 id="回调函数（Callback）"><a href="#回调函数（Callback）" class="headerlink" title="回调函数（Callback）"></a>回调函数（Callback）</h2><blockquote>
<p>涉及面试题：什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</p>
</blockquote>
<p>回调函数应该是大家经常使用到的，以下代码就是一个回调函数的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>但是回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，你可能就会写出如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">    ajax(url1, () =&gt; &#123;</span><br><span class="line">        // 处理逻辑</span><br><span class="line">        ajax(url2, () =&gt; &#123;</span><br><span class="line">            // 处理逻辑</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上代码看起来不利于阅读和维护，当然，你可能会想说解决这个问题还不简单，把函数分开来写不就得了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function firstAjax() &#123;</span><br><span class="line">  ajax(url1, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">    secondAjax()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">function secondAjax() &#123;</span><br><span class="line">  ajax(url2, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">  // 处理逻辑</span><br><span class="line">  firstAjax()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。</p>
<p>回调地狱的根本问题就是：</p>
<ol>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li>
<li>嵌套函数一多，就很难处理错误</li>
</ol>
<p>当然，回调函数还存在着别的几个缺点，比如不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code>。在接下来的几小节中，我们将来学习通过别的技术解决这些问题。</p>
<h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><blockquote>
<p>涉及面试题：你理解的 Generator 是什么？</p>
</blockquote>
<p><code>Generator</code> 算是 ES6 中难理解的概念之一了，<code>Generator</code> 最大的特点就是可以控制函数的执行。在这一小节中我们不会去讲什么是 <code>Generator</code>，而是把重点放在 <code>Generator</code> 的一些容易困惑的地方。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function *foo(x) &#123;</span><br><span class="line">  let y = 2 * (yield (x + 1))</span><br><span class="line">  let z = yield (y / 3)</span><br><span class="line">  return (x + y + z)</span><br><span class="line">&#125;</span><br><span class="line">let it = foo(5)</span><br><span class="line">console.log(it.next())   // =&gt; &#123;value: 6, done: false&#125;</span><br><span class="line">console.log(it.next(12)) // =&gt; &#123;value: 8, done: false&#125;</span><br><span class="line">console.log(it.next(13)) // =&gt; &#123;value: 42, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>你也许会疑惑为什么会产生与你预想不同的值，接下来就让我为你逐行代码分析原因</p>
<ul>
<li>首先 <code>Generator</code> 函数调用和普通函数不同，它会返回一个迭代器</li>
<li>当执行第一次 <code>next</code> 时，传参会被忽略，并且函数暂停在 <code>yield (x + 1)</code> 处，所以返回 <code>5 + 1 = 6</code></li>
<li>当执行第二次 <code>next</code> 时，传入的参数等于上一个 <code>yield</code> 的返回值，如果你不传参，<code>yield</code> 永远返回 <code>undefined</code>。此时 <code>let y = 2 * 12</code>，所以第二个 <code>yield</code> 等于 <code>2 * 12 / 3 = 8</code></li>
<li>当执行第三次 <code>next</code> 时，传入的参数会传递给 <code>z</code>，所以 <code>z = 13, x = 5, y = 24</code>，相加等于 <code>42</code></li>
</ul>
<p><code>Generator</code> 函数一般见到的不多，其实也于他有点绕有关系，并且一般会配合 co 库去使用。当然，我们可以通过 <code>Generator</code> 函数解决回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function *fetch() &#123;</span><br><span class="line">    yield ajax(url, () =&gt; &#123;&#125;)</span><br><span class="line">    yield ajax(url1, () =&gt; &#123;&#125;)</span><br><span class="line">    yield ajax(url2, () =&gt; &#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">let it = fetch()</span><br><span class="line">let result1 = it.next()</span><br><span class="line">let result2 = it.next()</span><br><span class="line">let result3 = it.next()</span><br></pre></td></tr></table></figure>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote>
<p>涉及面试题：Promise 的特点是什么，分别有什么优缺点？什么是 Promise 链？Promise 构造函数执行和 then 函数执行有什么区别？</p>
</blockquote>
<p><code>Promise</code> 翻译过来就是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态，分别是：</p>
<ol>
<li>等待中（pending）</li>
<li>完成了 （resolved）</li>
<li>拒绝了（rejected）</li>
</ol>
<p>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  resolve(&apos;success&apos;)</span><br><span class="line">  // 无效</span><br><span class="line">  reject(&apos;reject&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当我们在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">  console.log(&apos;new Promise&apos;)</span><br><span class="line">  resolve(&apos;success&apos;)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&apos;finifsh&apos;)</span><br><span class="line">// new Promise -&gt; finifsh</span><br></pre></td></tr></table></figure>
<p><code>Promise</code> 实现了链式调用，也就是说每次调用 <code>then</code> 之后返回的都是一个 <code>Promise</code>，并且是一个全新的 <code>Promise</code>，原因也是因为状态不可变。如果你在 <code>then</code> 中 使用了 <code>return</code>，那么 <code>return</code> 的值会被 <code>Promise.resolve()</code> 包装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve(1)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(res) // =&gt; 1</span><br><span class="line">    return 2 // 包装成 Promise.resolve(2)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">    console.log(res) // =&gt; 2</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>当然了，<code>Promise</code> 也很好地解决了回调地狱的问题，可以把之前的回调地狱例子改写为如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ajax(url)</span><br><span class="line">  .then(res =&gt; &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">      return ajax(url1)</span><br><span class="line">  &#125;).then(res =&gt; &#123;</span><br><span class="line">      console.log(res)</span><br><span class="line">      return ajax(url2)</span><br><span class="line">  &#125;).then(res =&gt; console.log(res))</span><br></pre></td></tr></table></figure>
<p>前面都是在讲述 <code>Promise</code> 的一些优点和特点，其实它也是存在一些缺点的，比如无法取消 <code>Promise</code>，错误需要通过回调函数捕获。</p>
<h2 id="async-及-await"><a href="#async-及-await" class="headerlink" title="async 及 await"></a>async 及 await</h2><blockquote>
<p>涉及面试题：async 及 await 的特点，它们的优点和缺点分别是什么？await 原理是什么？</p>
</blockquote>
<p>一个函数如果加上 <code>async</code> ，那么该函数就会返回一个 <code>Promise</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">  return &quot;1&quot;</span><br><span class="line">&#125;</span><br><span class="line">console.log(test()) // -&gt; Promise &#123;&lt;resolved&gt;: &quot;1&quot;&#125;</span><br></pre></td></tr></table></figure>
<p><code>async</code> 就是将函数返回值使用 <code>Promise.resolve()</code> 包裹了下，和 <code>then</code> 中处理返回值一样，并且 <code>await</code> 只能配套 <code>async</code> 使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">  let value = await sleep()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>async</code> 和 <code>await</code> 可以说是异步终极解决方案了，相比直接使用 <code>Promise</code> 来说，优势在于处理 <code>then</code> 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 <code>then</code> 也很恶心，并且也能优雅地解决回调地狱问题。当然也存在一些缺点，因为 <code>await</code> 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 <code>await</code> 会导致性能上的降低。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">async function test() &#123;</span><br><span class="line">  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span><br><span class="line">  // 如果有依赖性的话，其实就是解决回调地狱的例子了</span><br><span class="line">  await fetch(url)</span><br><span class="line">  await fetch(url1)</span><br><span class="line">  await fetch(url2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看一个使用 <code>await</code> 的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = 0</span><br><span class="line">let b = async () =&gt; &#123;</span><br><span class="line">  a = a + await 10</span><br><span class="line">  console.log(&apos;2&apos;, a) // -&gt; &apos;2&apos; 10</span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line">console.log(&apos;1&apos;, a) // -&gt; &apos;1&apos; 1</span><br></pre></td></tr></table></figure>
<p>对于以上代码你可能会有疑惑，让我来解释下原因</p>
<ul>
<li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为 <code>await</code> 内部实现了 <code>generator</code> ，<code>generator</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来</li>
<li>因为 <code>await</code> 是异步操作，后来的表达式不返回 <code>Promise</code> 的话，就会包装成 <code>Promise.reslove(返回值)</code>，然后会去执行函数外的同步代码</li>
<li>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 0 + 10</code></li>
</ul>
<p>上述解释中提到了 <code>await</code> 内部实现了 <code>generator</code>，其实 <code>await</code> 就是 <code>generator</code> 加上 <code>Promise</code> 的语法糖，且内部实现了自动执行 <code>generator</code>。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。</p>
<h2 id="常用定时器函数"><a href="#常用定时器函数" class="headerlink" title="常用定时器函数"></a>常用定时器函数</h2><blockquote>
<p>涉及面试题：setTimeout、setInterval、requestAnimationFrame 各有什么特点？</p>
</blockquote>
<p>异步编程当然少不了定时器了，常见的定时器函数有 <code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>。我们先来讲讲最常用的<code>setTimeout</code>，很多人认为 <code>setTimeout</code> 是延时多久，那就应该是多久后执行。</p>
<p>其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 <code>setTimeout</code> 不会按期执行。当然了，我们可以通过代码去修正 <code>setTimeout</code>，从而使定时器相对准确</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">let period = 60 * 1000 * 60 * 2</span><br><span class="line">let startTime = new Date().getTime()</span><br><span class="line">let count = 0</span><br><span class="line">let end = new Date().getTime() + period</span><br><span class="line">let interval = 1000</span><br><span class="line">let currentInterval = interval</span><br><span class="line"></span><br><span class="line">function loop() &#123;</span><br><span class="line">  count++</span><br><span class="line">  // 代码执行所消耗的时间</span><br><span class="line">  let offset = new Date().getTime() - (startTime + count * interval);</span><br><span class="line">  let diff = end - new Date().getTime()</span><br><span class="line">  let h = Math.floor(diff / (60 * 1000 * 60))</span><br><span class="line">  let hdiff = diff % (60 * 1000 * 60)</span><br><span class="line">  let m = Math.floor(hdiff / (60 * 1000))</span><br><span class="line">  let mdiff = hdiff % (60 * 1000)</span><br><span class="line">  let s = mdiff / (1000)</span><br><span class="line">  let sCeil = Math.ceil(s)</span><br><span class="line">  let sFloor = Math.floor(s)</span><br><span class="line">  // 得到下一次循环所消耗的时间</span><br><span class="line">  currentInterval = interval - offset</span><br><span class="line">  console.log(&apos;时：&apos;+h, &apos;分：&apos;+m, &apos;毫秒：&apos;+s, &apos;秒向上取整：&apos;+sCeil, &apos;代码执行时间：&apos;+offset, &apos;下次循环间隔&apos;+currentInterval)</span><br><span class="line"></span><br><span class="line">  setTimeout(loop, currentInterval)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(loop, currentInterval)</span><br></pre></td></tr></table></figure>
<p>接下来我们来看 <code>setInterval</code>，其实这个函数作用和 <code>setTimeout</code> 基本一致，只是该函数是每隔一段时间执行一次回调函数。</p>
<p>通常来说不建议使用 <code>setInterval</code>。第一，它和 <code>setTimeout</code> 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function demo() &#123;</span><br><span class="line">  setInterval(function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">  &#125;,1000)</span><br><span class="line">  sleep(2000)</span><br><span class="line">&#125;</span><br><span class="line">demo()</span><br></pre></td></tr></table></figure>
<p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。</p>
<p>如果你有循环定时器的需求，其实完全可以通过 <code>requestAnimationFrame</code> 来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function setInterval(callback, interval) &#123;</span><br><span class="line">  let timer</span><br><span class="line">  const now = Date.now</span><br><span class="line">  let startTime = now()</span><br><span class="line">  let endTime = startTime</span><br><span class="line">  const loop = () =&gt; &#123;</span><br><span class="line">    timer = window.requestAnimationFrame(loop)</span><br><span class="line">    endTime = now()</span><br><span class="line">    if (endTime - startTime &gt;= interval) &#123;</span><br><span class="line">      startTime = endTime = now()</span><br><span class="line">      callback(timer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  timer = window.requestAnimationFrame(loop)</span><br><span class="line">  return timer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let a = 0</span><br><span class="line">setInterval(timer =&gt; &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">  a++</span><br><span class="line">  if (a === 3) cancelAnimationFrame(timer)</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure>
<p>首先 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 <code>setTimeout</code>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>异步编程是 JS 中较难掌握的内容，同时也是很重要的知识点。以上提到的每个知识点其实都可以作为一道面试题，希望大家可以好好掌握以上内容如果大家对于这个章节的内容存在疑问，欢迎在评论区与我互动。</p>
<blockquote>
<p>异步编程相关内容并非一章节就能讲完，需要继续浏览后续章节。</p>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-10-15T15:44:28.649Z" itemprop="dateUpdated">2020-10-15 23:44:28</time>
</span><br>


        
    </div>
    
    <footer>
        <a href="http://fengtx.tk">
            <img src="/img/avatar.jpg" alt="冯天祥">
            冯天祥
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            

            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/&title=《【JavaScript】JS 异步编程及常考面试题》 — 冯天祥&pic=http://fengtx.tk/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/&title=《【JavaScript】JS 异步编程及常考面试题》 — 冯天祥&source=前端小白冯天祥的技术博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《【JavaScript】JS 异步编程及常考面试题》 — 冯天祥&url=http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/&via=http://fengtx.tk" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/04/05/yuque/【Network】HTTP 及 TLS/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">【Network】HTTP 及 TLS</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/04/05/yuque/【JavaScript】jQuery学习小记/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">【JavaScript】jQuery学习小记</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢打赏
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check" data-wechat="/img/wechat.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style="display:none">
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style="display:none">
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>冯天祥 &copy; 2016 - 2020</span>
            <!-- <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span> -->
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/&title=《【JavaScript】JS 异步编程及常考面试题》 — 冯天祥&pic=http://fengtx.tk/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/&title=《【JavaScript】JS 异步编程及常考面试题》 — 冯天祥&source=前端小白冯天祥的技术博客" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《【JavaScript】JS 异步编程及常考面试题》 — 冯天祥&url=http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/&via=http://fengtx.tk" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://fengtx.tk/2020/04/05/yuque/【JavaScript】JS 异步编程及常考面试题/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAN4AAADeCAAAAAB3DOFrAAACsklEQVR42u3aQW7DMAwEwPz/0y7QaxtnSYpNCoxPQeLaGh8sdbWPR3xc38f999eT4/46P89Mzjl84OHh4bWGfj+4/PtnA71nJ4zkvr/8LR4eHt4ar3q55Pz7z5OJIRkDHh4e3ifwJqvZZLjJN3h4eHj/l5ffYP6Y8PDw8D6T14sVqlNCfrVqOHIga8HDw8OLeZOX8rs+L+7v4eHh4Q121aslgPz61eFerQMPDw9vg5fUAvJb9qaTvBbQi4zx8PDw9nh5WJDXqvKKVTUyLpyPh4eHt8zLy0+nqlrVTbhyxIyHh4d3lFfdysovnWxc5ZFxNdTAw8PD2+ZNXtBJHFCdbKqByCP/GQ8PD2/My2H5QrkXQOSPPi9p4eHh4W3wqkWBPIaoTie9OsKLX/Hw8PCWefnlevWsJJiYTAblJ4GHh4c35p3a3JqXpcqM+9IAHh4e3p/zqqWo5G9PBb4vRoiHh4e3xsv3jyav7zwm7j3Wp2EEHh4e3jKvWrEqR6vFWlVvIw0PDw9vjzfpKfWmk8kSvFovwMPDw9vgVYPRPMbNX+X5YnoljMDDw8MbxLiT2tMknK1OPIWiAx4eHt4C7+yitrqdVo1om3g8PDy8o7zq5lM1FJi/6HuRMR4eHt4erxoW5MvZfCsriSTysT29Fx4eHt4hXr4bdnaJfBWPJMyNshY8PDy8o7xqgakX5vbmrt6WGB4eHt4GL29j5bFFHg1P4ony+Xh4eHiHeJOlbTVWSB5iNZ54cX08PDy8Bd7k5TsJZyePporHw8PD2+BNylIbQ+yFHVEMgYeHh3eUl1Sd8iXsZCFencGiABcPDw/vTbwcnAeyeZErLzTg4eHhfTIvv3G+mM4faPLPAB4eHt4eb14VzasJvUJVHkPg4eHhbfMmG2C9Tf1eLSCfeMoHHh4eXsr7AtvlVLk1kqvFAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
